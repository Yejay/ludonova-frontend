This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-07T17:56:04.619Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
- Code comments have been removed.

- Line numbers have been added to the beginning of each line.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<directory_structure>
src/
  main/
    java/
      com/
        bht/
          ludonova/
            config/
              DataInitializer.java
              GameInitializerConfig.java
              OpenAPIConfig.java
              RawgApiConfig.java
              WebConfig.java
            controller/
              AuthController.java
              GameController.java
              GameInstanceController.java
              ReviewController.java
              SteamAuthController.java
              UserController.java
            dto/
              auth/
                AuthenticationResponse.java
                LoginRequest.java
                RefreshTokenRequest.java
                TokenResponse.java
              game/
                AdminGameUpdateDTO.java
                GameInstanceUpdateDTO.java
              gameInstance/
                GameInstanceCreateDTO.java
                GameInstanceResponseDTO.java
                GameInstanceUpdateDTO.java
              rawg/
                RawgGameDTO.java
                RawgSearchResponseDTO.java
              review/
                ReviewCreateDTO.java
                ReviewResponseDTO.java
                ReviewUpdateDTO.java
              steam/
                SteamApiResponseDTO.java
                SteamAuthRequest.java
                SteamUserDTO.java
              user/
                CreateUserDTO.java
                UserDTO.java
                UserUpdateDTO.java
              ErrorResponse.java
            exception/
              AuthenticationException.java
              GameAlreadyAddedException.java
              GameInstanceNotFoundException.java
              GameNotFoundException.java
              GlobalExceptionHandler.java
              LudoNovaException.java
              ReviewNotFoundException.java
              SteamAuthenticationException.java
              UnauthorizedException.java
              UserNotFoundException.java
            mapper/
              GameInstanceMapper.java
            model/
              enums/
                GameSource.java
                GameStatus.java
                Platform.java
                Role.java
              Game.java
              GameInstance.java
              Review.java
              SteamUser.java
              User.java
            repository/
              GameInstanceRepository.java
              GameRepository.java
              ReviewRepository.java
              UserRepository.java
            security/
              AuthenticationExceptionHandler.java
              CustomUserDetailsService.java
              JwtAuthenticationFilter.java
              JwtTokenProvider.java
              SecurityConfig.java
            service/
              auth/
                AuthenticationStrategy.java
                BasicAuthenticationStrategy.java
                SteamAuthenticationStrategy.java
              AuthenticationService.java
              GameInstanceService.java
              GameService.java
              GameSyncService.java
              RawgService.java
              ReviewService.java
              SteamService.java
              UserService.java
            LudoNovaApplication.java
    resources/
      db/
        migration/
          V1__create_base_schema.sql
      application.properties
.env.example
.gitignore
docker-compose.yml
ludonova-overview-backend.md
pom.xml
README.md
setup.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/main/java/com/bht/ludonova/config/DataInitializer.java">
 1: package com.bht.ludonova.config;
 2: import com.bht.ludonova.model.Game;
 3: import com.bht.ludonova.model.GameInstance;
 4: import com.bht.ludonova.model.User;
 5: import com.bht.ludonova.model.enums.GameSource;
 6: import com.bht.ludonova.model.enums.GameStatus;
 7: import com.bht.ludonova.model.enums.Platform;
 8: import com.bht.ludonova.model.enums.Role;
 9: import com.bht.ludonova.repository.GameInstanceRepository;
10: import com.bht.ludonova.repository.GameRepository;
11: import com.bht.ludonova.repository.UserRepository;
12: import org.slf4j.Logger;
13: import org.slf4j.LoggerFactory;
14: import org.springframework.boot.CommandLineRunner;
15: import org.springframework.context.annotation.Bean;
16: import org.springframework.context.annotation.Configuration;
17: import org.springframework.security.crypto.password.PasswordEncoder;
18: import java.time.LocalDate;
19: import java.time.LocalDateTime;
20: import java.util.List;
21: import java.util.Set;
22: @Configuration
23: public class DataInitializer {
24:     private static final Logger log = LoggerFactory.getLogger(DataInitializer.class);
25:     @Bean
26:     CommandLineRunner initDatabase(
27:             UserRepository userRepository,
28:             GameRepository gameRepository,
29:             GameInstanceRepository gameInstanceRepository,
30:             PasswordEncoder passwordEncoder
31:     ) {
32:         return args -> {
33:             User testUser;
34:             if (userRepository.findByUsername("test").isEmpty()) {
35:                 testUser = User.builder()
36:                         .username("test")
37:                         .password(passwordEncoder.encode("test123"))
38:                         .email("test@example.com")
39:                         .role(Role.USER)
40:                         .build();
41:                 testUser = userRepository.save(testUser);
42:                 log.info("Test user created successfully");
43:             } else {
44:                 testUser = userRepository.findByUsername("test").get();
45:             }
46:             if (userRepository.findByUsername("admin").isEmpty()) {
47:                 User adminUser = User.builder()
48:                         .username("admin")
49:                         .password(passwordEncoder.encode("admin123"))
50:                         .email("admin@example.com")
51:                         .role(Role.ADMIN)
52:                         .build();
53:                 userRepository.save(adminUser);
54:                 log.info("Admin user created successfully");
55:             }
56:         };
57:     }
58: }
</file>

<file path="src/main/java/com/bht/ludonova/config/GameInitializerConfig.java">
 1: package com.bht.ludonova.config;
 2: import com.bht.ludonova.service.GameService;
 3: import lombok.RequiredArgsConstructor;
 4: import org.springframework.boot.ApplicationRunner;
 5: import org.springframework.context.annotation.Bean;
 6: import org.springframework.context.annotation.Configuration;
 7: @Configuration
 8: @RequiredArgsConstructor
 9: public class GameInitializerConfig {
10:     private final GameService gameService;
11:     @Bean
12:     public ApplicationRunner initializeGames() {
13:         return args -> gameService.initializeGameDatabase();
14:     }
15: }
</file>

<file path="src/main/java/com/bht/ludonova/config/OpenAPIConfig.java">
 1: package com.bht.ludonova.config;
 2: import io.swagger.v3.oas.models.OpenAPI;
 3: import io.swagger.v3.oas.models.info.Info;
 4: import io.swagger.v3.oas.models.info.License;
 5: import io.swagger.v3.oas.models.Components;
 6: import io.swagger.v3.oas.models.security.SecurityScheme;
 7: import org.springframework.context.annotation.Bean;
 8: import org.springframework.context.annotation.Configuration;
 9: @Configuration
10: public class OpenAPIConfig {
11:     @Bean
12:     public OpenAPI customOpenAPI() {
13:         return new OpenAPI()
14:                 .info(new Info()
15:                         .title("LudoNova API")
16:                         .version("1.0")
17:                         .description("API documentation for LudoNova game tracking application")
18:                         .license(new License().name("Private").url("https://ludonova.com")))
19:                 .components(new Components()
20:                         .addSecuritySchemes("bearer-jwt", new SecurityScheme()
21:                                 .type(SecurityScheme.Type.HTTP)
22:                                 .scheme("bearer")
23:                                 .bearerFormat("JWT")));
24:     }
25: }
</file>

<file path="src/main/java/com/bht/ludonova/config/RawgApiConfig.java">
 1: package com.bht.ludonova.config;
 2: import org.springframework.beans.factory.annotation.Value;
 3: import org.springframework.cache.annotation.EnableCaching;
 4: import org.springframework.context.annotation.Bean;
 5: import org.springframework.context.annotation.Configuration;
 6: import org.springframework.web.reactive.function.client.WebClient;
 7: @Configuration
 8: @EnableCaching
 9: public class RawgApiConfig {
10:     @Value("${rawg.api.key}")
11:     private String apiKey;
12:     @Value("${rawg.api.base-url:https://api.rawg.io/api}")
13:     private String baseUrl;
14:     @Bean
15:     public WebClient rawgWebClient() {
16:         return WebClient.builder()
17:                 .baseUrl(baseUrl)
18:                 .defaultHeader("User-Agent", "LudoNova")
19:                 .build();
20:     }
21: }
</file>

<file path="src/main/java/com/bht/ludonova/config/WebConfig.java">
 1: package com.bht.ludonova.config;
 2: import org.springframework.beans.factory.annotation.Value;
 3: import org.springframework.context.annotation.Bean;
 4: import org.springframework.context.annotation.Configuration;
 5: import org.springframework.web.cors.CorsConfiguration;
 6: import org.springframework.web.cors.CorsConfigurationSource;
 7: import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
 8: import java.util.List;
 9: @Configuration
10: public class WebConfig {
11:     @Value("${cors.allowed-origins}")
12:     private List<String> allowedOrigins;
13:     @Bean
14:     public CorsConfigurationSource corsConfigurationSource() {
15:         CorsConfiguration configuration = new CorsConfiguration();
16:         configuration.setAllowedOrigins(allowedOrigins);
17:         configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
18:         configuration.setAllowedHeaders(List.of(
19:                 "Authorization",
20:                 "Content-Type",
21:                 "X-Requested-With",
22:                 "Accept",
23:                 "Origin",
24:                 "Access-Control-Request-Method",
25:                 "Access-Control-Request-Headers"
26:         ));
27:         configuration.setExposedHeaders(List.of(
28:                 "Access-Control-Allow-Origin",
29:                 "Access-Control-Allow-Credentials"
30:         ));
31:         configuration.setAllowCredentials(true);
32:         configuration.setMaxAge(3600L);
33:         UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
34:         source.registerCorsConfiguration("/**", configuration);
35:         return source;
36:     }
37: }
</file>

<file path="src/main/java/com/bht/ludonova/controller/AuthController.java">
 1: package com.bht.ludonova.controller;
 2: import com.bht.ludonova.dto.auth.AuthenticationResponse;
 3: import com.bht.ludonova.dto.auth.RefreshTokenRequest;
 4: import com.bht.ludonova.dto.auth.LoginRequest;
 5: import com.bht.ludonova.exception.AuthenticationException;
 6: import com.bht.ludonova.service.AuthenticationService;
 7: import jakarta.validation.Valid;
 8: import lombok.extern.slf4j.Slf4j;
 9: import org.springframework.http.ResponseEntity;
10: import org.springframework.web.bind.annotation.*;
11: import java.util.Map;
12: @RestController
13: @RequestMapping("/api/auth")
14: @Slf4j
15: public class AuthController {
16:     private final AuthenticationService authService;
17:     public AuthController(AuthenticationService authService) {
18:         this.authService = authService;
19:     }
20:     @PostMapping("/login")
21:     public ResponseEntity<AuthenticationResponse> login(@Valid @RequestBody LoginRequest loginRequest) {
22:         Map<String, String> credentials = Map.of(
23:                 "username", loginRequest.getUsername(),
24:                 "password", loginRequest.getPassword()
25:         );
26:         AuthenticationResponse response = authService.authenticate("basic", credentials);
27:         return ResponseEntity.ok(response);
28:     }
29:     @PostMapping("/refresh")
30:     public ResponseEntity<AuthenticationResponse> refresh(@Valid @RequestBody RefreshTokenRequest request) {
31:         log.debug("Received refresh token request with token: {}", request.getRefreshToken());
32:         try {
33:             AuthenticationResponse response = authService.refresh(request.getRefreshToken());
34:             return ResponseEntity.ok(response);
35:         } catch (AuthenticationException e) {
36:             log.error("Failed to refresh token", e);
37:             throw new AuthenticationException("Invalid refresh token");
38:         }
39:     }
40: }
</file>

<file path="src/main/java/com/bht/ludonova/controller/GameController.java">
 1: package com.bht.ludonova.controller;
 2: import org.springframework.data.domain.Page;
 3: import org.springframework.data.domain.Pageable;
 4: import org.springframework.data.web.PageableDefault;
 5: import org.springframework.http.ResponseEntity;
 6: import org.springframework.security.access.prepost.PreAuthorize;
 7: import org.springframework.web.bind.annotation.*;
 8: import com.bht.ludonova.model.Game;
 9: import com.bht.ludonova.service.GameService;
10: import io.swagger.v3.oas.annotations.tags.Tag;
11: import lombok.RequiredArgsConstructor;
12: @RestController
13: @RequestMapping("/api/games")
14: @RequiredArgsConstructor
15: @Tag(name = "Games", description = "API for accessing game information")
16: public class GameController {
17:     private final GameService gameService;
18:     @GetMapping
19:     @PreAuthorize("isAuthenticated()")
20:     public Page<Game> searchGames(
21:             @RequestParam(required = false) String query,
22:             @PageableDefault(size = 20) Pageable pageable) {
23:         return gameService.searchGames(query, pageable);
24:     }
25:     @GetMapping("/{id}")
26:     @PreAuthorize("isAuthenticated()")
27:     public ResponseEntity<Game> getGame(@PathVariable Long id) {
28:         return gameService.findById(id)
29:                 .map(ResponseEntity::ok)
30:                 .orElse(ResponseEntity.notFound().build());
31:     }
32: }
</file>

<file path="src/main/java/com/bht/ludonova/controller/GameInstanceController.java">
 1: package com.bht.ludonova.controller;
 2: import java.util.List;
 3: import org.springframework.data.domain.Page;
 4: import org.springframework.data.domain.Pageable;
 5: import org.springframework.http.ResponseEntity;
 6: import org.springframework.security.access.prepost.PreAuthorize;
 7: import org.springframework.security.core.annotation.AuthenticationPrincipal;
 8: import org.springframework.security.core.userdetails.UserDetails;
 9: import org.springframework.web.bind.annotation.*;
10: import com.bht.ludonova.dto.ErrorResponse;
11: import com.bht.ludonova.dto.gameInstance.*;
12: import com.bht.ludonova.model.User;
13: import com.bht.ludonova.model.enums.GameStatus;
14: import com.bht.ludonova.exception.*;
15: import com.bht.ludonova.service.GameInstanceService;
16: import com.bht.ludonova.service.UserService;
17: import jakarta.validation.Valid;
18: import lombok.RequiredArgsConstructor;
19: @RestController
20: @RequestMapping("/api/game-instances")
21: @RequiredArgsConstructor
22: public class GameInstanceController {
23:     private final GameInstanceService gameInstanceService;
24:     private final UserService userService;
25:     @GetMapping
26:     @PreAuthorize("isAuthenticated()")
27:     public ResponseEntity<Page<GameInstanceResponseDTO>> getUserGameInstances(Pageable pageable) {
28:         User currentUser = userService.getCurrentUser();
29:         return ResponseEntity.ok(gameInstanceService.getUserGameInstances(currentUser.getId(), pageable));
30:     }
31:     @GetMapping("/status/{status}")
32:     @PreAuthorize("isAuthenticated()")
33:     public ResponseEntity<List<GameInstanceResponseDTO>> getUserGameInstancesByStatus(
34:             @PathVariable GameStatus status) {
35:         User currentUser = userService.getCurrentUser();
36:         return ResponseEntity.ok(gameInstanceService.getUserGameInstancesByStatus(currentUser.getId(), status));
37:     }
38:     @PostMapping
39:     @PreAuthorize("isAuthenticated()")
40:     public ResponseEntity<?> createGameInstance(@RequestBody @Valid GameInstanceCreateDTO dto) {
41:         try {
42:             User currentUser = userService.getCurrentUser();
43:             GameInstanceResponseDTO created = gameInstanceService.createGameInstance(currentUser.getId(), dto);
44:             return ResponseEntity.ok(created);
45:         } catch (GameAlreadyAddedException e) {
46:             return ResponseEntity
47:                     .badRequest()
48:                     .body(new ErrorResponse("GAME_ALREADY_EXISTS", "Game already in your list", 400));
49:         } catch (GameNotFoundException e) {
50:             return ResponseEntity
51:                     .notFound()
52:                     .build();
53:         }
54:     }
55:     @PutMapping("/{id}")
56:     @PreAuthorize("isAuthenticated()")
57:     public ResponseEntity<?> updateGameInstance(
58:             @PathVariable Long id,
59:             @RequestBody @Valid GameInstanceUpdateDTO dto) {
60:         try {
61:             User currentUser = userService.getCurrentUser();
62:             GameInstanceResponseDTO updated = gameInstanceService.updateGameInstance(currentUser.getId(), id, dto);
63:             return ResponseEntity.ok(updated);
64:         } catch (GameInstanceNotFoundException | UnauthorizedException e) {
65:             return ResponseEntity.notFound().build();
66:         }
67:     }
68:     @PatchMapping("/{id}/status")
69:     @PreAuthorize("isAuthenticated()")
70:     public ResponseEntity<?> updateGameStatus(
71:             @PathVariable Long id,
72:             @RequestParam GameStatus status) {
73:         try {
74:             User currentUser = userService.getCurrentUser();
75:             GameInstanceResponseDTO updated = gameInstanceService.updateGameStatus(currentUser.getId(), id, status);
76:             return ResponseEntity.ok(updated);
77:         } catch (GameInstanceNotFoundException | UnauthorizedException e) {
78:             return ResponseEntity.notFound().build();
79:         }
80:     }
81:     @DeleteMapping("/{id}")
82:     @PreAuthorize("isAuthenticated()")
83:     public ResponseEntity<Void> deleteGameInstance(@PathVariable Long id) {
84:         try {
85:             User currentUser = userService.getCurrentUser();
86:             gameInstanceService.deleteGameInstance(currentUser.getId(), id);
87:             return ResponseEntity.noContent().build();
88:         } catch (GameInstanceNotFoundException | UnauthorizedException e) {
89:             return ResponseEntity.notFound().build();
90:         }
91:     }
92: }
</file>

<file path="src/main/java/com/bht/ludonova/controller/ReviewController.java">
 1: package com.bht.ludonova.controller;
 2: import com.bht.ludonova.dto.review.ReviewCreateDTO;
 3: import com.bht.ludonova.dto.review.ReviewResponseDTO;
 4: import com.bht.ludonova.dto.review.ReviewUpdateDTO;
 5: import com.bht.ludonova.service.ReviewService;
 6: import com.bht.ludonova.service.UserService;
 7: import jakarta.validation.Valid;
 8: import lombok.RequiredArgsConstructor;
 9: import org.springframework.http.ResponseEntity;
10: import org.springframework.security.access.prepost.PreAuthorize;
11: import org.springframework.web.bind.annotation.*;
12: import java.util.List;
13: @RestController
14: @RequestMapping("/api/reviews")
15: @RequiredArgsConstructor
16: public class ReviewController {
17:     private final ReviewService reviewService;
18:     private final UserService userService;
19:     @PostMapping
20:     @PreAuthorize("isAuthenticated()")
21:     public ResponseEntity<ReviewResponseDTO> createReview(@RequestBody @Valid ReviewCreateDTO dto) {
22:         Long userId = userService.getCurrentUser().getId();
23:         return ResponseEntity.ok(reviewService.createReview(userId, dto));
24:     }
25:     @PutMapping("/{id}")
26:     @PreAuthorize("isAuthenticated()")
27:     public ResponseEntity<ReviewResponseDTO> updateReview(@PathVariable Long id, @RequestBody @Valid ReviewUpdateDTO dto) {
28:         Long userId = userService.getCurrentUser().getId();
29:         return ResponseEntity.ok(reviewService.updateReview(userId, id, dto));
30:     }
31:     @DeleteMapping("/{id}")
32:     @PreAuthorize("isAuthenticated()")
33:     public ResponseEntity<Void> deleteReview(@PathVariable Long id) {
34:         Long userId = userService.getCurrentUser().getId();
35:         reviewService.deleteReview(userId, id);
36:         return ResponseEntity.noContent().build();
37:     }
38:     @GetMapping("/game/{gameId}")
39:     @PreAuthorize("isAuthenticated()")
40:     public ResponseEntity<List<ReviewResponseDTO>> getReviewsByGame(@PathVariable Long gameId) {
41:         return ResponseEntity.ok(reviewService.getReviewsByGame(gameId));
42:     }
43:     @GetMapping("/user/{userId}")
44:     @PreAuthorize("isAuthenticated()")
45:     public ResponseEntity<List<ReviewResponseDTO>> getReviewsByUser(@PathVariable Long userId) {
46:         return ResponseEntity.ok(reviewService.getReviewsByUser(userId));
47:     }
48:     @GetMapping("/{id}")
49:     @PreAuthorize("isAuthenticated()")
50:     public ResponseEntity<ReviewResponseDTO> getReviewById(@PathVariable Long id) {
51:         return ResponseEntity.ok(reviewService.getReviewByIdResponse(id));
52:     }
53: }
</file>

<file path="src/main/java/com/bht/ludonova/controller/SteamAuthController.java">
 1: package com.bht.ludonova.controller;
 2: import com.bht.ludonova.dto.auth.AuthenticationResponse;
 3: import com.bht.ludonova.exception.SteamAuthenticationException;
 4: import com.bht.ludonova.service.AuthenticationService;
 5: import lombok.extern.slf4j.Slf4j;
 6: import org.springframework.beans.factory.annotation.Value;
 7: import org.springframework.http.ResponseEntity;
 8: import org.springframework.web.bind.annotation.GetMapping;
 9: import org.springframework.web.bind.annotation.RequestMapping;
10: import org.springframework.web.bind.annotation.RequestParam;
11: import org.springframework.web.bind.annotation.RestController;
12: import java.net.URLEncoder;
13: import java.nio.charset.StandardCharsets;
14: import java.util.Map;
15: @RestController
16: @RequestMapping("/api/auth/steam")
17: @Slf4j
18: public class SteamAuthController {
19:     private final AuthenticationService authService;
20:     @Value("${steam.return.url}")
21:     private String returnUrl;
22:     @Value("${steam.realm.url}")
23:     private String realmUrl;
24:     public SteamAuthController(AuthenticationService authService) {
25:         this.authService = authService;
26:     }
27:     @GetMapping("/login")
28:     public ResponseEntity<Map<String, String>> steamLogin() {
29:         try {
30:             String steamOpenIdUrl = buildSteamOpenIdUrl();
31:             return ResponseEntity.ok(Map.of("url", steamOpenIdUrl));
32:         } catch (Exception e) {
33:             log.error("Error generating Steam login URL", e);
34:             throw new SteamAuthenticationException("Failed to generate Steam login URL");
35:         }
36:     }
37:     @GetMapping("/return")
38:     public ResponseEntity<AuthenticationResponse> steamReturn(@RequestParam Map<String, String> params) {
39:         log.debug("Received Steam return params: {}", params);
40:         AuthenticationResponse response = authService.authenticate("steam", params);
41:         return ResponseEntity.ok(response);
42:     }
43:     private String buildSteamOpenIdUrl() {
44:         try {
45:             String encodedReturnUrl = URLEncoder.encode(returnUrl, StandardCharsets.UTF_8);
46:             String encodedRealm = URLEncoder.encode(realmUrl, StandardCharsets.UTF_8);
47:             return String.format(
48:                     "https://steamcommunity.com/openid/login" +
49:                             "?openid.ns=%s" +
50:                             "&openid.mode=checkid_setup" +
51:                             "&openid.return_to=%s" +
52:                             "&openid.realm=%s" +
53:                             "&openid.identity=%s" +
54:                             "&openid.claimed_id=%s",
55:                     URLEncoder.encode("http://specs.openid.net/auth/2.0", StandardCharsets.UTF_8),
56:                     encodedReturnUrl,
57:                     encodedRealm,
58:                     URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8),
59:                     URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8)
60:             );
61:         } catch (Exception e) {
62:             log.error("Error building Steam OpenID URL", e);
63:             throw new SteamAuthenticationException("Failed to build Steam authentication URL");
64:         }
65:     }
66: }
</file>

<file path="src/main/java/com/bht/ludonova/controller/UserController.java">
  1: package com.bht.ludonova.controller;
  2: import com.bht.ludonova.dto.ErrorResponse;
  3: import com.bht.ludonova.dto.user.CreateUserDTO;
  4: import com.bht.ludonova.dto.user.UserDTO;
  5: import com.bht.ludonova.dto.user.UserUpdateDTO;
  6: import com.bht.ludonova.model.User;
  7: import com.bht.ludonova.model.enums.Role;
  8: import com.bht.ludonova.repository.UserRepository;
  9: import com.bht.ludonova.service.UserService;
 10: import jakarta.validation.Valid;
 11: import org.springframework.beans.factory.annotation.Autowired;
 12: import org.springframework.http.HttpStatus;
 13: import org.springframework.http.ResponseEntity;
 14: import org.springframework.security.access.prepost.PreAuthorize;
 15: import org.springframework.security.core.annotation.AuthenticationPrincipal;
 16: import org.springframework.security.core.userdetails.UserDetails;
 17: import org.springframework.web.bind.annotation.*;
 18: import java.util.List;
 19: @RestController
 20: @RequestMapping("/api/user")
 21: public class UserController {
 22:     private final UserRepository userRepository;
 23:     private final UserService userService;
 24:     @Autowired
 25:     public UserController(UserRepository userRepository, UserService userService) {
 26:         this.userRepository = userRepository;
 27:         this.userService = userService;
 28:     }
 29:     @GetMapping("/current")
 30:     public ResponseEntity<User> getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
 31:         return userRepository.findByUsername(userDetails.getUsername())
 32:                 .map(user -> {
 33:                     user.setPassword(null);
 34:                     return ResponseEntity.ok(user);
 35:                 })
 36:                 .orElse(ResponseEntity.notFound().build());
 37:     }
 38:     @PutMapping("/current")
 39:     public ResponseEntity<User> updateCurrentUser(
 40:             @AuthenticationPrincipal UserDetails userDetails,
 41:             @RequestBody UserUpdateDTO updateDTO) {
 42:         return userRepository.findByUsername(userDetails.getUsername())
 43:                 .map(user -> {
 44:                     if (updateDTO.getEmail() != null) {
 45:                         user.setEmail(updateDTO.getEmail());
 46:                     }
 47:                     User updatedUser = userRepository.save(user);
 48:                     updatedUser.setPassword(null);
 49:                     return ResponseEntity.ok(updatedUser);
 50:                 })
 51:                 .orElse(ResponseEntity.notFound().build());
 52:     }
 53:     @PostMapping("/create")
 54:     @PreAuthorize("hasRole('ROLE_ADMIN')")
 55:     public ResponseEntity<?> createUser(@Valid @RequestBody CreateUserDTO createUserDTO) {
 56:         try {
 57:             UserDTO createdUser = userService.createUser(createUserDTO);
 58:             return ResponseEntity.status(HttpStatus.CREATED).body(createdUser);
 59:         } catch (IllegalArgumentException e) {
 60:             return ResponseEntity
 61:                     .badRequest()
 62:                     .body(new ErrorResponse("USER_EXISTS", e.getMessage(), HttpStatus.BAD_REQUEST.value()));
 63:         }
 64:     }
 65:     @GetMapping
 66:     @PreAuthorize("hasRole('ROLE_ADMIN')")
 67:     public ResponseEntity<List<User>> getAllUsers() {
 68:         List<User> users = userRepository.findAll();
 69:         users.forEach(user -> user.setPassword(null));
 70:         return ResponseEntity.ok(users);
 71:     }
 72:     @GetMapping("/{id}")
 73:     @PreAuthorize("hasRole('ROLE_ADMIN')")
 74:     public ResponseEntity<User> getUser(@PathVariable Long id) {
 75:         return userRepository.findById(id)
 76:                 .map(user -> {
 77:                     user.setPassword(null);
 78:                     return ResponseEntity.ok(user);
 79:                 })
 80:                 .orElse(ResponseEntity.notFound().build());
 81:     }
 82:     @PutMapping("/{id}")
 83:     @PreAuthorize("hasRole('ROLE_ADMIN')")
 84:     public ResponseEntity<User> updateUser(
 85:             @PathVariable Long id,
 86:             @RequestBody UserUpdateDTO updateDTO) {
 87:         return userRepository.findById(id)
 88:                 .map(user -> {
 89:                     if (updateDTO.getEmail() != null) {
 90:                         user.setEmail(updateDTO.getEmail());
 91:                     }
 92:                     if (updateDTO.getRole() != null) {
 93:                         user.setRole(updateDTO.getRole());
 94:                     }
 95:                     User updatedUser = userRepository.save(user);
 96:                     updatedUser.setPassword(null);
 97:                     return ResponseEntity.ok(updatedUser);
 98:                 })
 99:                 .orElse(ResponseEntity.notFound().build());
100:     }
101:     @DeleteMapping("/{id}")
102:     @PreAuthorize("hasRole('ROLE_ADMIN')")
103:     public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
104:         if (userRepository.existsById(id)) {
105:             userRepository.deleteById(id);
106:             return ResponseEntity.ok().build();
107:         }
108:         return ResponseEntity.notFound().build();
109:     }
110: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/AuthenticationResponse.java">
1: package com.bht.ludonova.dto.auth;
2: import com.bht.ludonova.dto.user.UserDTO;
3: import lombok.Data;
4: @Data
5: public class AuthenticationResponse {
6:     private final TokenResponse tokens;
7:     private final UserDTO user;
8: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/LoginRequest.java">
1: package com.bht.ludonova.dto.auth;
2: import lombok.Data;
3: @Data
4: public class LoginRequest {
5:     private String username;
6:     private String password;
7: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/RefreshTokenRequest.java">
1: package com.bht.ludonova.dto.auth;
2: import jakarta.validation.constraints.NotBlank;
3: import lombok.Data;
4: @Data
5: public class RefreshTokenRequest {
6:     @NotBlank(message = "Refresh token is required")
7:     private String refreshToken;
8: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/TokenResponse.java">
 1: package com.bht.ludonova.dto.auth;
 2: import lombok.Data;
 3: @Data
 4: public class TokenResponse {
 5:     private final String accessToken;
 6:     private final String refreshToken;
 7:     private final String tokenType;
 8:     private final long expiresIn;
 9:     public static TokenResponse of(String accessToken, String refreshToken, long expiresIn) {
10:         return new TokenResponse(accessToken, refreshToken, "Bearer", expiresIn);
11:     }
12: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/game/AdminGameUpdateDTO.java">
 1: package com.bht.ludonova.dto.game;
 2: import com.bht.ludonova.model.enums.GameSource;
 3: import com.bht.ludonova.model.enums.Platform;
 4: import lombok.Data;
 5: import java.time.LocalDate;
 6: import java.util.Set;
 7: @Data
 8: public class AdminGameUpdateDTO {
 9:     private String title;
10:     private Platform platform;
11:     private LocalDate releaseDate;
12:     private Set<String> genres;
13:     private GameSource source;
14:     private String apiId;
15: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/game/GameInstanceUpdateDTO.java">
1: package com.bht.ludonova.dto.game;
2: import lombok.Data;
3: @Data
4: public class GameInstanceUpdateDTO {
5:     private String status;
6:     private Integer progressPercentage;
7:     private Integer playTime;
8:     private String notes;
9: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/gameInstance/GameInstanceCreateDTO.java">
 1: package com.bht.ludonova.dto.gameInstance;
 2: import jakarta.validation.constraints.NotNull;
 3: import lombok.Data;
 4: import com.bht.ludonova.model.enums.GameStatus;
 5: @Data
 6: public class GameInstanceCreateDTO {
 7:     @NotNull
 8:     private Long gameId;
 9:     @NotNull
10:     private GameStatus status;
11:     private Integer progressPercentage;
12:     private Integer playTime;
13:     private String notes;
14: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/gameInstance/GameInstanceResponseDTO.java">
 1: package com.bht.ludonova.dto.gameInstance;
 2: import java.time.LocalDateTime;
 3: import java.util.Set;
 4: import lombok.Data;
 5: import com.bht.ludonova.model.enums.GameStatus;
 6: @Data
 7: public class GameInstanceResponseDTO {
 8:     private Long id;
 9:     private Long gameId;
10:     private String gameTitle;
11:     private String backgroundImage;
12:     private GameStatus status;
13:     private Integer progressPercentage;
14:     private Integer playTime;
15:     private String notes;
16:     private LocalDateTime lastPlayed;
17:     private LocalDateTime addedAt;
18:     private Set<String> genres;
19: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/gameInstance/GameInstanceUpdateDTO.java">
 1: package com.bht.ludonova.dto.gameInstance;
 2: import lombok.Data;
 3: import com.bht.ludonova.model.enums.GameStatus;
 4: @Data
 5: public class GameInstanceUpdateDTO {
 6:     private GameStatus status;
 7:     private Integer progressPercentage;
 8:     private Integer playTime;
 9:     private String notes;
10: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/rawg/RawgGameDTO.java">
 1: package com.bht.ludonova.dto.rawg;
 2: import com.fasterxml.jackson.annotation.JsonProperty;
 3: import lombok.Data;
 4: import java.time.LocalDate;
 5: import java.util.List;
 6: @Data
 7: public class RawgGameDTO {
 8:     private Long id;
 9:     private String slug;
10:     private String name;
11:     @JsonProperty("released")
12:     private LocalDate releaseDate;
13:     @JsonProperty("background_image")
14:     private String backgroundImage;
15:     private Double rating;
16:     @JsonProperty("ratings_count")
17:     private Integer ratingsCount;
18:     private List<PlatformInfo> platforms;
19:     private List<Genre> genres;
20:     @Data
21:     public static class PlatformInfo {
22:         private Platform platform;
23:     }
24:     @Data
25:     public static class Platform {
26:         private Long id;
27:         private String name;
28:         private String slug;
29:     }
30:     @Data
31:     public static class Genre {
32:         private Long id;
33:         private String name;
34:         private String slug;
35:     }
36: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/rawg/RawgSearchResponseDTO.java">
 1: package com.bht.ludonova.dto.rawg;
 2: import lombok.Data;
 3: import java.util.List;
 4: @Data
 5: public class RawgSearchResponseDTO {
 6:     private Integer count;
 7:     private String next;
 8:     private String previous;
 9:     private List<RawgGameDTO> results;
10: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/review/ReviewCreateDTO.java">
 1: package com.bht.ludonova.dto.review;
 2: import jakarta.validation.constraints.Max;
 3: import jakarta.validation.constraints.Min;
 4: import jakarta.validation.constraints.NotNull;
 5: import lombok.Data;
 6: @Data
 7: public class ReviewCreateDTO {
 8:     @NotNull
 9:     private Long gameId;
10:     @NotNull
11:     @Min(1)
12:     @Max(5)
13:     private Integer rating;
14:     private String reviewText;
15: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/review/ReviewResponseDTO.java">
 1: package com.bht.ludonova.dto.review;
 2: import lombok.Builder;
 3: import lombok.Data;
 4: import java.time.LocalDateTime;
 5: @Data
 6: @Builder
 7: public class ReviewResponseDTO {
 8:     private Long id;
 9:     private Long gameId;
10:     private String gameTitle;
11:     private Long userId;
12:     private Integer rating;
13:     private String reviewText;
14:     private LocalDateTime createdAt;
15: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/review/ReviewUpdateDTO.java">
 1: package com.bht.ludonova.dto.review;
 2: import jakarta.validation.constraints.Max;
 3: import jakarta.validation.constraints.Min;
 4: import lombok.Data;
 5: @Data
 6: public class ReviewUpdateDTO {
 7:     @Min(1)
 8:     @Max(5)
 9:     private Integer rating;
10:     private String reviewText;
11: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/steam/SteamApiResponseDTO.java">
 1: package com.bht.ludonova.dto.steam;
 2: import com.fasterxml.jackson.annotation.JsonProperty;
 3: import lombok.Data;
 4: import java.util.List;
 5: @Data
 6: public class SteamApiResponseDTO {
 7:     private Response response;
 8:     @Data
 9:     public static class Response {
10:         private List<Player> players;
11:     }
12:     @Data
13:     public static class Player {
14:         @JsonProperty("steamid")
15:         private String steamId;
16:         @JsonProperty("personaname")
17:         private String personaName;
18:         @JsonProperty("profileurl")
19:         private String profileUrl;
20:         @JsonProperty("avatar")
21:         private String avatarUrl;
22:     }
23: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/steam/SteamAuthRequest.java">
1: package com.bht.ludonova.dto.steam;
2: import lombok.Data;
3: import java.util.Map;
4: @Data
5: public class SteamAuthRequest {
6:     private final Map<String, String> openIdParams;
7: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/steam/SteamUserDTO.java">
1: package com.bht.ludonova.dto.steam;
2: import lombok.Data;
3: @Data
4: public class SteamUserDTO {
5:     private String steamId;
6:     private String personaName;
7:     private String profileUrl;
8:     private String avatarUrl;
9: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/user/CreateUserDTO.java">
 1: package com.bht.ludonova.dto.user;
 2: import com.bht.ludonova.model.enums.Role;
 3: import jakarta.validation.constraints.Email;
 4: import jakarta.validation.constraints.NotBlank;
 5: import jakarta.validation.constraints.NotNull;
 6: import jakarta.validation.constraints.Size;
 7: import lombok.Data;
 8: @Data
 9: public class CreateUserDTO {
10:     @NotBlank(message = "Username is required")
11:     @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
12:     private String username;
13:     @NotBlank(message = "Password is required")
14:     @Size(min = 6, message = "Password must be at least 6 characters")
15:     private String password;
16:     @Email(message = "Invalid email format")
17:     private String email;
18:     @NotNull(message = "Role is required")
19:     private Role role = Role.USER;
20: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/user/UserDTO.java">
 1: package com.bht.ludonova.dto.user;
 2: import com.bht.ludonova.dto.steam.SteamUserDTO;
 3: import com.bht.ludonova.model.enums.Role;
 4: import lombok.Data;
 5: @Data
 6: public class UserDTO {
 7:     private Long id;
 8:     private String username;
 9:     private String email;
10:     private Role role;
11:     private SteamUserDTO steamUser;
12: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/user/UserUpdateDTO.java">
1: package com.bht.ludonova.dto.user;
2: import com.bht.ludonova.model.enums.Role;
3: import lombok.Data;
4: @Data
5: public class UserUpdateDTO {
6:     private String email;
7:     private Role role;
8: }
</file>

<file path="src/main/java/com/bht/ludonova/dto/ErrorResponse.java">
1: package com.bht.ludonova.dto;
2: import lombok.Data;
3: @Data
4: public class ErrorResponse {
5:     private final String errorCode;
6:     private final String message;
7:     private final int status;
8: }
</file>

<file path="src/main/java/com/bht/ludonova/exception/AuthenticationException.java">
1: package com.bht.ludonova.exception;
2: public class AuthenticationException extends LudoNovaException {
3:     public AuthenticationException(String message) {
4:         super(message, "AUTH_ERROR");
5:     }
6: }
</file>

<file path="src/main/java/com/bht/ludonova/exception/GameAlreadyAddedException.java">
1: package com.bht.ludonova.exception;
2: public class GameAlreadyAddedException extends RuntimeException {
3:     public GameAlreadyAddedException(String message) {
4:         super(message);
5:     }
6: }
</file>

<file path="src/main/java/com/bht/ludonova/exception/GameInstanceNotFoundException.java">
1: package com.bht.ludonova.exception;
2: public class GameInstanceNotFoundException extends RuntimeException {
3:     public GameInstanceNotFoundException(String message) {
4:         super(message);
5:     }
6: }
</file>

<file path="src/main/java/com/bht/ludonova/exception/GameNotFoundException.java">
1: package com.bht.ludonova.exception;
2: public class GameNotFoundException extends RuntimeException {
3:     public GameNotFoundException(String message) {
4:         super(message);
5:     }
6: }
</file>

<file path="src/main/java/com/bht/ludonova/exception/GlobalExceptionHandler.java">
 1: package com.bht.ludonova.exception;
 2: import com.bht.ludonova.dto.ErrorResponse;
 3: import org.springframework.http.HttpStatus;
 4: import org.springframework.http.ResponseEntity;
 5: import org.springframework.validation.FieldError;
 6: import org.springframework.web.bind.MethodArgumentNotValidException;
 7: import org.springframework.web.bind.annotation.ExceptionHandler;
 8: import org.springframework.web.bind.annotation.RestControllerAdvice;
 9: import java.util.HashMap;
10: import java.util.Map;
11: @RestControllerAdvice
12: public class GlobalExceptionHandler {
13:     @ExceptionHandler(AuthenticationException.class)
14:     public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {
15:         ErrorResponse error = new ErrorResponse(
16:                 ex.getErrorCode(),
17:                 ex.getMessage(),
18:                 HttpStatus.UNAUTHORIZED.value()
19:         );
20:         return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
21:     }
22:     @ExceptionHandler(SteamAuthenticationException.class)
23:     public ResponseEntity<ErrorResponse> handleSteamAuthenticationException(SteamAuthenticationException ex) {
24:         ErrorResponse error = new ErrorResponse(
25:                 ex.getErrorCode(),
26:                 ex.getMessage(),
27:                 HttpStatus.UNAUTHORIZED.value()
28:         );
29:         return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
30:     }
31:     @ExceptionHandler(Exception.class)
32:     public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
33:         ErrorResponse error = new ErrorResponse(
34:                 "INTERNAL_ERROR",
35:                 "An unexpected error occurred",
36:                 HttpStatus.INTERNAL_SERVER_ERROR.value()
37:         );
38:         return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
39:     }
40:     @ExceptionHandler(IllegalArgumentException.class)
41:     public ResponseEntity<ErrorResponse> handleIllegalArgumentException(IllegalArgumentException ex) {
42:         ErrorResponse error = new ErrorResponse(
43:                 "VALIDATION_ERROR",
44:                 ex.getMessage(),
45:                 HttpStatus.BAD_REQUEST.value()
46:         );
47:         return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
48:     }
49:     @ExceptionHandler(MethodArgumentNotValidException.class)
50:     public ResponseEntity<ErrorResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
51:         Map<String, String> errors = new HashMap<>();
52:         ex.getBindingResult().getAllErrors().forEach((error) -> {
53:             String fieldName = ((FieldError) error).getField();
54:             String errorMessage = error.getDefaultMessage();
55:             errors.put(fieldName, errorMessage);
56:         });
57:         ErrorResponse error = new ErrorResponse(
58:                 "VALIDATION_ERROR",
59:                 "Validation failed: " + errors,
60:                 HttpStatus.BAD_REQUEST.value()
61:         );
62:         return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
63:     }
64:     @ExceptionHandler(ReviewNotFoundException.class)
65:     public ResponseEntity<ErrorResponse> handleReviewNotFoundException(ReviewNotFoundException ex) {
66:         ErrorResponse error = new ErrorResponse(
67:                 "REVIEW_NOT_FOUND",
68:                 ex.getMessage(),
69:                 HttpStatus.NOT_FOUND.value()
70:         );
71:         return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
72:     }
73: }
</file>

<file path="src/main/java/com/bht/ludonova/exception/LudoNovaException.java">
 1: package com.bht.ludonova.exception;
 2: public class LudoNovaException extends RuntimeException {
 3:     private final String errorCode;
 4:     public LudoNovaException(String message, String errorCode) {
 5:         super(message);
 6:         this.errorCode = errorCode;
 7:     }
 8:     public String getErrorCode() {
 9:         return errorCode;
10:     }
11: }
</file>

<file path="src/main/java/com/bht/ludonova/exception/ReviewNotFoundException.java">
1: package com.bht.ludonova.exception;
2: public class ReviewNotFoundException extends RuntimeException {
3:     public ReviewNotFoundException(String message) {
4:         super(message);
5:     }
6: }
</file>

<file path="src/main/java/com/bht/ludonova/exception/SteamAuthenticationException.java">
1: package com.bht.ludonova.exception;
2: public class SteamAuthenticationException extends AuthenticationException {
3:     public SteamAuthenticationException(String message) {
4:         super("Steam authentication failed: " + message);
5:     }
6: }
</file>

<file path="src/main/java/com/bht/ludonova/exception/UnauthorizedException.java">
1: package com.bht.ludonova.exception;
2: public class UnauthorizedException extends RuntimeException {
3:     public UnauthorizedException(String message) {
4:         super(message);
5:     }
6: }
</file>

<file path="src/main/java/com/bht/ludonova/exception/UserNotFoundException.java">
1: package com.bht.ludonova.exception;
2: public class UserNotFoundException extends RuntimeException {
3:     public UserNotFoundException(String message) {
4:         super(message);
5:     }
6: }
</file>

<file path="src/main/java/com/bht/ludonova/mapper/GameInstanceMapper.java">
 1: package com.bht.ludonova.mapper;
 2: import java.util.Collections;
 3: import java.util.List;
 4: import java.util.stream.Collectors;
 5: import org.springframework.data.domain.Page;
 6: import org.springframework.stereotype.Component;
 7: import lombok.RequiredArgsConstructor;
 8: import com.bht.ludonova.dto.gameInstance.GameInstanceResponseDTO;
 9: import com.bht.ludonova.model.GameInstance;
10: @Component
11: @RequiredArgsConstructor
12: public class GameInstanceMapper {
13:     public GameInstanceResponseDTO toDTO(GameInstance instance) {
14:         if (instance == null) {
15:             return null;
16:         }
17:         GameInstanceResponseDTO dto = new GameInstanceResponseDTO();
18:         dto.setId(instance.getId());
19:         dto.setGameId(instance.getGame().getId());
20:         dto.setGameTitle(instance.getGame().getTitle());
21:         dto.setBackgroundImage(instance.getGame().getBackgroundImage());
22:         dto.setStatus(instance.getStatus());
23:         dto.setProgressPercentage(instance.getProgressPercentage());
24:         dto.setPlayTime(instance.getPlayTime());
25:         dto.setNotes(instance.getNotes());
26:         dto.setLastPlayed(instance.getLastPlayed());
27:         dto.setAddedAt(instance.getAddedAt());
28:         dto.setGenres(instance.getGame().getGenres());
29:         return dto;
30:     }
31:     public List<GameInstanceResponseDTO> toDTOList(List<GameInstance> instances) {
32:         if (instances == null) {
33:             return Collections.emptyList();
34:         }
35:         return instances.stream()
36:                 .map(this::toDTO)
37:                 .collect(Collectors.toList());
38:     }
39:     public Page<GameInstanceResponseDTO> toDTOPage(Page<GameInstance> page) {
40:         if (page == null) {
41:             return Page.empty();
42:         }
43:         return page.map(this::toDTO);
44:     }
45: }
</file>

<file path="src/main/java/com/bht/ludonova/model/enums/GameSource.java">
1: package com.bht.ludonova.model.enums;
2: import lombok.Getter;
3: @Getter
4: public enum GameSource {
5:     STEAM,
6:     RAWG,
7:     MANUAL
8: }
</file>

<file path="src/main/java/com/bht/ludonova/model/enums/GameStatus.java">
1: package com.bht.ludonova.model.enums;
2: import lombok.Getter;
3: @Getter
4: public enum GameStatus {
5:     PLAYING,
6:     COMPLETED,
7:     PLAN_TO_PLAY,
8:     DROPPED
9: }
</file>

<file path="src/main/java/com/bht/ludonova/model/enums/Platform.java">
 1: package com.bht.ludonova.model.enums;
 2: import lombok.Getter;
 3: @Getter
 4: public enum Platform {
 5:     PS1("PlayStation"),
 6:     PS2("PlayStation 2"),
 7:     PS3("PlayStation 3"),
 8:     PS4("PlayStation 4"),
 9:     PS5("PlayStation 5"),
10:     XBOX("Xbox"),
11:     XBOX_360("Xbox 360"),
12:     XBOX_ONE("Xbox One"),
13:     XBOX_SERIES_X("Xbox Series X"),
14:     XBOX_SERIES_S("Xbox Series S"),
15:     SWITCH("Nintendo Switch"),
16:     WII("Nintendo Wii"),
17:     WII_U("Nintendo Wii U"),
18:     NINTENDO_3DS("Nintendo 3DS"),
19:     NINTENDO_DS("Nintendo DS"),
20:     PC("PC"),
21:     MAC("Mac"),
22:     LINUX("Linux");
23:     private final String displayName;
24:     Platform(String displayName) {
25:         this.displayName = displayName;
26:     }
27: }
</file>

<file path="src/main/java/com/bht/ludonova/model/enums/Role.java">
 1: package com.bht.ludonova.model.enums;
 2: import lombok.Getter;
 3: @Getter
 4: public enum Role {
 5:     USER("ROLE_USER"),
 6:     ADMIN("ROLE_ADMIN");
 7:     private final String springSecurityRole;
 8:     Role(String springSecurityRole) {
 9:         this.springSecurityRole = springSecurityRole;
10:     }
11: }
</file>

<file path="src/main/java/com/bht/ludonova/model/Game.java">
 1: package com.bht.ludonova.model;
 2: import com.bht.ludonova.model.enums.GameSource;
 3: import com.bht.ludonova.model.enums.Platform;
 4: import jakarta.persistence.*;
 5: import lombok.Data;
 6: import lombok.Builder;
 7: import lombok.NoArgsConstructor;
 8: import lombok.AllArgsConstructor;
 9: import java.time.LocalDate;
10: import java.time.LocalDateTime;
11: import java.util.HashSet;
12: import java.util.Set;
13: @Data
14: @Builder
15: @NoArgsConstructor
16: @AllArgsConstructor
17: @Entity
18: @Table(name = "games")
19: public class Game {
20:     @Id
21:     @GeneratedValue(strategy = GenerationType.IDENTITY)
22:     private Long id;
23:     @Column(nullable = false)
24:     private String title;
25:     @Column(nullable = false, unique = true)
26:     private String slug;
27:     @Column(name = "api_id", unique = true)
28:     private String apiId;
29:     @Column(name = "background_image")
30:     private String backgroundImage;
31:     @ElementCollection
32:     @CollectionTable(name = "game_genres",
33:                     joinColumns = @JoinColumn(name = "game_id"))
34:     @Column(name = "genre")
35:     @Builder.Default
36:     private Set<String> genres = new HashSet<>();
37:     @Enumerated(EnumType.STRING)
38:     @Column(nullable = false)
39:     private GameSource source;
40:     @Column(name = "rawg_last_updated")
41:     private LocalDateTime rawgLastUpdated;
42:     @Column(name = "release_date")
43:     private LocalDate releaseDate;
44:     private Double rating;
45: }
</file>

<file path="src/main/java/com/bht/ludonova/model/GameInstance.java">
 1: package com.bht.ludonova.model;
 2: import com.bht.ludonova.model.enums.GameStatus;
 3: import jakarta.persistence.*;
 4: import lombok.AllArgsConstructor;
 5: import lombok.Builder;
 6: import lombok.Data;
 7: import lombok.NoArgsConstructor;
 8: import java.time.LocalDateTime;
 9: @Data
10: @Builder
11: @NoArgsConstructor
12: @AllArgsConstructor
13: @Entity
14: @Table(name = "game_instances", indexes = {
15:         @Index(name = "idx_game_instance_user_id", columnList = "user_id"),
16:         @Index(name = "idx_game_instance_user_game", columnList = "user_id,game_id", unique = true)
17: })
18: public class GameInstance {
19:     @Id
20:     @GeneratedValue(strategy = GenerationType.IDENTITY)
21:     private Long id;
22:     @ManyToOne(fetch = FetchType.LAZY)
23:     @JoinColumn(name = "user_id", nullable = false)
24:     private User user;
25:     @ManyToOne(fetch = FetchType.LAZY)
26:     @JoinColumn(name = "game_id", nullable = false)
27:     private Game game;
28:     @Enumerated(EnumType.STRING)
29:     @Column(nullable = false)
30:     private GameStatus status;
31:     @Column(name = "progress_percentage")
32:     private Integer progressPercentage;
33:     @Column(name = "play_time")
34:     private Integer playTime;
35:     @Column(name = "last_played")
36:     private LocalDateTime lastPlayed;
37:     @Column(name = "added_at")
38:     private LocalDateTime addedAt;
39:     private String notes;
40: }
</file>

<file path="src/main/java/com/bht/ludonova/model/Review.java">
 1: package com.bht.ludonova.model;
 2: import jakarta.persistence.*;
 3: import jakarta.validation.constraints.Max;
 4: import jakarta.validation.constraints.Min;
 5: import lombok.AllArgsConstructor;
 6: import lombok.Builder;
 7: import lombok.Data;
 8: import lombok.NoArgsConstructor;
 9: import java.time.LocalDateTime;
10: @Data
11: @Builder
12: @NoArgsConstructor
13: @AllArgsConstructor
14: @Entity
15: @Table(name = "reviews")
16: public class Review {
17:     @Id
18:     @GeneratedValue(strategy = GenerationType.IDENTITY)
19:     private Long id;
20:     @ManyToOne(fetch = FetchType.LAZY)
21:     @JoinColumn(name = "user_id", nullable = false)
22:     private User user;
23:     @ManyToOne(fetch = FetchType.LAZY)
24:     @JoinColumn(name = "game_id", nullable = false)
25:     private Game game;
26:     @Min(1)
27:     @Max(5)
28:     private Integer rating;
29:     @Column(name = "review_text")
30:     private String reviewText;
31:     @Column(name = "created_at")
32:     private LocalDateTime createdAt;
33: }
</file>

<file path="src/main/java/com/bht/ludonova/model/SteamUser.java">
 1: package com.bht.ludonova.model;
 2: import lombok.Data;
 3: import jakarta.persistence.Entity;
 4: import jakarta.persistence.Table;
 5: import jakarta.persistence.Id;
 6: import jakarta.persistence.OneToOne;
 7: import com.fasterxml.jackson.annotation.JsonBackReference;
 8: @Data
 9: @Entity
10: @Table(name = "steam_users")
11: public class SteamUser {
12:     @Id
13:     private String steamId;
14:     private String personaName;
15:     private String profileUrl;
16:     private String avatarUrl;
17:     @OneToOne(mappedBy = "steamUser")
18:     @JsonBackReference
19:     private User user;
20: }
</file>

<file path="src/main/java/com/bht/ludonova/model/User.java">
 1: package com.bht.ludonova.model;
 2: import com.bht.ludonova.model.enums.Role;
 3: import jakarta.persistence.*;
 4: import lombok.Data;
 5: import lombok.Builder;
 6: import lombok.NoArgsConstructor;
 7: import lombok.AllArgsConstructor;
 8: import com.fasterxml.jackson.annotation.JsonManagedReference;
 9: @Data
10: @Builder
11: @NoArgsConstructor
12: @AllArgsConstructor
13: @Entity
14: @Table(name = "users")
15: public class User {
16:     @Id
17:     @GeneratedValue(strategy = GenerationType.IDENTITY)
18:     private Long id;
19:     @Column(unique = true, nullable = false)
20:     private String username;
21:     @Column(nullable = false)
22:     private String password;
23:     @Column
24:     private String email;
25:     @OneToOne(cascade = CascadeType.ALL)
26:     @JoinColumn(name = "steam_id")
27:     @JsonManagedReference
28:     private SteamUser steamUser;
29:     @Enumerated(EnumType.STRING)
30:     @Column(nullable = false)
31:     private Role role = Role.USER;
32: }
</file>

<file path="src/main/java/com/bht/ludonova/repository/GameInstanceRepository.java">
 1: package com.bht.ludonova.repository;
 2: import com.bht.ludonova.model.GameInstance;
 3: import com.bht.ludonova.model.enums.GameStatus;
 4: import org.springframework.data.domain.Page;
 5: import org.springframework.data.domain.Pageable;
 6: import org.springframework.data.jpa.repository.JpaRepository;
 7: import org.springframework.data.jpa.repository.Query;
 8: import org.springframework.data.repository.query.Param;
 9: import org.springframework.stereotype.Repository;
10: import java.util.List;
11: import java.util.Optional;
12: @Repository
13: public interface GameInstanceRepository extends JpaRepository<GameInstance, Long> {
14:     @Query("SELECT gi FROM GameInstance gi WHERE gi.user.id = :userId ORDER BY gi.lastPlayed DESC NULLS LAST")
15:     Page<GameInstance> findByUserIdOrderByLastPlayedDesc(@Param("userId") Long userId, Pageable pageable);
16:     @Query("SELECT gi FROM GameInstance gi WHERE gi.user.id = :userId AND gi.status = :status ORDER BY gi.lastPlayed DESC NULLS LAST")
17:     List<GameInstance> findByUserIdAndStatus(@Param("userId") Long userId, @Param("status") GameStatus status);
18:     boolean existsByUserIdAndGameId(Long userId, Long gameId);
19:     Optional<GameInstance> findByUserIdAndGameId(Long userId, Long gameId);
20:     @Deprecated
21:     List<GameInstance> findByUserId(Long userId);
22: }
</file>

<file path="src/main/java/com/bht/ludonova/repository/GameRepository.java">
 1: package com.bht.ludonova.repository;
 2: import com.bht.ludonova.model.Game;
 3: import com.bht.ludonova.model.enums.GameSource;
 4: import com.bht.ludonova.model.enums.Platform;
 5: import org.springframework.data.domain.Page;
 6: import org.springframework.data.domain.Pageable;
 7: import org.springframework.data.jpa.repository.JpaRepository;
 8: import org.springframework.stereotype.Repository;
 9: import java.util.List;
10: import java.util.Optional;
11: @Repository
12: public interface GameRepository extends JpaRepository<Game, Long> {
13:     Optional<Game> findByApiIdAndSource(String apiId, GameSource source);
14:     Page<Game> findAllByOrderByRatingDesc(Pageable pageable);
15:     Page<Game> findByTitleContainingIgnoreCase(String title, Pageable pageable);
16: }
</file>

<file path="src/main/java/com/bht/ludonova/repository/ReviewRepository.java">
 1: package com.bht.ludonova.repository;
 2: import com.bht.ludonova.model.Review;
 3: import org.springframework.data.jpa.repository.JpaRepository;
 4: import org.springframework.stereotype.Repository;
 5: import java.util.List;
 6: import java.util.Optional;
 7: @Repository
 8: public interface ReviewRepository extends JpaRepository<Review, Long> {
 9:     List<Review> findByGameId(Long gameId);
10:     List<Review> findByUserId(Long userId);
11:     Optional<Review> findByUserIdAndGameId(Long userId, Long gameId);
12: }
</file>

<file path="src/main/java/com/bht/ludonova/repository/UserRepository.java">
 1: package com.bht.ludonova.repository;
 2: import com.bht.ludonova.model.User;
 3: import org.springframework.data.jpa.repository.JpaRepository;
 4: import org.springframework.stereotype.Repository;
 5: import java.util.Optional;
 6: @Repository
 7: public interface UserRepository extends JpaRepository<User, Long> {
 8:     Optional<User> findByUsername(String username);
 9:     Optional<User> findBySteamUser_SteamId(String steamId);
10: }
</file>

<file path="src/main/java/com/bht/ludonova/security/AuthenticationExceptionHandler.java">
 1: package com.bht.ludonova.security;
 2: import com.fasterxml.jackson.databind.ObjectMapper;
 3: import jakarta.servlet.ServletException;
 4: import jakarta.servlet.http.HttpServletRequest;
 5: import jakarta.servlet.http.HttpServletResponse;
 6: import lombok.extern.slf4j.Slf4j;
 7: import org.springframework.http.MediaType;
 8: import org.springframework.security.core.AuthenticationException;
 9: import org.springframework.security.web.AuthenticationEntryPoint;
10: import org.springframework.security.web.access.AccessDeniedHandler;
11: import org.springframework.security.access.AccessDeniedException;
12: import org.springframework.stereotype.Component;
13: import java.io.IOException;
14: import java.util.HashMap;
15: import java.util.Map;
16: @Slf4j
17: @Component
18: public class AuthenticationExceptionHandler implements AuthenticationEntryPoint, AccessDeniedHandler {
19:     private final ObjectMapper objectMapper = new ObjectMapper();
20:     @Override
21:     public void commence(HttpServletRequest request, HttpServletResponse response,
22:                          AuthenticationException authException) throws IOException, ServletException {
23:         log.error("Unauthorized error: {}", authException.getMessage());
24:         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
25:         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
26:         Map<String, Object> body = new HashMap<>();
27:         body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
28:         body.put("error", "Unauthorized");
29:         body.put("message", authException.getMessage());
30:         body.put("path", request.getServletPath());
31:         objectMapper.writeValue(response.getOutputStream(), body);
32:     }
33:     @Override
34:     public void handle(HttpServletRequest request, HttpServletResponse response,
35:                        AccessDeniedException accessDeniedException) throws IOException, ServletException {
36:         log.error("Access denied error: {}", accessDeniedException.getMessage());
37:         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
38:         response.setStatus(HttpServletResponse.SC_FORBIDDEN);
39:         Map<String, Object> body = new HashMap<>();
40:         body.put("status", HttpServletResponse.SC_FORBIDDEN);
41:         body.put("error", "Forbidden");
42:         body.put("message", accessDeniedException.getMessage());
43:         body.put("path", request.getServletPath());
44:         objectMapper.writeValue(response.getOutputStream(), body);
45:     }
46: }
</file>

<file path="src/main/java/com/bht/ludonova/security/CustomUserDetailsService.java">
 1: package com.bht.ludonova.security;
 2: import com.bht.ludonova.model.User;
 3: import com.bht.ludonova.model.enums.Role;
 4: import com.bht.ludonova.repository.UserRepository;
 5: import lombok.RequiredArgsConstructor;
 6: import lombok.extern.slf4j.Slf4j;
 7: import org.springframework.security.core.authority.SimpleGrantedAuthority;
 8: import org.springframework.security.core.userdetails.UserDetails;
 9: import org.springframework.security.core.userdetails.UserDetailsService;
10: import org.springframework.security.core.userdetails.UsernameNotFoundException;
11: import org.springframework.stereotype.Service;
12: import org.springframework.transaction.annotation.Transactional;
13: import java.util.ArrayList;
14: import java.util.Collections;
15: import java.util.List;
16: @Slf4j
17: @Service
18: @RequiredArgsConstructor
19: public class CustomUserDetailsService implements UserDetailsService {
20:     private final UserRepository userRepository;
21:     @Override
22:     @Transactional(readOnly = true)
23:     public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
24:         User user = userRepository.findByUsername(username)
25:                 .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));
26:         log.debug("Loading user: {} with role: {}", username, user.getRole());
27:         List<SimpleGrantedAuthority> authorities = new ArrayList<>();
28:         authorities.add(new SimpleGrantedAuthority(Role.USER.getSpringSecurityRole()));
29:         if (user.getRole() == Role.ADMIN) {
30:             authorities.add(new SimpleGrantedAuthority(Role.ADMIN.getSpringSecurityRole()));
31:             log.debug("Added ADMIN role for user: {}", username);
32:         }
33:         log.debug("Final authorities for user {}: {}", username, authorities);
34:         return org.springframework.security.core.userdetails.User.builder()
35:                 .username(user.getUsername())
36:                 .password(user.getPassword())
37:                 .authorities(authorities)
38:                 .accountExpired(false)
39:                 .accountLocked(false)
40:                 .credentialsExpired(false)
41:                 .disabled(false)
42:                 .build();
43:     }
44: }
</file>

<file path="src/main/java/com/bht/ludonova/security/JwtAuthenticationFilter.java">
 1: package com.bht.ludonova.security;
 2: import com.bht.ludonova.exception.AuthenticationException;
 3: import io.jsonwebtoken.Claims;
 4: import jakarta.servlet.FilterChain;
 5: import jakarta.servlet.ServletException;
 6: import jakarta.servlet.http.HttpServletRequest;
 7: import jakarta.servlet.http.HttpServletResponse;
 8: import lombok.RequiredArgsConstructor;
 9: import lombok.extern.slf4j.Slf4j;
10: import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
11: import org.springframework.security.core.authority.SimpleGrantedAuthority;
12: import org.springframework.security.core.context.SecurityContextHolder;
13: import org.springframework.security.core.userdetails.UserDetails;
14: import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
15: import org.springframework.stereotype.Component;
16: import org.springframework.util.AntPathMatcher;
17: import org.springframework.util.StringUtils;
18: import org.springframework.web.filter.OncePerRequestFilter;
19: import java.io.IOException;
20: import java.util.ArrayList;
21: import java.util.Arrays;
22: import java.util.List;
23: import java.util.stream.Collectors;
24: @Slf4j
25: @Component
26: @RequiredArgsConstructor
27: public class JwtAuthenticationFilter extends OncePerRequestFilter {
28:     private final JwtTokenProvider tokenProvider;
29:     private final CustomUserDetailsService customUserDetailsService;
30:     private final AntPathMatcher pathMatcher = new AntPathMatcher();
31:     private final List<String> publicPaths = Arrays.asList(
32:             "/api/auth/**",
33:             "/api/test/public"
34:     );
35:     @Override
36:     protected boolean shouldNotFilter(HttpServletRequest request) {
37:         String path = request.getServletPath();
38:         return publicPaths.stream()
39:                 .anyMatch(pattern -> pathMatcher.match(pattern, path));
40:     }
41:     @Override
42:     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
43:             throws ServletException, IOException {
44:         try {
45:             String jwt = getJwtFromRequest(request);
46:             if (StringUtils.hasText(jwt)) {
47:                 if (tokenProvider.validateToken(jwt)) {
48:                     Claims claims = tokenProvider.getClaimsFromToken(jwt, false);
49:                     String username = claims.getSubject();
50:                     List<SimpleGrantedAuthority> authorities = new ArrayList<>();
51:                     if (claims.get("authorities") instanceof List) {
52:                         @SuppressWarnings("unchecked")
53:                         List<String> authoritiesList = (List<String>) claims.get("authorities");
54:                         authorities = authoritiesList.stream()
55:                                 .map(SimpleGrantedAuthority::new)
56:                                 .collect(Collectors.toList());
57:                     }
58:                     log.debug("Token claims authorities: {}", authorities);
59:                     UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);
60:                     UsernamePasswordAuthenticationToken authentication =
61:                             new UsernamePasswordAuthenticationToken(
62:                                     userDetails,
63:                                     null,
64:                                     authorities
65:                             );
66:                     authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
67:                     SecurityContextHolder.getContext().setAuthentication(authentication);
68:                 }
69:             }
70:         } catch (Exception ex) {
71:             log.error("Could not set user authentication in security context", ex);
72:             SecurityContextHolder.clearContext();
73:         }
74:         filterChain.doFilter(request, response);
75:     }
76:     private String getJwtFromRequest(HttpServletRequest request) {
77:         String bearerToken = request.getHeader("Authorization");
78:         if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
79:             return bearerToken.substring(7);
80:         }
81:         return null;
82:     }
83:     private boolean shouldRefreshToken(String token) {
84:         return tokenProvider.isTokenExpired(token, false);
85:     }
86: }
</file>

<file path="src/main/java/com/bht/ludonova/security/JwtTokenProvider.java">
  1: package com.bht.ludonova.security;
  2: import io.jsonwebtoken.*;
  3: import io.jsonwebtoken.security.Keys;
  4: import io.jsonwebtoken.security.SignatureException;
  5: import lombok.extern.slf4j.Slf4j;
  6: import org.springframework.beans.factory.annotation.Value;
  7: import org.springframework.security.core.Authentication;
  8: import org.springframework.security.core.GrantedAuthority;
  9: import org.springframework.stereotype.Component;
 10: import javax.crypto.SecretKey;
 11: import java.nio.charset.StandardCharsets;
 12: import java.util.Date;
 13: import java.util.HashMap;
 14: import java.util.List;
 15: import java.util.Map;
 16: import java.util.stream.Collectors;
 17: @Slf4j
 18: @Component
 19: public class JwtTokenProvider {
 20:     private final SecretKey accessTokenKey;
 21:     private final SecretKey refreshTokenKey;
 22:     private final long accessTokenExpirationMs;
 23:     private final long refreshTokenExpirationMs;
 24:     public JwtTokenProvider(
 25:             @Value("${jwt.secret}") String jwtSecret,
 26:             @Value("${jwt.refresh-secret:${jwt.secret}}") String refreshSecret,
 27:             @Value("${jwt.expiration}") long accessTokenExpirationMs,
 28:             @Value("${jwt.refresh-expiration:2592000000}") long refreshTokenExpirationMs) {
 29:         this.accessTokenKey = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
 30:         this.refreshTokenKey = Keys.hmacShaKeyFor(refreshSecret.getBytes(StandardCharsets.UTF_8));
 31:         this.accessTokenExpirationMs = accessTokenExpirationMs;
 32:         this.refreshTokenExpirationMs = refreshTokenExpirationMs;
 33:     }
 34:     public String generateAccessToken(Authentication authentication) {
 35:         return generateAccessToken(authentication.getName(), createClaims(authentication));
 36:     }
 37:     public String generateAccessToken(String username) {
 38:         return generateAccessToken(username, new HashMap<>());
 39:     }
 40:     public String generateAccessToken(String username, Map<String, Object> claims) {
 41:         return generateToken(username, claims, accessTokenKey, accessTokenExpirationMs);
 42:     }
 43:     public String generateRefreshToken(String username) {
 44:         return generateToken(username, new HashMap<>(), refreshTokenKey, refreshTokenExpirationMs);
 45:     }
 46:     private String generateToken(String username, Map<String, Object> claims, SecretKey key, long expirationMs) {
 47:         Date now = new Date();
 48:         Date expiryDate = new Date(now.getTime() + expirationMs);
 49:         return Jwts.builder()
 50:                 .setClaims(claims)
 51:                 .setSubject(username)
 52:                 .setIssuedAt(now)
 53:                 .setExpiration(expiryDate)
 54:                 .signWith(key, SignatureAlgorithm.HS512)
 55:                 .compact();
 56:     }
 57:     private Map<String, Object> createClaims(Authentication authentication) {
 58:         Map<String, Object> claims = new HashMap<>();
 59:         List<String> authorities = authentication.getAuthorities().stream()
 60:                 .map(GrantedAuthority::getAuthority)
 61:                 .collect(Collectors.toList());
 62:         claims.put("authorities", authorities);
 63:         log.debug("Creating token with authorities: {}", authorities);
 64:         claims.put("type", "Bearer");
 65:         return claims;
 66:     }
 67:     public String getUsernameFromToken(String token, boolean isRefreshToken) {
 68:         SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
 69:         Claims claims = Jwts.parserBuilder()
 70:                 .setSigningKey(key)
 71:                 .build()
 72:                 .parseClaimsJws(token)
 73:                 .getBody();
 74:         log.debug("Token claims: {}", claims);
 75:         return claims.getSubject();
 76:     }
 77:     public String getUsernameFromToken(String token) {
 78:         return getUsernameFromToken(token, false);
 79:     }
 80:     public boolean validateToken(String token) {
 81:         return validateToken(token, false);
 82:     }
 83:     public boolean validateToken(String token, boolean isRefreshToken) {
 84:         try {
 85:             SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
 86:             Jwts.parserBuilder()
 87:                     .setSigningKey(key)
 88:                     .build()
 89:                     .parseClaimsJws(token);
 90:             return true;
 91:         } catch (SignatureException e) {
 92:             log.error("Invalid JWT signature: {}", e.getMessage());
 93:         } catch (MalformedJwtException e) {
 94:             log.error("Invalid JWT token: {}", e.getMessage());
 95:         } catch (ExpiredJwtException e) {
 96:             log.error("JWT token is expired: {}", e.getMessage());
 97:         } catch (UnsupportedJwtException e) {
 98:             log.error("JWT token is unsupported: {}", e.getMessage());
 99:         } catch (IllegalArgumentException e) {
100:             log.error("JWT claims string is empty: {}", e.getMessage());
101:         }
102:         return false;
103:     }
104:     public Claims getClaimsFromToken(String token, boolean isRefreshToken) {
105:         SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
106:         return Jwts.parserBuilder()
107:                 .setSigningKey(key)
108:                 .build()
109:                 .parseClaimsJws(token)
110:                 .getBody();
111:     }
112:     public boolean isTokenExpired(String token, boolean isRefreshToken) {
113:         try {
114:             Claims claims = getClaimsFromToken(token, isRefreshToken);
115:             return claims.getExpiration().before(new Date());
116:         } catch (ExpiredJwtException e) {
117:             return true;
118:         }
119:     }
120:     public long getAccessTokenExpirationMs() {
121:         return accessTokenExpirationMs;
122:     }
123:     public long getRefreshTokenExpirationMs() {
124:         return refreshTokenExpirationMs;
125:     }
126: }
</file>

<file path="src/main/java/com/bht/ludonova/security/SecurityConfig.java">
 1: package com.bht.ludonova.security;
 2: import lombok.RequiredArgsConstructor;
 3: import org.springframework.context.annotation.Bean;
 4: import org.springframework.context.annotation.Configuration;
 5: import org.springframework.security.authentication.AuthenticationManager;
 6: import org.springframework.security.authentication.AuthenticationProvider;
 7: import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
 8: import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
 9: import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
10: import org.springframework.security.config.annotation.web.builders.HttpSecurity;
11: import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
12: import org.springframework.security.config.http.SessionCreationPolicy;
13: import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
14: import org.springframework.security.crypto.password.PasswordEncoder;
15: import org.springframework.security.web.SecurityFilterChain;
16: import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
17: import org.springframework.web.cors.CorsConfigurationSource;
18: @Configuration
19: @EnableWebSecurity
20: @EnableMethodSecurity
21: @RequiredArgsConstructor
22: public class SecurityConfig {
23:     private final CustomUserDetailsService userDetailsService;
24:     private final JwtAuthenticationFilter jwtAuthFilter;
25:     private final CorsConfigurationSource corsConfigurationSource;
26:     private final AuthenticationExceptionHandler authenticationExceptionHandler;
27:     @Bean
28:     public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
29:         return http
30:                 .cors(cors -> cors.configurationSource(corsConfigurationSource))
31:                 .csrf(csrf -> csrf.disable())
32:                 .headers(headers -> headers
33:                         .httpStrictTransportSecurity(hsts -> hsts
34:                                 .includeSubDomains(true)
35:                                 .preload(true)
36:                                 .maxAgeInSeconds(31536000)
37:                         )
38:                 )
39:                 .authorizeHttpRequests(auth -> auth
40:                         .requestMatchers(
41:                                 "/api/auth/login",
42:                                 "/api/auth/refresh",
43:                                 "/api/auth/steam/login",
44:                                 "/api/auth/steam/return",
45:                                 "/swagger-ui/**",
46:                                 "/v3/api-docs/**",
47:                                 "/swagger-ui.html"
48:                         ).permitAll()
49:                         .requestMatchers("/api/games/**").authenticated()
50:                         .requestMatchers("/api/user/**").authenticated()
51:                         .anyRequest().authenticated()
52:                 )
53:                 .sessionManagement(session -> session
54:                         .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
55:                 )
56:                 .authenticationProvider(authenticationProvider())
57:                 .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
58:                 .exceptionHandling(exc -> exc
59:                         .authenticationEntryPoint(authenticationExceptionHandler)
60:                         .accessDeniedHandler(authenticationExceptionHandler)
61:                 )
62:                 .build();
63:     }
64:     @Bean
65:     public PasswordEncoder passwordEncoder() {
66:         return new BCryptPasswordEncoder();
67:     }
68:     @Bean
69:     public AuthenticationProvider authenticationProvider() {
70:         DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
71:         authProvider.setUserDetailsService(userDetailsService);
72:         authProvider.setPasswordEncoder(passwordEncoder());
73:         return authProvider;
74:     }
75:     @Bean
76:     public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
77:         return config.getAuthenticationManager();
78:     }
79: }
</file>

<file path="src/main/java/com/bht/ludonova/service/auth/AuthenticationStrategy.java">
1: package com.bht.ludonova.service.auth;
2: import com.bht.ludonova.dto.auth.AuthenticationResponse;
3: import java.util.Map;
4: public interface AuthenticationStrategy {
5:     AuthenticationResponse authenticate(Map<String, String> credentials);
6:     AuthenticationResponse refresh(String refreshToken);
7: }
</file>

<file path="src/main/java/com/bht/ludonova/service/auth/BasicAuthenticationStrategy.java">
 1: package com.bht.ludonova.service.auth;
 2: import com.bht.ludonova.dto.auth.AuthenticationResponse;
 3: import com.bht.ludonova.dto.auth.TokenResponse;
 4: import com.bht.ludonova.dto.user.UserDTO;
 5: import com.bht.ludonova.exception.AuthenticationException;
 6: import com.bht.ludonova.security.JwtTokenProvider;
 7: import com.bht.ludonova.service.UserService;
 8: import lombok.extern.slf4j.Slf4j;
 9: import org.springframework.security.authentication.AuthenticationManager;
10: import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
11: import org.springframework.security.core.Authentication;
12: import org.springframework.security.core.context.SecurityContextHolder;
13: import org.springframework.stereotype.Service;
14: import java.util.Map;
15: @Service
16: @Slf4j
17: public class BasicAuthenticationStrategy implements AuthenticationStrategy {
18:     private final AuthenticationManager authenticationManager;
19:     private final JwtTokenProvider tokenProvider;
20:     private final UserService userService;
21:     public BasicAuthenticationStrategy(
22:             AuthenticationManager authenticationManager,
23:             JwtTokenProvider tokenProvider,
24:             UserService userService) {
25:         this.authenticationManager = authenticationManager;
26:         this.tokenProvider = tokenProvider;
27:         this.userService = userService;
28:     }
29:     @Override
30:     public AuthenticationResponse authenticate(Map<String, String> credentials) {
31:         try {
32:             Authentication authentication = authenticationManager.authenticate(
33:                     new UsernamePasswordAuthenticationToken(
34:                             credentials.get("username"),
35:                             credentials.get("password")
36:                     )
37:             );
38:             SecurityContextHolder.getContext().setAuthentication(authentication);
39:             String accessToken = tokenProvider.generateAccessToken(authentication);
40:             String refreshToken = tokenProvider.generateRefreshToken(authentication.getName());
41:             UserDTO user = userService.getCurrentUserDTO();
42:             TokenResponse tokens = TokenResponse.of(
43:                     accessToken,
44:                     refreshToken,
45:                     tokenProvider.getAccessTokenExpirationMs()
46:             );
47:             return new AuthenticationResponse(tokens, user);
48:         } catch (org.springframework.security.core.AuthenticationException e) {
49:             log.error("Authentication failed", e);
50:             throw new AuthenticationException("Invalid username or password");
51:         }
52:     }
53:     @Override
54:     public AuthenticationResponse refresh(String refreshToken) {
55:         log.debug("Attempting to refresh token: {}", refreshToken);
56:         try {
57:             if (!tokenProvider.validateToken(refreshToken, true)) {
58:                 log.error("Invalid refresh token validation");
59:                 throw new AuthenticationException("Invalid refresh token");
60:             }
61:             String username = tokenProvider.getUsernameFromToken(refreshToken, true);
62:             log.debug("Extracted username from refresh token: {}", username);
63:             UserDTO user = userService.getUserDTOByUsername(username);
64:             String newAccessToken = tokenProvider.generateAccessToken(username);
65:             String newRefreshToken = tokenProvider.generateRefreshToken(username);
66:             TokenResponse tokens = TokenResponse.of(
67:                     newAccessToken,
68:                     newRefreshToken,
69:                     tokenProvider.getAccessTokenExpirationMs()
70:             );
71:             return new AuthenticationResponse(tokens, user);
72:         } catch (Exception e) {
73:             log.error("Token refresh failed", e);
74:             throw new AuthenticationException("Failed to refresh token");
75:         }
76:     }
77: }
</file>

<file path="src/main/java/com/bht/ludonova/service/auth/SteamAuthenticationStrategy.java">
 1: package com.bht.ludonova.service.auth;
 2: import com.bht.ludonova.dto.auth.AuthenticationResponse;
 3: import com.bht.ludonova.dto.auth.TokenResponse;
 4: import com.bht.ludonova.dto.user.UserDTO;
 5: import com.bht.ludonova.exception.SteamAuthenticationException;
 6: import com.bht.ludonova.model.SteamUser;
 7: import com.bht.ludonova.model.User;
 8: import com.bht.ludonova.security.JwtTokenProvider;
 9: import com.bht.ludonova.service.SteamService;
10: import com.bht.ludonova.service.UserService;
11: import lombok.extern.slf4j.Slf4j;
12: import org.springframework.stereotype.Service;
13: import java.util.Map;
14: @Service
15: @Slf4j
16: public class SteamAuthenticationStrategy implements AuthenticationStrategy {
17:     private final SteamService steamService;
18:     private final UserService userService;
19:     private final JwtTokenProvider tokenProvider;
20:     public SteamAuthenticationStrategy(
21:             SteamService steamService,
22:             UserService userService,
23:             JwtTokenProvider tokenProvider) {
24:         this.steamService = steamService;
25:         this.userService = userService;
26:         this.tokenProvider = tokenProvider;
27:     }
28:     @Override
29:     public AuthenticationResponse authenticate(Map<String, String> openIdParams) {
30:         try {
31:             log.debug("Starting Steam authentication with params: {}", openIdParams);
32:             if (!steamService.validateSteamResponse(openIdParams)) {
33:                 log.error("Steam validation failed");
34:                 throw new SteamAuthenticationException("Invalid Steam response");
35:             }
36:             log.debug("Steam response validated successfully");
37:             String steamId = extractSteamId(openIdParams);
38:             if (steamId == null) {
39:                 log.error("Could not extract Steam ID from params");
40:                 throw new SteamAuthenticationException("Could not extract Steam ID");
41:             }
42:             log.debug("Extracted Steam ID: {}", steamId);
43:             SteamUser steamUser = steamService.fetchUserDetails(steamId);
44:             log.debug("Fetched Steam user details: {}", steamUser);
45:             User user = userService.getOrCreateSteamUser(steamUser);
46:             log.debug("Got/Created user: {}", user);
47:             String accessToken = tokenProvider.generateAccessToken(user.getUsername());
48:             String refreshToken = tokenProvider.generateRefreshToken(user.getUsername());
49:             UserDTO userDTO = userService.convertToDTO(user);
50:             log.debug("Generated tokens and converted user to DTO");
51:             TokenResponse tokens = TokenResponse.of(
52:                     accessToken,
53:                     refreshToken,
54:                     tokenProvider.getAccessTokenExpirationMs()
55:             );
56:             return new AuthenticationResponse(tokens, userDTO);
57:         } catch (Exception e) {
58:             log.error("Steam authentication failed", e);
59:             throw new SteamAuthenticationException(e.getMessage());
60:         }
61:     }
62:     @Override
63:     public AuthenticationResponse refresh(String refreshToken) {
64:         return null;
65:     }
66:     private String extractSteamId(Map<String, String> params) {
67:         String identity = params.get("openid.claimed_id");
68:         if (identity != null && identity.matches("https://steamcommunity.com/openid/id/\\d+")) {
69:             return identity.substring(identity.lastIndexOf("/") + 1);
70:         }
71:         return null;
72:     }
73: }
</file>

<file path="src/main/java/com/bht/ludonova/service/AuthenticationService.java">
 1: package com.bht.ludonova.service;
 2: import com.bht.ludonova.dto.auth.AuthenticationResponse;
 3: import com.bht.ludonova.exception.AuthenticationException;
 4: import com.bht.ludonova.service.auth.AuthenticationStrategy;
 5: import com.bht.ludonova.service.auth.BasicAuthenticationStrategy;
 6: import com.bht.ludonova.service.auth.SteamAuthenticationStrategy;
 7: import lombok.extern.slf4j.Slf4j;
 8: import org.springframework.security.core.context.SecurityContextHolder;
 9: import org.springframework.stereotype.Service;
10: import java.util.Map;
11: @Service
12: @Slf4j
13: public class AuthenticationService {
14:     private final Map<String, AuthenticationStrategy> authenticationStrategies;
15:     public AuthenticationService(
16:             BasicAuthenticationStrategy basicAuthStrategy,
17:             SteamAuthenticationStrategy steamAuthStrategy) {
18:         this.authenticationStrategies = Map.of(
19:                 "basic", basicAuthStrategy,
20:                 "steam", steamAuthStrategy
21:         );
22:     }
23:     public AuthenticationResponse authenticate(String strategy, Map<String, String> credentials) {
24:         AuthenticationStrategy authStrategy = authenticationStrategies.get(strategy);
25:         if (authStrategy == null) {
26:             throw new AuthenticationException("Unsupported authentication strategy: " + strategy);
27:         }
28:         AuthenticationResponse response = authStrategy.authenticate(credentials);
29:         log.debug("Authenticated user with authorities: {}",
30:                 SecurityContextHolder.getContext().getAuthentication().getAuthorities());
31:         return response;
32:     }
33:     public AuthenticationResponse refresh(String refreshToken) {
34:         return authenticationStrategies.get("basic").refresh(refreshToken);
35:     }
36: }
</file>

<file path="src/main/java/com/bht/ludonova/service/GameInstanceService.java">
 1: package com.bht.ludonova.service;
 2: import java.time.LocalDateTime;
 3: import java.util.List;
 4: import org.springframework.data.domain.Page;
 5: import org.springframework.data.domain.Pageable;
 6: import org.springframework.stereotype.Service;
 7: import org.springframework.transaction.annotation.Transactional;
 8: import com.bht.ludonova.dto.gameInstance.*;
 9: import com.bht.ludonova.exception.*;
10: import com.bht.ludonova.model.*;
11: import com.bht.ludonova.model.enums.GameStatus;
12: import com.bht.ludonova.repository.*;
13: import com.bht.ludonova.mapper.GameInstanceMapper;
14: import lombok.RequiredArgsConstructor;
15: @Service
16: @Transactional
17: @RequiredArgsConstructor
18: public class GameInstanceService {
19:     private final GameInstanceRepository gameInstanceRepository;
20:     private final GameRepository gameRepository;
21:     private final UserRepository userRepository;
22:     private final GameInstanceMapper gameInstanceMapper;
23:     public GameInstanceResponseDTO createGameInstance(Long userId, GameInstanceCreateDTO dto) {
24:         if (gameInstanceRepository.existsByUserIdAndGameId(userId, dto.getGameId())) {
25:             throw new GameAlreadyAddedException("Game already in user's list");
26:         }
27:         User user = userRepository.findById(userId)
28:                 .orElseThrow(() -> new UserNotFoundException("User not found"));
29:         Game game = gameRepository.findById(dto.getGameId())
30:                 .orElseThrow(() -> new GameNotFoundException("Game not found"));
31:         GameInstance gameInstance = GameInstance.builder()
32:                 .user(user)
33:                 .game(game)
34:                 .status(dto.getStatus())
35:                 .progressPercentage(dto.getProgressPercentage() != null ? dto.getProgressPercentage() : 0)
36:                 .playTime(dto.getPlayTime() != null ? dto.getPlayTime() : 0)
37:                 .notes(dto.getNotes())
38:                 .addedAt(LocalDateTime.now())
39:                 .lastPlayed(dto.getStatus() == GameStatus.PLAYING ? LocalDateTime.now() : null)
40:                 .build();
41:         return gameInstanceMapper.toDTO(gameInstanceRepository.save(gameInstance));
42:     }
43:     public GameInstanceResponseDTO updateGameInstance(Long userId, Long instanceId, GameInstanceUpdateDTO dto) {
44:         GameInstance instance = gameInstanceRepository.findById(instanceId)
45:                 .orElseThrow(() -> new GameInstanceNotFoundException("Game instance not found"));
46:         if (!instance.getUser().getId().equals(userId)) {
47:             throw new UnauthorizedException("Not authorized to update this game instance");
48:         }
49:         if (dto.getStatus() != null) {
50:             boolean wasPlaying = instance.getStatus() == GameStatus.PLAYING;
51:             boolean isNowPlaying = dto.getStatus() == GameStatus.PLAYING;
52:             instance.setStatus(dto.getStatus());
53:             if (!wasPlaying && isNowPlaying) {
54:                 instance.setLastPlayed(LocalDateTime.now());
55:             }
56:         }
57:         if (dto.getProgressPercentage() != null) {
58:             instance.setProgressPercentage(dto.getProgressPercentage());
59:         }
60:         if (dto.getPlayTime() != null) {
61:             instance.setPlayTime(dto.getPlayTime());
62:         }
63:         if (dto.getNotes() != null) {
64:             instance.setNotes(dto.getNotes());
65:         }
66:         return gameInstanceMapper.toDTO(gameInstanceRepository.save(instance));
67:     }
68:     public Page<GameInstanceResponseDTO> getUserGameInstances(Long userId, Pageable pageable) {
69:         return gameInstanceMapper.toDTOPage(
70:                 gameInstanceRepository.findByUserIdOrderByLastPlayedDesc(userId, pageable)
71:         );
72:     }
73:     public List<GameInstanceResponseDTO> getUserGameInstancesByStatus(Long userId, GameStatus status) {
74:         return gameInstanceMapper.toDTOList(
75:                 gameInstanceRepository.findByUserIdAndStatus(userId, status)
76:         );
77:     }
78:     public GameInstanceResponseDTO updateGameStatus(Long userId, Long instanceId, GameStatus status) {
79:         GameInstanceUpdateDTO updateDTO = new GameInstanceUpdateDTO();
80:         updateDTO.setStatus(status);
81:         return updateGameInstance(userId, instanceId, updateDTO);
82:     }
83:     public void deleteGameInstance(Long userId, Long instanceId) {
84:         GameInstance instance = gameInstanceRepository.findById(instanceId)
85:                 .orElseThrow(() -> new GameInstanceNotFoundException("Game instance not found"));
86:         if (!instance.getUser().getId().equals(userId)) {
87:             throw new UnauthorizedException("Not authorized to delete this game instance");
88:         }
89:         gameInstanceRepository.delete(instance);
90:     }
91: }
</file>

<file path="src/main/java/com/bht/ludonova/service/GameService.java">
  1: package com.bht.ludonova.service;
  2: import java.time.LocalDateTime;
  3: import java.util.Optional;
  4: import java.util.stream.Collectors;
  5: import org.springframework.cache.CacheManager;
  6: import org.springframework.data.domain.Page;
  7: import org.springframework.data.domain.Pageable;
  8: import org.springframework.stereotype.Service;
  9: import org.springframework.transaction.annotation.Transactional;
 10: import org.springframework.cache.annotation.Cacheable;
 11: import com.bht.ludonova.dto.rawg.RawgGameDTO;
 12: import com.bht.ludonova.dto.rawg.RawgSearchResponseDTO;
 13: import com.bht.ludonova.model.Game;
 14: import com.bht.ludonova.model.enums.GameSource;
 15: import com.bht.ludonova.repository.GameRepository;
 16: import lombok.RequiredArgsConstructor;
 17: import lombok.extern.slf4j.Slf4j;
 18: @Service
 19: @Transactional(readOnly = true)
 20: @RequiredArgsConstructor
 21: @Slf4j
 22: public class GameService {
 23:     private final GameRepository gameRepository;
 24:     private final RawgService rawgService;
 25:     private final CacheManager cacheManager;
 26:     @Cacheable(value = "games", key = "#id")
 27:     public Optional<Game> findById(Long id) {
 28:         return gameRepository.findById(id);
 29:     }
 30:     @Transactional
 31:     public void initializeGameDatabase() {
 32:         if (gameRepository.count() < 20) {
 33:             log.info("Initializing game database with popular games...");
 34:             int page = 1;
 35:             int totalGamesFetched = 0;
 36:             int pageSize = 40;
 37:             while (totalGamesFetched < 100) {
 38:                 try {
 39:                     RawgSearchResponseDTO response = rawgService.listGames(
 40:                             page,
 41:                             "-metacritic",
 42:                             null,
 43:                             pageSize);
 44:                     for (RawgGameDTO rawgGame : response.getResults()) {
 45:                         syncGameFromRawg(rawgGame);
 46:                         totalGamesFetched++;
 47:                     }
 48:                     if (response.getNext() == null) break;
 49:                     page++;
 50:                 } catch (Exception e) {
 51:                     log.error("Error fetching from RAWG, retrying...", e);
 52:                     break;
 53:                 }
 54:             }
 55:             log.info("Initialized game database with {} games.", totalGamesFetched);
 56:         } else {
 57:             log.info("Game database already initialized.");
 58:         }
 59:     }
 60:     public Page<Game> searchGames(String searchQuery, Pageable pageable) {
 61:         if (searchQuery == null || searchQuery.trim().isEmpty()) {
 62:             return gameRepository.findAllByOrderByRatingDesc(pageable);
 63:         }
 64:         Page<Game> localResults = gameRepository
 65:                 .findByTitleContainingIgnoreCase(searchQuery.trim(), pageable);
 66:         if (localResults.getContent().size() < pageable.getPageSize()) {
 67:             try {
 68:                 fetchAndSyncGamesFromRawg(searchQuery, pageable.getPageNumber() + 1);
 69:                 return gameRepository.findByTitleContainingIgnoreCase(
 70:                         searchQuery.trim(), pageable);
 71:             } catch (Exception e) {
 72:                 log.error("Error fetching from RAWG", e);
 73:                 return localResults;
 74:             }
 75:         }
 76:         return localResults;
 77:     }
 78:     @Transactional
 79:     protected void fetchAndSyncGamesFromRawg(String query, int page) {
 80:         RawgSearchResponseDTO searchResponse = rawgService.searchGames(query, page);
 81:         if (searchResponse != null && searchResponse.getResults() != null) {
 82:             searchResponse.getResults().forEach(this::syncGameFromRawg);
 83:         }
 84:     }
 85:     @Transactional
 86:     protected Game syncGameFromRawg(RawgGameDTO rawgGame) {
 87:         return gameRepository.findByApiIdAndSource(
 88:                         rawgGame.getId().toString(), GameSource.RAWG)
 89:                 .map(existing -> updateGameFromRawg(existing, rawgGame))
 90:                 .orElseGet(() -> createGameFromRawg(rawgGame));
 91:     }
 92:     private Game updateGameFromRawg(Game existing, RawgGameDTO rawgGame) {
 93:         existing.setTitle(rawgGame.getName());
 94:         existing.setSlug(generateSlug(rawgGame.getName()));
 95:         existing.setRating(rawgGame.getRating());
 96:         existing.setBackgroundImage(rawgGame.getBackgroundImage());
 97:         existing.setGenres(rawgGame.getGenres().stream()
 98:                 .map(RawgGameDTO.Genre::getName)
 99:                 .collect(Collectors.toSet()));
100:         existing.setRawgLastUpdated(LocalDateTime.now());
101:         return gameRepository.save(existing);
102:     }
103:     private Game createGameFromRawg(RawgGameDTO rawgGame) {
104:         String slug = generateSlug(rawgGame.getName());
105:         Game game = Game.builder()
106:                 .title(rawgGame.getName())
107:                 .apiId(rawgGame.getId().toString())
108:                 .source(GameSource.RAWG)
109:                 .releaseDate(rawgGame.getReleaseDate())
110:                 .backgroundImage(rawgGame.getBackgroundImage())
111:                 .rating(rawgGame.getRating())
112:                 .slug(slug)
113:                 .genres(rawgGame.getGenres().stream()
114:                         .map(RawgGameDTO.Genre::getName)
115:                         .collect(Collectors.toSet()))
116:                 .rawgLastUpdated(LocalDateTime.now())
117:                 .build();
118:         return gameRepository.save(game);
119:     }
120:     private String generateSlug(String title) {
121:         if (title == null) return "";
122:         return title.toLowerCase()
123:                 .replaceAll("[^a-z0-9\\s-]", "")
124:                 .replaceAll("\\s+", "-")
125:                 .replaceAll("-+", "-")
126:                 .trim();
127:     }
128: }
</file>

<file path="src/main/java/com/bht/ludonova/service/GameSyncService.java">
 1: package com.bht.ludonova.service;
 2: import com.bht.ludonova.dto.rawg.RawgGameDTO;
 3: import com.bht.ludonova.dto.rawg.RawgSearchResponseDTO;
 4: import com.bht.ludonova.model.Game;
 5: import com.bht.ludonova.model.enums.GameSource;
 6: import com.bht.ludonova.repository.GameRepository;
 7: import lombok.RequiredArgsConstructor;
 8: import lombok.extern.slf4j.Slf4j;
 9: import org.springframework.boot.context.event.ApplicationReadyEvent;
10: import org.springframework.context.event.EventListener;
11: import org.springframework.stereotype.Service;
12: import org.springframework.transaction.annotation.Transactional;
13: import java.util.Set;
14: import java.util.stream.Collectors;
15: @Service
16: @Slf4j
17: @RequiredArgsConstructor
18: public class GameSyncService {
19:     private final RawgService rawgService;
20:     private final GameRepository gameRepository;
21:     @EventListener(ApplicationReadyEvent.class)
22:     @Transactional
23:     public void initializeGameDatabase() {
24:         if (gameRepository.count() < 20) {
25:             log.info("Initializing game database with popular games...");
26:             try {
27:                 RawgSearchResponseDTO popularGames = rawgService.listGames(
28:                         1,
29:                         "-rating",
30:                         null,
31:                         40
32:                 );
33:                 for (RawgGameDTO rawgGame : popularGames.getResults()) {
34:                     syncGameFromRawg(rawgGame);
35:                 }
36:                 log.info("Successfully initialized game database");
37:             } catch (Exception e) {
38:                 log.error("Error during initial game sync", e);
39:             }
40:         }
41:     }
42:     @Transactional
43:     public Game syncGameFromRawg(RawgGameDTO rawgGame) {
44:         return gameRepository.findByApiIdAndSource(
45:                 rawgGame.getId().toString(),
46:                 GameSource.RAWG
47:         ).orElseGet(() -> createGameFromRawg(rawgGame));
48:     }
49:     private Game createGameFromRawg(RawgGameDTO rawgGame) {
50:         Set<String> genres = rawgGame.getGenres().stream()
51:                 .map(RawgGameDTO.Genre::getName)
52:                 .collect(Collectors.toSet());
53:         return gameRepository.save(Game.builder()
54:                 .title(rawgGame.getName())
55:                 .apiId(rawgGame.getId().toString())
56:                 .source(GameSource.RAWG)
57:                 .releaseDate(rawgGame.getReleaseDate())
58:                 .genres(genres)
59:                 .backgroundImage(rawgGame.getBackgroundImage())
60:                 .rating(rawgGame.getRating())
61:                 .build());
62:     }
63: }
</file>

<file path="src/main/java/com/bht/ludonova/service/RawgService.java">
 1: package com.bht.ludonova.service;
 2: import com.bht.ludonova.dto.rawg.RawgSearchResponseDTO;
 3: import lombok.extern.slf4j.Slf4j;
 4: import org.springframework.beans.factory.annotation.Value;
 5: import org.springframework.stereotype.Service;
 6: import org.springframework.web.reactive.function.client.WebClient;
 7: @Service
 8: @Slf4j
 9: public class RawgService {
10:     private final WebClient rawgWebClient;
11:     private final String apiKey;
12:     public RawgService(
13:             WebClient rawgWebClient,
14:             @Value("${rawg.api.key}") String apiKey) {
15:         this.rawgWebClient = rawgWebClient;
16:         this.apiKey = apiKey;
17:     }
18:     public RawgSearchResponseDTO searchGames(String query, int page) {
19:         return rawgWebClient.get()
20:                 .uri(uriBuilder -> uriBuilder
21:                         .path("/games")
22:                         .queryParam("key", apiKey)
23:                         .queryParam("search", query)
24:                         .queryParam("page", page)
25:                         .queryParam("page_size", 20)
26:                         .build())
27:                 .retrieve()
28:                 .bodyToMono(RawgSearchResponseDTO.class)
29:                 .block();
30:     }
31:     public RawgSearchResponseDTO listGames(int page, String ordering, String platforms, Integer pageSize) {
32:         return rawgWebClient.get()
33:                 .uri(uriBuilder -> {
34:                     var builder = uriBuilder
35:                             .path("/games")
36:                             .queryParam("key", apiKey)
37:                             .queryParam("page", page)
38:                             .queryParam("page_size", pageSize != null ? pageSize : 20);
39:                     if (ordering != null) {
40:                         builder.queryParam("ordering", ordering);
41:                     }
42:                     if (platforms != null) {
43:                         builder.queryParam("platforms", platforms);
44:                     }
45:                     return builder.build();
46:                 })
47:                 .retrieve()
48:                 .bodyToMono(RawgSearchResponseDTO.class)
49:                 .block();
50:     }
51: }
</file>

<file path="src/main/java/com/bht/ludonova/service/ReviewService.java">
 1: package com.bht.ludonova.service;
 2: import com.bht.ludonova.dto.review.ReviewCreateDTO;
 3: import com.bht.ludonova.dto.review.ReviewResponseDTO;
 4: import com.bht.ludonova.dto.review.ReviewUpdateDTO;
 5: import com.bht.ludonova.exception.GameNotFoundException;
 6: import com.bht.ludonova.exception.ReviewNotFoundException;
 7: import com.bht.ludonova.exception.UnauthorizedException;
 8: import com.bht.ludonova.model.Game;
 9: import com.bht.ludonova.model.Review;
10: import com.bht.ludonova.model.User;
11: import com.bht.ludonova.repository.GameRepository;
12: import com.bht.ludonova.repository.ReviewRepository;
13: import lombok.RequiredArgsConstructor;
14: import org.springframework.stereotype.Service;
15: import java.time.LocalDateTime;
16: import java.util.List;
17: @Service
18: @RequiredArgsConstructor
19: public class ReviewService {
20:     private final ReviewRepository reviewRepository;
21:     private final GameRepository gameRepository;
22:     private final UserService userService;
23:     public ReviewResponseDTO createReview(Long userId, ReviewCreateDTO dto) {
24:         User user = userService.getCurrentUser();
25:         Game game = gameRepository.findById(dto.getGameId())
26:                 .orElseThrow(() -> new GameNotFoundException("Game not found"));
27:         Review review = Review.builder()
28:                 .user(user)
29:                 .game(game)
30:                 .rating(dto.getRating())
31:                 .reviewText(dto.getReviewText())
32:                 .createdAt(LocalDateTime.now())
33:                 .build();
34:         review = reviewRepository.save(review);
35:         return mapToDTO(review);
36:     }
37:     public ReviewResponseDTO updateReview(Long userId, Long reviewId, ReviewUpdateDTO dto) {
38:         Review review = reviewRepository.findById(reviewId)
39:                 .orElseThrow(() -> new ReviewNotFoundException("Review not found"));
40:         if (!review.getUser().getId().equals(userId)) {
41:             throw new UnauthorizedException("You cannot edit this review");
42:         }
43:         if (dto.getRating() != null) {
44:             review.setRating(dto.getRating());
45:         }
46:         if (dto.getReviewText() != null) {
47:             review.setReviewText(dto.getReviewText());
48:         }
49:         review = reviewRepository.save(review);
50:         return mapToDTO(review);
51:     }
52:     public void deleteReview(Long userId, Long reviewId) {
53:         Review review = reviewRepository.findById(reviewId)
54:                 .orElseThrow(() -> new ReviewNotFoundException("Review not found"));
55:         if (!review.getUser().getId().equals(userId)) {
56:             throw new UnauthorizedException("You cannot delete this review");
57:         }
58:         reviewRepository.delete(review);
59:     }
60:     public List<ReviewResponseDTO> getReviewsByGame(Long gameId) {
61:         return reviewRepository.findByGameId(gameId).stream()
62:                 .map(this::mapToDTO)
63:                 .toList();
64:     }
65:     public List<ReviewResponseDTO> getReviewsByUser(Long userId) {
66:         return reviewRepository.findByUserId(userId).stream()
67:                 .map(this::mapToDTO)
68:                 .toList();
69:     }
70:     public ReviewResponseDTO getReviewByIdResponse(Long id) {
71:         Review review = reviewRepository.findById(id)
72:                 .orElseThrow(() -> new ReviewNotFoundException("Review with ID " + id + " not found"));
73:         return mapToDTO(review);
74:     }
75:     private ReviewResponseDTO mapToDTO(Review review) {
76:         return ReviewResponseDTO.builder()
77:                 .id(review.getId())
78:                 .gameId(review.getGame().getId())
79:                 .gameTitle(review.getGame().getTitle())
80:                 .userId(review.getUser().getId())
81:                 .rating(review.getRating())
82:                 .reviewText(review.getReviewText())
83:                 .createdAt(review.getCreatedAt())
84:                 .build();
85:     }
86: }
</file>

<file path="src/main/java/com/bht/ludonova/service/SteamService.java">
 1: package com.bht.ludonova.service;
 2: import com.bht.ludonova.dto.steam.SteamApiResponseDTO;
 3: import com.bht.ludonova.exception.SteamAuthenticationException;
 4: import org.springframework.beans.factory.annotation.Value;
 5: import org.springframework.stereotype.Service;
 6: import org.springframework.web.reactive.function.client.WebClient;
 7: import com.bht.ludonova.model.SteamUser;
 8: import lombok.extern.slf4j.Slf4j;
 9: import java.io.UnsupportedEncodingException;
10: import java.net.URLEncoder;
11: import java.nio.charset.StandardCharsets;
12: import java.util.HashMap;
13: import java.util.Map;
14: import java.util.stream.Collectors;
15: @Slf4j
16: @Service
17: public class SteamService {
18:     @Value("${steam.api.key}")
19:     private String steamApiKey;
20:     private final WebClient steamApiClient;
21:     private final WebClient openIdClient;
22:     public SteamService() {
23:         this.steamApiClient = WebClient.builder()
24:                 .baseUrl("https://api.steampowered.com")
25:                 .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
26:                 .build();
27:         this.openIdClient = WebClient.builder()
28:                 .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
29:                 .build();
30:     }
31:     public boolean validateSteamResponse(Map<String, String> params) {
32:         try {
33:             log.info("Validating Steam response with params: {}", params);
34:             String url = "https://steamcommunity.com/openid/login";
35:             Map<String, String> validationParams = new HashMap<>(params);
36:             validationParams.put("openid.mode", "check_authentication");
37:             String formData = validationParams.entrySet().stream()
38:                     .map(entry -> entry.getKey() + "=" + encodeValue(entry.getValue()))
39:                     .collect(Collectors.joining("&"));
40:             String responseBody = openIdClient.post()
41:                     .uri(url)
42:                     .header("Content-Type", "application/x-www-form-urlencoded")
43:                     .bodyValue(formData)
44:                     .retrieve()
45:                     .bodyToMono(String.class)
46:                     .block();
47:             log.info("Steam validation response: {}", responseBody);
48:             return responseBody != null && responseBody.contains("is_valid:true");
49:         } catch (Exception e) {
50:             log.error("Error validating Steam response", e);
51:             return false;
52:         }
53:     }
54:     public SteamUser fetchUserDetails(String steamId) {
55:         String url = "/ISteamUser/GetPlayerSummaries/v2/";
56:         try {
57:             SteamApiResponseDTO dto = steamApiClient.get()
58:                     .uri(uriBuilder -> uriBuilder
59:                             .path(url)
60:                             .queryParam("key", steamApiKey)
61:                             .queryParam("steamids", steamId)
62:                             .build())
63:                     .retrieve()
64:                     .bodyToMono(SteamApiResponseDTO.class)
65:                     .block();
66:             if (dto != null && dto.getResponse() != null && !dto.getResponse().getPlayers().isEmpty()) {
67:                 SteamApiResponseDTO.Player player = dto.getResponse().getPlayers().get(0);
68:                 return mapToSteamUser(player);
69:             }
70:             throw new SteamApiException("Failed to fetch Steam user details");
71:         } catch (Exception e) {
72:             log.error("Error fetching Steam user details", e);
73:             throw new SteamApiException("Failed to fetch Steam user details", e);
74:         }
75:     }
76:     private String encodeValue(String value) {
77:         try {
78:             return URLEncoder.encode(value, StandardCharsets.UTF_8.toString());
79:         } catch (UnsupportedEncodingException e) {
80:             return value;
81:         }
82:     }
83:     private SteamUser mapToSteamUser(SteamApiResponseDTO.Player player) {
84:         SteamUser steamUser = new SteamUser();
85:         steamUser.setSteamId(player.getSteamId());
86:         steamUser.setPersonaName(player.getPersonaName());
87:         steamUser.setProfileUrl(player.getProfileUrl());
88:         steamUser.setAvatarUrl(player.getAvatarUrl());
89:         return steamUser;
90:     }
91:     public static class SteamApiException extends RuntimeException {
92:         public SteamApiException(String message) {
93:             super(message);
94:         }
95:         public SteamApiException(String message, Throwable cause) {
96:             super(message, cause);
97:         }
98:     }
99: }
</file>

<file path="src/main/java/com/bht/ludonova/service/UserService.java">
  1: package com.bht.ludonova.service;
  2: import com.bht.ludonova.dto.steam.SteamUserDTO;
  3: import com.bht.ludonova.dto.user.CreateUserDTO;
  4: import com.bht.ludonova.dto.user.UserDTO;
  5: import com.bht.ludonova.dto.user.UserUpdateDTO;
  6: import com.bht.ludonova.exception.AuthenticationException;
  7: import com.bht.ludonova.exception.UnauthorizedException;
  8: import com.bht.ludonova.model.enums.Role;
  9: import org.springframework.security.core.context.SecurityContextHolder;
 10: import org.springframework.security.crypto.password.PasswordEncoder;
 11: import org.springframework.stereotype.Service;
 12: import org.springframework.transaction.annotation.Transactional;
 13: import com.bht.ludonova.model.SteamUser;
 14: import com.bht.ludonova.model.User;
 15: import com.bht.ludonova.repository.UserRepository;
 16: import java.util.List;
 17: import java.util.UUID;
 18: import java.util.stream.Collectors;
 19: @Service
 20: @Transactional
 21: public class UserService {
 22:     private final UserRepository userRepository;
 23:     private final PasswordEncoder passwordEncoder;
 24:     public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
 25:         this.userRepository = userRepository;
 26:         this.passwordEncoder = passwordEncoder;
 27:     }
 28:     public UserDTO createUser(CreateUserDTO createUserDTO) {
 29:         if (userRepository.findByUsername(createUserDTO.getUsername()).isPresent()) {
 30:             throw new IllegalArgumentException("Username already exists");
 31:         }
 32:         User user = User.builder()
 33:                 .username(createUserDTO.getUsername())
 34:                 .password(passwordEncoder.encode(createUserDTO.getPassword()))
 35:                 .email(createUserDTO.getEmail())
 36:                 .role(createUserDTO.getRole())
 37:                 .build();
 38:         User savedUser = userRepository.save(user);
 39:         return convertToDTO(savedUser);
 40:     }
 41:     public User getOrCreateSteamUser(SteamUser steamUser) {
 42:         return userRepository.findBySteamUser_SteamId(steamUser.getSteamId())
 43:                 .orElseGet(() -> createSteamUser(steamUser));
 44:     }
 45:     private User createSteamUser(SteamUser steamUser) {
 46:         User user = new User();
 47:         user.setUsername("steam_" + steamUser.getSteamId());
 48:         user.setPassword(passwordEncoder.encode(UUID.randomUUID().toString()));
 49:         user.setRole(Role.USER);
 50:         user.setSteamUser(steamUser);
 51:         return userRepository.save(user);
 52:     }
 53:     public UserDTO getCurrentUserDTO() {
 54:         String username = SecurityContextHolder.getContext().getAuthentication().getName();
 55:         return userRepository.findByUsername(username)
 56:                 .map(this::convertToDTO)
 57:                 .orElseThrow(() -> new AuthenticationException("User not found"));
 58:     }
 59:     public UserDTO getUserDTOByUsername(String username) {
 60:         return userRepository.findByUsername(username)
 61:                 .map(this::convertToDTO)
 62:                 .orElseThrow(() -> new AuthenticationException("User not found: " + username));
 63:     }
 64:     public UserDTO convertToDTO(User user) {
 65:         UserDTO dto = new UserDTO();
 66:         dto.setId(user.getId());
 67:         dto.setUsername(user.getUsername());
 68:         dto.setEmail(user.getEmail());
 69:         dto.setRole(user.getRole());
 70:         if (user.getSteamUser() != null) {
 71:             SteamUserDTO steamUserDTO = new SteamUserDTO();
 72:             steamUserDTO.setSteamId(user.getSteamUser().getSteamId());
 73:             steamUserDTO.setPersonaName(user.getSteamUser().getPersonaName());
 74:             steamUserDTO.setProfileUrl(user.getSteamUser().getProfileUrl());
 75:             steamUserDTO.setAvatarUrl(user.getSteamUser().getAvatarUrl());
 76:             dto.setSteamUser(steamUserDTO);
 77:         }
 78:         return dto;
 79:     }
 80:     public List<UserDTO> getAllUsers() {
 81:         checkAdminAccess();
 82:         return userRepository.findAll().stream()
 83:                 .map(this::convertToDTO)
 84:                 .collect(Collectors.toList());
 85:     }
 86:     public UserDTO getUserById(Long id) {
 87:         checkAdminAccess();
 88:         return userRepository.findById(id)
 89:                 .map(this::convertToDTO)
 90:                 .orElseThrow(() -> new AuthenticationException("User not found: " + id));
 91:     }
 92:     public UserDTO updateUser(Long id, UserUpdateDTO updateDTO) {
 93:         User currentUser = getCurrentUser();
 94:         User userToUpdate = userRepository.findById(id)
 95:                 .orElseThrow(() -> new AuthenticationException("User not found: " + id));
 96:         if (!currentUser.getRole().equals(Role.ADMIN) && !currentUser.getId().equals(id)) {
 97:             throw new UnauthorizedException("You can only update your own profile");
 98:         }
 99:         if (updateDTO.getRole() != null) {
100:             if (!currentUser.getRole().equals(Role.ADMIN)) {
101:                 throw new UnauthorizedException("Only admins can update roles");
102:             }
103:             userToUpdate.setRole(updateDTO.getRole());
104:         }
105:         if (updateDTO.getEmail() != null) {
106:             userToUpdate.setEmail(updateDTO.getEmail());
107:         }
108:         return convertToDTO(userRepository.save(userToUpdate));
109:     }
110:     public void deleteUser(Long id) {
111:         checkAdminAccess();
112:         userRepository.deleteById(id);
113:     }
114:     public User getCurrentUser() {
115:         String username = SecurityContextHolder.getContext().getAuthentication().getName();
116:         return userRepository.findByUsername(username)
117:                 .orElseThrow(() -> new AuthenticationException("User not found"));
118:     }
119:     private void checkAdminAccess() {
120:         User currentUser = getCurrentUser();
121:         if (!currentUser.getRole().equals(Role.ADMIN)) {
122:             throw new UnauthorizedException("Admin access required");
123:         }
124:     }
125: }
</file>

<file path="src/main/java/com/bht/ludonova/LudoNovaApplication.java">
 1: package com.bht.ludonova;
 2: import org.springframework.boot.SpringApplication;
 3: import org.springframework.boot.autoconfigure.SpringBootApplication;
 4: import org.springframework.boot.autoconfigure.domain.EntityScan;
 5: import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
 6: @SpringBootApplication
 7: @EntityScan("com.bht.ludonova.model")
 8: @EnableJpaRepositories("com.bht.ludonova.repository")
 9: public class LudoNovaApplication {
10:     public static void main(String[] args) {
11:         SpringApplication.run(LudoNovaApplication.class, args);
12:     }
13: }
</file>

<file path="src/main/resources/db/migration/V1__create_base_schema.sql">
 1: CREATE TABLE IF NOT EXISTS steam_users
 2: (
 3:     steam_id     VARCHAR(255) PRIMARY KEY,
 4:     persona_name VARCHAR(255),
 5:     profile_url  VARCHAR(255),
 6:     avatar_url   VARCHAR(255)
 7: );
 8: CREATE TABLE IF NOT EXISTS users
 9: (
10:     id         BIGSERIAL PRIMARY KEY,
11:     username   VARCHAR(255) NOT NULL UNIQUE,
12:     email      VARCHAR(255),
13:     password   VARCHAR(255) NOT NULL,
14:     role       VARCHAR(50)  NOT NULL DEFAULT 'USER',
15:     steam_id   VARCHAR(255) REFERENCES steam_users (steam_id),
16:     created_at TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP
17: );
18: CREATE TABLE games
19: (
20:     id                BIGSERIAL PRIMARY KEY,
21:     title            VARCHAR(255) NOT NULL,
22:     slug             VARCHAR(255) NOT NULL UNIQUE,
23:     api_id           VARCHAR(100),
24:     background_image VARCHAR(512),
25:     release_date     DATE,
26:     source           VARCHAR(20)  NOT NULL,
27:     rating           DOUBLE PRECISION,
28:     rawg_last_updated TIMESTAMP,
29:     created_at       TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
30:     UNIQUE (api_id, source)
31: );
32: CREATE TABLE game_genres
33: (
34:     game_id BIGINT REFERENCES games (id) ON DELETE CASCADE,
35:     genre   VARCHAR(50),
36:     PRIMARY KEY (game_id, genre)
37: );
38: CREATE TABLE game_instances
39: (
40:     id                  BIGSERIAL PRIMARY KEY,
41:     user_id             BIGINT REFERENCES users (id) ON DELETE CASCADE,
42:     game_id             BIGINT REFERENCES games (id) ON DELETE CASCADE,
43:     status              VARCHAR(20) NOT NULL,
44:     progress_percentage INTEGER CHECK (progress_percentage BETWEEN 0 AND 100),
45:     play_time           INTEGER,
46:     last_played         TIMESTAMP,
47:     notes               TEXT,
48:     added_at           TIMESTAMP   NOT NULL DEFAULT CURRENT_TIMESTAMP,
49:     created_at          TIMESTAMP   NOT NULL DEFAULT CURRENT_TIMESTAMP,
50:     updated_at          TIMESTAMP   NOT NULL DEFAULT CURRENT_TIMESTAMP,
51:     UNIQUE (user_id, game_id)
52: );
53: CREATE TABLE reviews
54: (
55:     id          BIGSERIAL PRIMARY KEY,
56:     user_id     BIGINT REFERENCES users (id) ON DELETE CASCADE,
57:     game_id     BIGINT REFERENCES games (id) ON DELETE CASCADE,
58:     rating      INTEGER CHECK (rating BETWEEN 1 AND 5),
59:     review_text TEXT,
60:     created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
61:     updated_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
62:     UNIQUE (user_id, game_id)
63: );
64: CREATE INDEX idx_games_title ON games(title);
65: CREATE INDEX idx_games_rating ON games(rating DESC);
66: CREATE INDEX idx_game_instances_user_status ON game_instances(user_id, status);
67: CREATE INDEX idx_reviews_game ON reviews(game_id);
</file>

<file path="src/main/resources/application.properties">
 1: # Server Configuration
 2: server.port=8443
 3: #server.port=8080
 4: 
 5: # PostgreSQL Database Configuration
 6: spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
 7: spring.datasource.username=postgres
 8: spring.datasource.password=postgres
 9: 
10: # JPA/Hibernate Configuration
11: spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
12: spring.jpa.hibernate.ddl-auto=validate
13: spring.jpa.show-sql=true
14: spring.jpa.properties.hibernate.format_sql=true
15: 
16: # Flyway Configuration
17: spring.flyway.enabled=true
18: spring.flyway.baseline-on-migrate=true
19: spring.flyway.clean-disabled=false
20: spring.flyway.locations=classpath:db/migration
21: 
22: # Enable SQL initialization
23: spring.sql.init.mode=always
24: 
25: # JWT Configuration
26: jwt.secret=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
27: jwt.refresh-secret=7338782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E
28: 
29: # Token expiration times (in milliseconds)
30: # Access token: 1 hour = 3600000 ms
31: jwt.expiration=3600000
32: # Refresh token: 30 days = 2592000000 ms
33: jwt.refresh-expiration=2592000000
34: 
35: # CORS Configuration
36: #spring.web.cors.allowed-origins=http://localhost:3000
37: #spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
38: #spring.web.cors.allowed-headers=*
39: #spring.web.cors.allow-credentials=true
40: 
41: # CORS Configuration
42: cors.allowed-origins=https://localhost:3000, http://localhost:3000
43: 
44: # Logging Configuration
45: logging.level.com.bht.ludonova=DEBUG
46: logging.level.org.hibernate.SQL=DEBUG
47: logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
48: logging.level.org.springframework.security=DEBUG
49: 
50: # Steam Configuration
51: steam.api.key=${STEAM_API_KEY}
52: steam.return.url=${STEAM_RETURN_URL:http://localhost:3000/auth/steam/callback}
53: steam.realm.url=${STEAM_REALM_URL:http://localhost:3000}
54: 
55: # Swagger UI custom path
56: springdoc.swagger-ui.path=/swagger-ui.html
57: # Enable or disable Swagger UI
58: springdoc.swagger-ui.enabled=true
59: # Sort APIs alphabetically
60: springdoc.swagger-ui.operationsSorter=alpha
61: 
62: # RAWG API Configuration
63: rawg.api.key=${RAWG_API_KEY}
64: rawg.api.base-url=https://api.rawg.io/api
65: 
66: # Cache Configuration
67: spring.cache.type=simple
68: spring.cache.cache-names=games,gameDetails
69: spring.cache.caffeine.spec=maximumSize=100,expireAfterWrite=30m
70: 
71: # Enable HTTPS
72: server.ssl.enabled=true
73: server.ssl.key-store=classpath:ludonova.p12
74: server.ssl.key-store-password=${SSL_KEY_STORE_PASSWORD}
75: server.ssl.key-store-type=PKCS12
76: server.ssl.key-alias=ludonova
</file>

<file path=".env.example">
1: # Steam Configuration
2: STEAM_API_KEY=your_steam_api_key_here
3: STEAM_RETURN_URL=http://localhost:3000/auth/steam/callback
4: RAWG_API_KEY=your-api-key-here
</file>

<file path=".gitignore">
 1: HELP.md
 2: target/
 3: !.mvn/wrapper/maven-wrapper.jar
 4: !**/src/main/**/target/
 5: !**/src/test/**/target/
 6: 
 7: ### STS ###
 8: .apt_generated
 9: .classpath
10: .factorypath
11: .project
12: .settings
13: .springBeans
14: .sts4-cache
15: 
16: ### IntelliJ IDEA ###
17: .idea
18: *.iws
19: *.iml
20: *.ipr
21: 
22: ### NetBeans ###
23: /nbproject/private/
24: /nbbuild/
25: /dist/
26: /nbdist/
27: /.nb-gradle/
28: build/
29: !**/src/main/**/build/
30: !**/src/test/**/build/
31: 
32: ### VS Code ###
33: .vscode/
34: 
35: ### Environment Files ###
36: .env
37: application-local.properties
38: application-dev.properties
39: application-prod.properties
40: 
41: ### Logs ###
42: *.log
43: logs/
44: log/
45: 
46: ### Docker ###
47: docker-compose.override.yml
48: 
49: ### OS generated files ###
50: .DS_Store
51: .DS_Store?
52: ._*
53: .Spotlight-V100
54: .Trashes
55: ehthumbs.db
56: Thumbs.db
57: 
58: ### Java ###
59: # Compiled class file
60: *.class
61: 
62: # Package Files #
63: *.jar
64: *.war
65: *.nar
66: *.ear
67: *.zip
68: *.tar.gz
69: *.rar
70: 
71: # virtual machine crash logs
72: hs_err_pid*
73: replay_pid*
74: 
75: # SSL/TLS Certificates
76: *.p12
77: *.pem
78: *.key
79: *.crt
80: *.cer
81: *.der
</file>

<file path="docker-compose.yml">
 1: version: '3.8'
 2: services:
 3:   postgres:
 4:     image: postgres:16
 5:     container_name: ludonova_db
 6:     environment:
 7:       POSTGRES_DB: ludonova
 8:       POSTGRES_USER: postgres
 9:       POSTGRES_PASSWORD: postgres
10:     ports:
11:       - "5432:5432"
12:     volumes:
13:       - postgres_data:/var/lib/postgresql/data
14: volumes:
15:   postgres_data:
</file>

<file path="ludonova-overview-backend.md">
   1: This file is a merged representation of the entire codebase, combining all repository files into a single document.
   2: Generated by Repomix on: 2024-11-23T16:43:22.583Z
   3: 
   4: # File Summary
   5: 
   6: ## Purpose
   7: This file contains a packed representation of the entire repository's contents.
   8: It is designed to be easily consumable by AI systems for analysis, code review,
   9: or other automated processes.
  10: 
  11: ## File Format
  12: The content is organized as follows:
  13: 1. This summary section
  14: 2. Repository information
  15: 3. Repository structure
  16: 4. Multiple file entries, each consisting of:
  17:   a. A header with the file path (## File: path/to/file)
  18:   b. The full contents of the file in a code block
  19: 
  20: ## Usage Guidelines
  21: - This file should be treated as read-only. Any changes should be made to the
  22:   original repository files, not this packed version.
  23: - When processing this file, use the file path to distinguish
  24:   between different files in the repository.
  25: - Be aware that this file may contain sensitive information. Handle it with
  26:   the same level of security as you would the original repository.
  27: 
  28: ## Notes
  29: - Some files may have been excluded based on .gitignore rules and Repomix's
  30:   configuration.
  31: - Binary files are not included in this packed representation. Please refer to
  32:   the Repository Structure section for a complete list of file paths, including
  33:   binary files.
  34: 
  35: ## Additional Info
  36: 
  37: For more information about Repomix, visit: https://github.com/yamadashy/repomix
  38: 
  39: # Repository Structure
  40: ```
  41: src/
  42:   main/
  43:     java/
  44:       com/
  45:         bht/
  46:           ludonova/
  47:             config/
  48:               DataInitializer.java
  49:               OpenAPIConfig.java
  50:               WebConfig.java
  51:             controller/
  52:               AuthController.java
  53:               GameController.java
  54:               GameInstanceController.java
  55:               SteamAuthController.java
  56:               UserController.java
  57:             dto/
  58:               auth/
  59:                 AuthenticationResponse.java
  60:                 LoginRequest.java
  61:                 RefreshTokenRequest.java
  62:                 TokenResponse.java
  63:               game/
  64:                 AdminGameUpdateDTO.java
  65:                 GameInstanceUpdateDTO.java
  66:                 GameUpdateDTO.java
  67:               steam/
  68:                 SteamApiResponseDTO.java
  69:                 SteamAuthRequest.java
  70:                 SteamUserDTO.java
  71:               user/
  72:                 UserDTO.java
  73:                 UserUpdateDTO.java
  74:               ErrorResponse.java
  75:             exception/
  76:               AuthenticationException.java
  77:               GlobalExceptionHandler.java
  78:               LudoNovaException.java
  79:               SteamAuthenticationException.java
  80:               UnauthorizedException.java
  81:             model/
  82:               enums/
  83:                 GameSource.java
  84:                 GameStatus.java
  85:                 Platform.java
  86:                 Role.java
  87:               Game.java
  88:               GameInstance.java
  89:               Review.java
  90:               SteamUser.java
  91:               User.java
  92:             repository/
  93:               GameInstanceRepository.java
  94:               GameRepository.java
  95:               ReviewRepository.java
  96:               UserRepository.java
  97:             security/
  98:               AuthenticationExceptionHandler.java
  99:               CustomUserDetailsService.java
 100:               JwtAuthenticationFilter.java
 101:               JwtTokenProvider.java
 102:               SecurityConfig.java
 103:             service/
 104:               auth/
 105:                 AuthenticationStrategy.java
 106:                 BasicAuthenticationStrategy.java
 107:                 SteamAuthenticationStrategy.java
 108:               AuthenticationService.java
 109:               GameInstanceService.java
 110:               GameService.java
 111:               SteamService.java
 112:               UserService.java
 113:             LudoNovaApplication.java
 114:     resources/
 115:       db/
 116:         migration/
 117:           V1__create_base_schema.sql
 118:       application.properties
 119: .env.example
 120: .gitignore
 121: backend-overview.md
 122: docker-compose.yml
 123: ludonova-backend-overview.xml
 124: pom.xml
 125: README.md
 126: setup.sh
 127: ```
 128: 
 129: # Repository Files
 130: 
 131: ## File: src/main/java/com/bht/ludonova/config/DataInitializer.java
 132: ```java
 133: package com.bht.ludonova.config;
 134: 
 135: import com.bht.ludonova.model.Game;
 136: import com.bht.ludonova.model.GameInstance;
 137: import com.bht.ludonova.model.User;
 138: import com.bht.ludonova.model.enums.GameSource;
 139: import com.bht.ludonova.model.enums.GameStatus;
 140: import com.bht.ludonova.model.enums.Platform;
 141: import com.bht.ludonova.model.enums.Role;
 142: import com.bht.ludonova.repository.GameInstanceRepository;
 143: import com.bht.ludonova.repository.GameRepository;
 144: import com.bht.ludonova.repository.UserRepository;
 145: import org.slf4j.Logger;
 146: import org.slf4j.LoggerFactory;
 147: import org.springframework.boot.CommandLineRunner;
 148: import org.springframework.context.annotation.Bean;
 149: import org.springframework.context.annotation.Configuration;
 150: import org.springframework.security.crypto.password.PasswordEncoder;
 151: 
 152: import java.time.LocalDate;
 153: import java.time.LocalDateTime;
 154: import java.util.Set;
 155: 
 156: @Configuration
 157: public class DataInitializer {
 158:     private static final Logger log = LoggerFactory.getLogger(DataInitializer.class);
 159: 
 160:     @Bean
 161:     CommandLineRunner initDatabase(
 162:             UserRepository userRepository,
 163:             GameRepository gameRepository,
 164:             GameInstanceRepository gameInstanceRepository,
 165:             PasswordEncoder passwordEncoder
 166:     ) {
 167:         return args -> {
 168:             // Create regular test user if doesn't exist
 169:             if (userRepository.findByUsername("test").isEmpty()) {
 170:                 User testUser = User.builder()
 171:                         .username("test")
 172:                         .password(passwordEncoder.encode("test123"))
 173:                         .email("test@example.com")
 174:                         .role(Role.USER)  // Set regular user role
 175:                         .build();
 176:                 userRepository.save(testUser);
 177:                 log.info("Test user created successfully");
 178:             }
 179: 
 180:             // Create admin user if doesn't exist
 181:             if (userRepository.findByUsername("admin").isEmpty()) {
 182:                 User adminUser = User.builder()
 183:                         .username("admin")
 184:                         .password(passwordEncoder.encode("admin123"))
 185:                         .email("admin@example.com")
 186:                         .role(Role.ADMIN)  // Set admin role
 187:                         .build();
 188:                 userRepository.save(adminUser);
 189:                 log.info("Admin user created successfully");
 190:             }
 191: 
 192:             // Create test game
 193:             Game testGame = Game.builder()
 194:                     .title("Half-Life 2")
 195:                     .platform(Platform.PC)
 196:                     .apiId("220")
 197:                     .source(GameSource.STEAM)
 198:                     .releaseDate(LocalDate.of(2004, 11, 16))
 199:                     .genres(Set.of("FPS", "Action", "Sci-Fi"))
 200:                     .build();
 201: 
 202:             testGame = gameRepository.save(testGame);
 203:             log.info("Test game created successfully");
 204: 
 205:             // Create game instance for test user
 206:             User user = userRepository.findByUsername("test").get();
 207:             if (!gameInstanceRepository.existsByUserIdAndGameId(user.getId(), testGame.getId())) {
 208:                 GameInstance instance = GameInstance.builder()
 209:                         .user(user)
 210:                         .game(testGame)
 211:                         .status(GameStatus.PLAYING)
 212:                         .progressPercentage(0)
 213:                         .playTime(0)
 214:                         .lastPlayed(LocalDateTime.now())
 215:                         .notes("Just started playing")
 216:                         .build();
 217:                 gameInstanceRepository.save(instance);
 218:                 log.info("Test game instance created successfully");
 219:             }
 220:         };
 221:     }
 222: }
 223: ```
 224: 
 225: ## File: src/main/java/com/bht/ludonova/config/OpenAPIConfig.java
 226: ```java
 227: package com.bht.ludonova.config;
 228: 
 229: import io.swagger.v3.oas.models.OpenAPI;
 230: import io.swagger.v3.oas.models.info.Info;
 231: import io.swagger.v3.oas.models.info.License;
 232: import io.swagger.v3.oas.models.Components;
 233: import io.swagger.v3.oas.models.security.SecurityScheme;
 234: import org.springframework.context.annotation.Bean;
 235: import org.springframework.context.annotation.Configuration;
 236: 
 237: @Configuration
 238: public class OpenAPIConfig {
 239: 
 240:     @Bean
 241:     public OpenAPI customOpenAPI() {
 242:         return new OpenAPI()
 243:                 .info(new Info()
 244:                         .title("LudoNova API")
 245:                         .version("1.0")
 246:                         .description("API documentation for LudoNova game tracking application")
 247:                         .license(new License().name("Private").url("https://ludonova.com")))
 248:                 .components(new Components()
 249:                         .addSecuritySchemes("bearer-jwt", new SecurityScheme()
 250:                                 .type(SecurityScheme.Type.HTTP)
 251:                                 .scheme("bearer")
 252:                                 .bearerFormat("JWT")));
 253:     }
 254: }
 255: ```
 256: 
 257: ## File: src/main/java/com/bht/ludonova/config/WebConfig.java
 258: ```java
 259: package com.bht.ludonova.config;
 260: 
 261: import org.springframework.beans.factory.annotation.Value;
 262: import org.springframework.context.annotation.Bean;
 263: import org.springframework.context.annotation.Configuration;
 264: import org.springframework.web.cors.CorsConfiguration;
 265: import org.springframework.web.cors.CorsConfigurationSource;
 266: import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
 267: 
 268: import java.util.List;
 269: 
 270: @Configuration
 271: public class WebConfig {
 272: 
 273:     @Value("${cors.allowed-origins}")
 274:     private List<String> allowedOrigins;
 275: 
 276:     @Bean
 277:     public CorsConfigurationSource corsConfigurationSource() {
 278:         CorsConfiguration configuration = new CorsConfiguration();
 279:         configuration.setAllowedOrigins(allowedOrigins);
 280:         configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
 281:         configuration.setAllowedHeaders(List.of(
 282:                 "Authorization",
 283:                 "Content-Type",
 284:                 "X-Requested-With",
 285:                 "Accept",
 286:                 "Origin",
 287:                 "Access-Control-Request-Method",
 288:                 "Access-Control-Request-Headers"
 289:         ));
 290:         configuration.setExposedHeaders(List.of(
 291:                 "Access-Control-Allow-Origin",
 292:                 "Access-Control-Allow-Credentials"
 293:         ));
 294:         configuration.setAllowCredentials(true);
 295:         configuration.setMaxAge(3600L);
 296: 
 297:         UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
 298:         source.registerCorsConfiguration("/api/**", configuration);
 299:         return source;
 300:     }
 301: }
 302: ```
 303: 
 304: ## File: src/main/java/com/bht/ludonova/controller/AuthController.java
 305: ```java
 306: package com.bht.ludonova.controller;
 307: 
 308: import com.bht.ludonova.dto.auth.AuthenticationResponse;
 309: import com.bht.ludonova.dto.auth.RefreshTokenRequest;
 310: import com.bht.ludonova.dto.auth.LoginRequest;
 311: import com.bht.ludonova.service.AuthenticationService;
 312: import jakarta.validation.Valid;
 313: import lombok.extern.slf4j.Slf4j;
 314: import org.springframework.http.ResponseEntity;
 315: import org.springframework.web.bind.annotation.*;
 316: 
 317: import java.util.Map;
 318: 
 319: @RestController
 320: @RequestMapping("/api/auth")
 321: @Slf4j
 322: public class AuthController {
 323:     private final AuthenticationService authService;
 324: 
 325:     public AuthController(AuthenticationService authService) {
 326:         this.authService = authService;
 327:     }
 328: 
 329:     @PostMapping("/login")
 330:     public ResponseEntity<AuthenticationResponse> login(@Valid @RequestBody LoginRequest loginRequest) {
 331:         Map<String, String> credentials = Map.of(
 332:                 "username", loginRequest.getUsername(),
 333:                 "password", loginRequest.getPassword()
 334:         );
 335: 
 336:         AuthenticationResponse response = authService.authenticate("basic", credentials);
 337:         return ResponseEntity.ok(response);
 338:     }
 339: 
 340:     @PostMapping("/refresh")
 341:     public ResponseEntity<AuthenticationResponse> refresh(@Valid @RequestBody RefreshTokenRequest request) {
 342:         AuthenticationResponse response = authService.refresh(request.getRefreshToken());
 343:         return ResponseEntity.ok(response);
 344:     }
 345: }
 346: ```
 347: 
 348: ## File: src/main/java/com/bht/ludonova/controller/GameController.java
 349: ```java
 350: //package com.bht.ludonova.controller;
 351: //
 352: //import java.util.List;
 353: //
 354: //import org.springframework.http.ResponseEntity;
 355: //import org.springframework.web.bind.annotation.DeleteMapping;
 356: //import org.springframework.web.bind.annotation.GetMapping;
 357: //import org.springframework.web.bind.annotation.PathVariable;
 358: //import org.springframework.web.bind.annotation.PostMapping;
 359: //import org.springframework.web.bind.annotation.PutMapping;
 360: //import org.springframework.web.bind.annotation.RequestBody;
 361: //import org.springframework.web.bind.annotation.RequestMapping;
 362: //import org.springframework.web.bind.annotation.RestController;
 363: //
 364: //import com.bht.ludonova.model.Game;
 365: //import com.bht.ludonova.model.enums.Platform;
 366: //import com.bht.ludonova.service.GameService;
 367: //
 368: //import lombok.RequiredArgsConstructor;
 369: //
 370: //@RestController
 371: //@RequestMapping("/api/games")
 372: //@RequiredArgsConstructor
 373: //public class GameController {
 374: //    private final GameService gameService;
 375: //
 376: //    @GetMapping
 377: //    public List<Game> getAllGames() {
 378: //        return gameService.findAll();
 379: //    }
 380: //
 381: //    @GetMapping("/{id}")
 382: //    public ResponseEntity<Game> getGame(@PathVariable Long id) {
 383: //        return gameService.findById(id)
 384: //                .map(ResponseEntity::ok)
 385: //                .orElse(ResponseEntity.notFound().build());
 386: //    }
 387: //
 388: //    @GetMapping("/platform/{platform}")
 389: //    public List<Game> getGamesByPlatform(@PathVariable Platform platform) {
 390: //        return gameService.findByPlatform(platform);
 391: //    }
 392: //
 393: //    @PostMapping
 394: //    public ResponseEntity<Game> createGame(@RequestBody Game game) {
 395: //        return ResponseEntity.ok(gameService.save(game));
 396: //    }
 397: //
 398: //    @PutMapping("/{id}")
 399: //    public ResponseEntity<Game> updateGame(@PathVariable Long id, @RequestBody Game game) {
 400: //        if (!id.equals(game.getId())) {
 401: //            return ResponseEntity.badRequest().build();
 402: //        }
 403: //        return ResponseEntity.ok(gameService.save(game));
 404: //    }
 405: //
 406: //    @DeleteMapping("/{id}")
 407: //    public ResponseEntity<Void> deleteGame(@PathVariable Long id) {
 408: //        gameService.deleteById(id);
 409: //        return ResponseEntity.noContent().build();
 410: //    }
 411: //}
 412: 
 413: package com.bht.ludonova.controller;
 414: 
 415: import java.util.List;
 416: 
 417: import org.springframework.http.ResponseEntity;
 418: import org.springframework.security.access.prepost.PreAuthorize;
 419: import org.springframework.web.bind.annotation.*;
 420: 
 421: import com.bht.ludonova.model.Game;
 422: import com.bht.ludonova.model.enums.Platform;
 423: import com.bht.ludonova.service.GameService;
 424: 
 425: import io.swagger.v3.oas.annotations.Operation;
 426: import io.swagger.v3.oas.annotations.Parameter;
 427: import io.swagger.v3.oas.annotations.tags.Tag;
 428: import lombok.RequiredArgsConstructor;
 429: 
 430: @RestController
 431: @RequestMapping("/api/games")
 432: @RequiredArgsConstructor
 433: @Tag(name = "Games", description = "API for managing games") // Tag for Swagger grouping
 434: public class GameController {
 435:     private final GameService gameService;
 436: 
 437:     @GetMapping
 438:     @PreAuthorize("isAuthenticated()")
 439:     public List<Game> getAllGames() {
 440:         return gameService.findAll();
 441:     }
 442: 
 443:     @GetMapping("/{id}")
 444:     @PreAuthorize("isAuthenticated()")
 445:     public ResponseEntity<Game> getGame(@PathVariable Long id) {
 446:         return gameService.findById(id)
 447:                 .map(ResponseEntity::ok)
 448:                 .orElse(ResponseEntity.notFound().build());
 449:     }
 450: 
 451:     @GetMapping("/platform/{platform}")
 452:     @PreAuthorize("isAuthenticated()")
 453:     public List<Game> getGamesByPlatform(@PathVariable Platform platform) {
 454:         return gameService.findByPlatform(platform);
 455:     }
 456: 
 457:     @PostMapping
 458:     @PreAuthorize("hasRole('ADMIN')")
 459:     public ResponseEntity<Game> createGame(@RequestBody Game game) {
 460:         return ResponseEntity.ok(gameService.save(game));
 461:     }
 462: 
 463:     @PutMapping("/{id}")
 464:     @PreAuthorize("hasRole('ADMIN')")
 465:     public ResponseEntity<Game> updateGame(@PathVariable Long id, @RequestBody Game game) {
 466:         if (!id.equals(game.getId())) {
 467:             return ResponseEntity.badRequest().build();
 468:         }
 469:         return ResponseEntity.ok(gameService.save(game));
 470:     }
 471: 
 472:     @DeleteMapping("/{id}")
 473:     @PreAuthorize("hasRole('ADMIN')")
 474:     public ResponseEntity<Void> deleteGame(@PathVariable Long id) {
 475:         gameService.deleteById(id);
 476:         return ResponseEntity.noContent().build();
 477:     }
 478: }
 479: ```
 480: 
 481: ## File: src/main/java/com/bht/ludonova/controller/GameInstanceController.java
 482: ```java
 483: package com.bht.ludonova.controller;
 484: 
 485: import java.util.List;
 486: 
 487: import org.springframework.http.ResponseEntity;
 488: import org.springframework.web.bind.annotation.DeleteMapping;
 489: import org.springframework.web.bind.annotation.GetMapping;
 490: import org.springframework.web.bind.annotation.PatchMapping;
 491: import org.springframework.web.bind.annotation.PathVariable;
 492: import org.springframework.web.bind.annotation.PostMapping;
 493: import org.springframework.web.bind.annotation.PutMapping;
 494: import org.springframework.web.bind.annotation.RequestBody;
 495: import org.springframework.web.bind.annotation.RequestMapping;
 496: import org.springframework.web.bind.annotation.RequestParam;
 497: import org.springframework.web.bind.annotation.RestController;
 498: 
 499: import com.bht.ludonova.model.GameInstance;
 500: import com.bht.ludonova.model.enums.GameStatus;
 501: import com.bht.ludonova.service.GameInstanceService;
 502: 
 503: import lombok.RequiredArgsConstructor;
 504: 
 505: @RestController
 506: @RequestMapping("/api/game-instances")
 507: @RequiredArgsConstructor
 508: public class GameInstanceController {
 509:     private final GameInstanceService gameInstanceService;
 510: 
 511:     @GetMapping("/user/{userId}")
 512:     public List<GameInstance> getUserGameInstances(@PathVariable Long userId) {
 513:         return gameInstanceService.findByUserId(userId);
 514:     }
 515: 
 516:     @GetMapping("/user/{userId}/status/{status}")
 517:     public List<GameInstance> getUserGameInstancesByStatus(
 518:             @PathVariable Long userId,
 519:             @PathVariable GameStatus status) {
 520:         return gameInstanceService.findByUserIdAndStatus(userId, status);
 521:     }
 522: 
 523:     @PostMapping
 524:     public ResponseEntity<GameInstance> createGameInstance(@RequestBody GameInstance gameInstance) {
 525:         return ResponseEntity.ok(gameInstanceService.save(gameInstance));
 526:     }
 527: 
 528:     @PutMapping("/{id}")
 529:     public ResponseEntity<GameInstance> updateGameInstance(
 530:             @PathVariable Long id,
 531:             @RequestBody GameInstance gameInstance) {
 532:         if (!id.equals(gameInstance.getId())) {
 533:             return ResponseEntity.badRequest().build();
 534:         }
 535:         return ResponseEntity.ok(gameInstanceService.save(gameInstance));
 536:     }
 537: 
 538:     @PatchMapping("/{id}/status")
 539:     public ResponseEntity<Void> updateGameStatus(
 540:             @PathVariable Long id,
 541:             @RequestParam GameStatus status) {
 542:         gameInstanceService.updateStatus(id, status);
 543:         return ResponseEntity.ok().build();
 544:     }
 545: 
 546:     @DeleteMapping("/{id}")
 547:     public ResponseEntity<Void> deleteGameInstance(@PathVariable Long id) {
 548:         gameInstanceService.deleteById(id);
 549:         return ResponseEntity.noContent().build();
 550:     }
 551: }
 552: ```
 553: 
 554: ## File: src/main/java/com/bht/ludonova/controller/SteamAuthController.java
 555: ```java
 556: package com.bht.ludonova.controller;
 557: 
 558: import com.bht.ludonova.dto.auth.AuthenticationResponse;
 559: import com.bht.ludonova.exception.SteamAuthenticationException;
 560: import com.bht.ludonova.service.AuthenticationService;
 561: import lombok.extern.slf4j.Slf4j;
 562: import org.springframework.beans.factory.annotation.Value;
 563: import org.springframework.http.ResponseEntity;
 564: import org.springframework.web.bind.annotation.GetMapping;
 565: import org.springframework.web.bind.annotation.RequestMapping;
 566: import org.springframework.web.bind.annotation.RequestParam;
 567: import org.springframework.web.bind.annotation.RestController;
 568: 
 569: import java.net.URLEncoder;
 570: import java.nio.charset.StandardCharsets;
 571: import java.util.Map;
 572: 
 573: @RestController
 574: @RequestMapping("/api/auth/steam")
 575: @Slf4j
 576: public class SteamAuthController {
 577:     private final AuthenticationService authService;
 578: 
 579:     @Value("${steam.return.url}")
 580:     private String returnUrl;
 581: 
 582:     @Value("${steam.realm.url}")
 583:     private String realmUrl;
 584: 
 585:     public SteamAuthController(AuthenticationService authService) {
 586:         this.authService = authService;
 587:     }
 588: 
 589:     @GetMapping("/login")
 590:     public ResponseEntity<Map<String, String>> steamLogin() {
 591:         try {
 592:             String steamOpenIdUrl = buildSteamOpenIdUrl();
 593:             return ResponseEntity.ok(Map.of("url", steamOpenIdUrl));
 594:         } catch (Exception e) {
 595:             log.error("Error generating Steam login URL", e);
 596:             throw new SteamAuthenticationException("Failed to generate Steam login URL");
 597:         }
 598:     }
 599: 
 600:     @GetMapping("/return")
 601:     public ResponseEntity<AuthenticationResponse> steamReturn(@RequestParam Map<String, String> params) {
 602:         log.debug("Received Steam return params: {}", params);
 603:         AuthenticationResponse response = authService.authenticate("steam", params);
 604:         return ResponseEntity.ok(response);
 605:     }
 606: 
 607:     private String buildSteamOpenIdUrl() {
 608:         try {
 609:             String encodedReturnUrl = URLEncoder.encode(returnUrl, StandardCharsets.UTF_8);
 610:             String encodedRealm = URLEncoder.encode(realmUrl, StandardCharsets.UTF_8);
 611: 
 612:             return String.format(
 613:                     "https://steamcommunity.com/openid/login" +
 614:                             "?openid.ns=%s" +
 615:                             "&openid.mode=checkid_setup" +
 616:                             "&openid.return_to=%s" +
 617:                             "&openid.realm=%s" +
 618:                             "&openid.identity=%s" +
 619:                             "&openid.claimed_id=%s",
 620:                     URLEncoder.encode("http://specs.openid.net/auth/2.0", StandardCharsets.UTF_8),
 621:                     encodedReturnUrl,
 622:                     encodedRealm,
 623:                     URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8),
 624:                     URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8)
 625:             );
 626:         } catch (Exception e) {
 627:             log.error("Error building Steam OpenID URL", e);
 628:             throw new SteamAuthenticationException("Failed to build Steam authentication URL");
 629:         }
 630:     }
 631: }
 632: ```
 633: 
 634: ## File: src/main/java/com/bht/ludonova/controller/UserController.java
 635: ```java
 636: package com.bht.ludonova.controller;
 637: 
 638: import com.bht.ludonova.dto.user.UserUpdateDTO;
 639: import com.bht.ludonova.model.User;
 640: import com.bht.ludonova.model.enums.Role;
 641: import com.bht.ludonova.repository.UserRepository;
 642: import org.springframework.beans.factory.annotation.Autowired;
 643: import org.springframework.http.ResponseEntity;
 644: import org.springframework.security.access.prepost.PreAuthorize;
 645: import org.springframework.security.core.annotation.AuthenticationPrincipal;
 646: import org.springframework.security.core.userdetails.UserDetails;
 647: import org.springframework.web.bind.annotation.*;
 648: 
 649: import java.util.List;
 650: 
 651: @RestController
 652: @RequestMapping("/api/user")
 653: public class UserController {
 654: 
 655:     @Autowired
 656:     private UserRepository userRepository;
 657: 
 658:     // Get current user's profile
 659:     @GetMapping("/current")
 660:     public ResponseEntity<User> getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
 661:         return userRepository.findByUsername(userDetails.getUsername())
 662:                 .map(user -> {
 663:                     user.setPassword(null);
 664:                     return ResponseEntity.ok(user);
 665:                 })
 666:                 .orElse(ResponseEntity.notFound().build());
 667:     }
 668: 
 669:     // Update current user's profile
 670:     @PutMapping("/current")
 671:     public ResponseEntity<User> updateCurrentUser(
 672:             @AuthenticationPrincipal UserDetails userDetails,
 673:             @RequestBody UserUpdateDTO updateDTO) {
 674:         return userRepository.findByUsername(userDetails.getUsername())
 675:                 .map(user -> {
 676:                     if (updateDTO.getEmail() != null) {
 677:                         user.setEmail(updateDTO.getEmail());
 678:                     }
 679:                     // Don't allow role updates through this endpoint
 680:                     User updatedUser = userRepository.save(user);
 681:                     updatedUser.setPassword(null);
 682:                     return ResponseEntity.ok(updatedUser);
 683:                 })
 684:                 .orElse(ResponseEntity.notFound().build());
 685:     }
 686: 
 687:     // Admin endpoints below
 688:     
 689:     // Get all users (admin only)
 690:     @GetMapping
 691:     @PreAuthorize("hasRole('ADMIN')")
 692:     public ResponseEntity<List<User>> getAllUsers() {
 693:         List<User> users = userRepository.findAll();
 694:         users.forEach(user -> user.setPassword(null));
 695:         return ResponseEntity.ok(users);
 696:     }
 697: 
 698:     // Get specific user (admin only)
 699:     @GetMapping("/{id}")
 700:     @PreAuthorize("hasRole('ADMIN')")
 701:     public ResponseEntity<User> getUser(@PathVariable Long id) {
 702:         return userRepository.findById(id)
 703:                 .map(user -> {
 704:                     user.setPassword(null);
 705:                     return ResponseEntity.ok(user);
 706:                 })
 707:                 .orElse(ResponseEntity.notFound().build());
 708:     }
 709: 
 710:     // Update any user (admin only)
 711:     @PutMapping("/{id}")
 712:     @PreAuthorize("hasRole('ADMIN')")
 713:     public ResponseEntity<User> updateUser(
 714:             @PathVariable Long id,
 715:             @RequestBody UserUpdateDTO updateDTO) {
 716:         return userRepository.findById(id)
 717:                 .map(user -> {
 718:                     if (updateDTO.getEmail() != null) {
 719:                         user.setEmail(updateDTO.getEmail());
 720:                     }
 721:                     if (updateDTO.getRole() != null) {
 722:                         user.setRole(updateDTO.getRole());
 723:                     }
 724:                     User updatedUser = userRepository.save(user);
 725:                     updatedUser.setPassword(null);
 726:                     return ResponseEntity.ok(updatedUser);
 727:                 })
 728:                 .orElse(ResponseEntity.notFound().build());
 729:     }
 730: 
 731:     // Delete user (admin only)
 732:     @DeleteMapping("/{id}")
 733:     @PreAuthorize("hasRole('ADMIN')")
 734:     public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
 735:         if (userRepository.existsById(id)) {
 736:             userRepository.deleteById(id);
 737:             return ResponseEntity.ok().build();
 738:         }
 739:         return ResponseEntity.notFound().build();
 740:     }
 741: }
 742: ```
 743: 
 744: ## File: src/main/java/com/bht/ludonova/dto/auth/AuthenticationResponse.java
 745: ```java
 746: package com.bht.ludonova.dto.auth;
 747: 
 748: import com.bht.ludonova.dto.user.UserDTO;
 749: import lombok.Data;
 750: 
 751: @Data
 752: public class AuthenticationResponse {
 753:     private final TokenResponse tokens;
 754:     private final UserDTO user;
 755: }
 756: ```
 757: 
 758: ## File: src/main/java/com/bht/ludonova/dto/auth/LoginRequest.java
 759: ```java
 760: package com.bht.ludonova.dto.auth;
 761: 
 762: import lombok.Data;
 763: 
 764: @Data
 765: public class LoginRequest {
 766:     private String username;
 767:     private String password;
 768: }
 769: ```
 770: 
 771: ## File: src/main/java/com/bht/ludonova/dto/auth/RefreshTokenRequest.java
 772: ```java
 773: package com.bht.ludonova.dto.auth;
 774: 
 775: import lombok.Data;
 776: 
 777: @Data
 778: public class RefreshTokenRequest {
 779:     private String refreshToken;
 780: }
 781: ```
 782: 
 783: ## File: src/main/java/com/bht/ludonova/dto/auth/TokenResponse.java
 784: ```java
 785: package com.bht.ludonova.dto.auth;
 786: 
 787: import lombok.Data;
 788: 
 789: @Data
 790: public class TokenResponse {
 791:     private final String accessToken;
 792:     private final String refreshToken;
 793:     private final String tokenType;
 794:     private final long expiresIn;
 795: 
 796:     public static TokenResponse of(String accessToken, String refreshToken, long expiresIn) {
 797:         return new TokenResponse(accessToken, refreshToken, "Bearer", expiresIn);
 798:     }
 799: }
 800: ```
 801: 
 802: ## File: src/main/java/com/bht/ludonova/dto/game/AdminGameUpdateDTO.java
 803: ```java
 804: package com.bht.ludonova.dto.game;
 805: 
 806: import com.bht.ludonova.model.enums.GameSource;
 807: import com.bht.ludonova.model.enums.Platform;
 808: import lombok.Data;
 809: 
 810: import java.time.LocalDate;
 811: import java.util.Set;
 812: 
 813: @Data
 814: public class AdminGameUpdateDTO {
 815:     private String title;
 816:     private Platform platform;
 817:     private LocalDate releaseDate;
 818:     private Set<String> genres;
 819:     private GameSource source;
 820:     private String apiId;
 821: }
 822: ```
 823: 
 824: ## File: src/main/java/com/bht/ludonova/dto/game/GameInstanceUpdateDTO.java
 825: ```java
 826: package com.bht.ludonova.dto.game;
 827: 
 828: import lombok.Data;
 829: 
 830: @Data
 831: public class GameInstanceUpdateDTO {
 832:     private String status;          // PLAYING, COMPLETED, BACKLOG, etc.
 833:     private Integer progressPercentage;
 834:     private Integer playTime;
 835:     private String notes;
 836: }
 837: ```
 838: 
 839: ## File: src/main/java/com/bht/ludonova/dto/game/GameUpdateDTO.java
 840: ```java
 841: package com.bht.ludonova.dto.game;
 842: 
 843: import com.bht.ludonova.model.enums.Platform;
 844: import lombok.Data;
 845: 
 846: import java.util.Set;
 847: 
 848: @Data
 849: public class GameUpdateDTO {
 850:     private String title;
 851:     private Platform platform;
 852:     private Set<String> genres;
 853:     // TODO evaluate, if these should be able to be updated by the user.
 854: //    private LocalDate releaseDate;
 855: //    private GameSource source;
 856: }
 857: ```
 858: 
 859: ## File: src/main/java/com/bht/ludonova/dto/steam/SteamApiResponseDTO.java
 860: ```java
 861: package com.bht.ludonova.dto.steam;
 862: 
 863: import com.fasterxml.jackson.annotation.JsonProperty;
 864: import lombok.Data;
 865: 
 866: import java.util.List;
 867: 
 868: @Data
 869: public class SteamApiResponseDTO {
 870:     private Response response;
 871: 
 872:     @Data
 873:     public static class Response {
 874:         private List<Player> players;
 875:     }
 876: 
 877:     @Data
 878:     public static class Player {
 879:         @JsonProperty("steamid")
 880:         private String steamId;
 881: 
 882:         @JsonProperty("personaname")
 883:         private String personaName;
 884: 
 885:         @JsonProperty("profileurl")
 886:         private String profileUrl;
 887: 
 888:         @JsonProperty("avatar")
 889:         private String avatarUrl;
 890:     }
 891: }
 892: ```
 893: 
 894: ## File: src/main/java/com/bht/ludonova/dto/steam/SteamAuthRequest.java
 895: ```java
 896: package com.bht.ludonova.dto.steam;
 897: 
 898: import lombok.Data;
 899: 
 900: import java.util.Map;
 901: 
 902: @Data
 903: public class SteamAuthRequest {
 904:     private final Map<String, String> openIdParams;
 905: }
 906: ```
 907: 
 908: ## File: src/main/java/com/bht/ludonova/dto/steam/SteamUserDTO.java
 909: ```java
 910: package com.bht.ludonova.dto.steam;
 911: 
 912: import lombok.Data;
 913: 
 914: @Data
 915: public class SteamUserDTO {
 916:     private String steamId;
 917:     private String personaName;
 918:     private String profileUrl;
 919:     private String avatarUrl;
 920: }
 921: ```
 922: 
 923: ## File: src/main/java/com/bht/ludonova/dto/user/UserDTO.java
 924: ```java
 925: package com.bht.ludonova.dto.user;
 926: 
 927: import com.bht.ludonova.dto.steam.SteamUserDTO;
 928: import com.bht.ludonova.model.enums.Role;
 929: 
 930: import lombok.Data;
 931: 
 932: @Data
 933: public class UserDTO {
 934:     private Long id;
 935:     private String username;
 936:     private String email;
 937:     private Role role;
 938:     private SteamUserDTO steamUser;
 939: }
 940: ```
 941: 
 942: ## File: src/main/java/com/bht/ludonova/dto/user/UserUpdateDTO.java
 943: ```java
 944: package com.bht.ludonova.dto.user;
 945: 
 946: import com.bht.ludonova.model.enums.Role;
 947: import lombok.Data;
 948: 
 949: @Data
 950: public class UserUpdateDTO {
 951:     private String email;
 952:     private Role role;  // Only used in admin endpoints
 953: }
 954: ```
 955: 
 956: ## File: src/main/java/com/bht/ludonova/dto/ErrorResponse.java
 957: ```java
 958: package com.bht.ludonova.dto;
 959: 
 960: import lombok.Data;
 961: 
 962: @Data
 963: public class ErrorResponse {
 964:     private final String errorCode;
 965:     private final String message;
 966:     private final int status;
 967: }
 968: ```
 969: 
 970: ## File: src/main/java/com/bht/ludonova/exception/AuthenticationException.java
 971: ```java
 972: package com.bht.ludonova.exception;
 973: 
 974: public class AuthenticationException extends LudoNovaException {
 975:     public AuthenticationException(String message) {
 976:         super(message, "AUTH_ERROR");
 977:     }
 978: }
 979: ```
 980: 
 981: ## File: src/main/java/com/bht/ludonova/exception/GlobalExceptionHandler.java
 982: ```java
 983: package com.bht.ludonova.exception;
 984: 
 985: import com.bht.ludonova.dto.ErrorResponse;
 986: import org.springframework.http.HttpStatus;
 987: import org.springframework.http.ResponseEntity;
 988: import org.springframework.web.bind.annotation.ExceptionHandler;
 989: import org.springframework.web.bind.annotation.RestControllerAdvice;
 990: 
 991: @RestControllerAdvice
 992: public class GlobalExceptionHandler {
 993: 
 994:     @ExceptionHandler(AuthenticationException.class)
 995:     public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {
 996:         ErrorResponse error = new ErrorResponse(
 997:                 ex.getErrorCode(),
 998:                 ex.getMessage(),
 999:                 HttpStatus.UNAUTHORIZED.value()
1000:         );
1001:         return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
1002:     }
1003: 
1004:     @ExceptionHandler(SteamAuthenticationException.class)
1005:     public ResponseEntity<ErrorResponse> handleSteamAuthenticationException(SteamAuthenticationException ex) {
1006:         ErrorResponse error = new ErrorResponse(
1007:                 ex.getErrorCode(),
1008:                 ex.getMessage(),
1009:                 HttpStatus.UNAUTHORIZED.value()
1010:         );
1011:         return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
1012:     }
1013: 
1014:     @ExceptionHandler(Exception.class)
1015:     public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
1016:         ErrorResponse error = new ErrorResponse(
1017:                 "INTERNAL_ERROR",
1018:                 "An unexpected error occurred",
1019:                 HttpStatus.INTERNAL_SERVER_ERROR.value()
1020:         );
1021:         return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
1022:     }
1023: }
1024: ```
1025: 
1026: ## File: src/main/java/com/bht/ludonova/exception/LudoNovaException.java
1027: ```java
1028: package com.bht.ludonova.exception;
1029: 
1030: public class LudoNovaException extends RuntimeException {
1031:     private final String errorCode;
1032: 
1033:     public LudoNovaException(String message, String errorCode) {
1034:         super(message);
1035:         this.errorCode = errorCode;
1036:     }
1037: 
1038:     public String getErrorCode() {
1039:         return errorCode;
1040:     }
1041: }
1042: ```
1043: 
1044: ## File: src/main/java/com/bht/ludonova/exception/SteamAuthenticationException.java
1045: ```java
1046: package com.bht.ludonova.exception;
1047: 
1048: public class SteamAuthenticationException extends AuthenticationException {
1049:     public SteamAuthenticationException(String message) {
1050:         super("Steam authentication failed: " + message);
1051:     }
1052: }
1053: ```
1054: 
1055: ## File: src/main/java/com/bht/ludonova/exception/UnauthorizedException.java
1056: ```java
1057: package com.bht.ludonova.exception;
1058: 
1059: public class UnauthorizedException extends RuntimeException {
1060:     public UnauthorizedException(String message) {
1061:         super(message);
1062:     }
1063: }
1064: ```
1065: 
1066: ## File: src/main/java/com/bht/ludonova/model/enums/GameSource.java
1067: ```java
1068: package com.bht.ludonova.model.enums;
1069: 
1070: import lombok.Getter;
1071: 
1072: @Getter
1073: public enum GameSource {
1074:     STEAM,
1075:     RAWG,
1076:     MANUAL
1077: }
1078: ```
1079: 
1080: ## File: src/main/java/com/bht/ludonova/model/enums/GameStatus.java
1081: ```java
1082: package com.bht.ludonova.model.enums;
1083: 
1084: import lombok.Getter;
1085: 
1086: @Getter
1087: public enum GameStatus {
1088:     PLAYING,
1089:     COMPLETED,
1090:     PLAN_TO_PLAY,
1091:     DROPPED
1092: }
1093: ```
1094: 
1095: ## File: src/main/java/com/bht/ludonova/model/enums/Platform.java
1096: ```java
1097: package com.bht.ludonova.model.enums;
1098: 
1099: import lombok.Getter;
1100: 
1101: 
1102: @Getter
1103: public enum Platform {
1104:     // Sony PlayStation
1105:     PS1("PlayStation"),
1106:     PS2("PlayStation 2"),
1107:     PS3("PlayStation 3"),
1108:     PS4("PlayStation 4"),
1109:     PS5("PlayStation 5"),
1110: 
1111:     // Microsoft Xbox
1112:     XBOX("Xbox"),
1113:     XBOX_360("Xbox 360"),
1114:     XBOX_ONE("Xbox One"),
1115:     XBOX_SERIES_X("Xbox Series X"),
1116:     XBOX_SERIES_S("Xbox Series S"),
1117: 
1118:     // Nintendo
1119:     SWITCH("Nintendo Switch"),
1120:     WII("Nintendo Wii"),
1121:     WII_U("Nintendo Wii U"),
1122:     NINTENDO_3DS("Nintendo 3DS"),
1123:     NINTENDO_DS("Nintendo DS"),
1124: 
1125:     // PC Platforms
1126:     PC("PC"),
1127:     MAC("Mac"),
1128:     LINUX("Linux");
1129: 
1130:     private final String displayName;
1131: 
1132:     Platform(String displayName) {
1133:         this.displayName = displayName;
1134:     }
1135: 
1136: }
1137: ```
1138: 
1139: ## File: src/main/java/com/bht/ludonova/model/enums/Role.java
1140: ```java
1141: package com.bht.ludonova.model.enums;
1142: 
1143: import lombok.Getter;
1144: 
1145: @Getter
1146: public enum Role {
1147:     USER,
1148:     ADMIN
1149: }
1150: ```
1151: 
1152: ## File: src/main/java/com/bht/ludonova/model/Game.java
1153: ```java
1154: package com.bht.ludonova.model;
1155: 
1156: import com.bht.ludonova.model.enums.GameSource;
1157: import com.bht.ludonova.model.enums.Platform;
1158: import jakarta.persistence.*;
1159: import lombok.Data;
1160: import lombok.Builder;
1161: import lombok.NoArgsConstructor;
1162: import lombok.AllArgsConstructor;
1163: 
1164: import java.time.LocalDate;
1165: import java.util.HashSet;
1166: import java.util.Set;
1167: 
1168: @Data
1169: @Builder
1170: @NoArgsConstructor
1171: @AllArgsConstructor
1172: @Entity
1173: @Table(name = "games")
1174: public class Game {
1175:     @Id
1176:     @GeneratedValue(strategy = GenerationType.IDENTITY)
1177:     private Long id;
1178: 
1179:     @Column(nullable = false)
1180:     private String title;
1181: 
1182:     @Enumerated(EnumType.STRING)
1183:     @Column(nullable = false)
1184:     private Platform platform;
1185: 
1186:     @Column(name = "api_id")
1187:     private String apiId;  // Steam AppId or RAWG ID
1188: 
1189:     @Column(name = "release_date")
1190:     private LocalDate releaseDate;
1191: 
1192:     @ElementCollection
1193:     @CollectionTable(name = "game_genres",
1194:             joinColumns = @JoinColumn(name = "game_id"))
1195:     @Column(name = "genre")
1196:     @Builder.Default
1197:     private Set<String> genres = new HashSet<>();
1198: 
1199:     @Enumerated(EnumType.STRING)
1200:     @Column(nullable = false)
1201:     private GameSource source;
1202: 
1203:     @OneToMany(mappedBy = "game")
1204:     @Builder.Default
1205:     private Set<GameInstance> instances = new HashSet<>();
1206: }
1207: ```
1208: 
1209: ## File: src/main/java/com/bht/ludonova/model/GameInstance.java
1210: ```java
1211: package com.bht.ludonova.model;
1212: 
1213: import com.bht.ludonova.model.enums.GameStatus;
1214: import jakarta.persistence.*;
1215: import lombok.AllArgsConstructor;
1216: import lombok.Builder;
1217: import lombok.Data;
1218: import lombok.NoArgsConstructor;
1219: 
1220: import java.time.LocalDateTime;
1221: 
1222: @Data
1223: @Builder
1224: @NoArgsConstructor
1225: @AllArgsConstructor
1226: @Entity
1227: @Table(name = "game_instances")
1228: public class GameInstance {
1229:     @Id
1230:     @GeneratedValue(strategy = GenerationType.IDENTITY)
1231:     private Long id;
1232: 
1233:     @ManyToOne(fetch = FetchType.LAZY)
1234:     @JoinColumn(name = "user_id", nullable = false)
1235:     private User user;
1236: 
1237:     @ManyToOne(fetch = FetchType.LAZY)
1238:     @JoinColumn(name = "game_id", nullable = false)
1239:     private Game game;
1240: 
1241:     @Enumerated(EnumType.STRING)
1242:     @Column(nullable = false)
1243:     private GameStatus status;
1244: 
1245:     @Column(name = "progress_percentage")
1246:     private Integer progressPercentage;
1247: 
1248:     @Column(name = "play_time")
1249:     private Integer playTime;
1250: 
1251:     @Column(name = "last_played")
1252:     private LocalDateTime lastPlayed;
1253: 
1254:     private String notes;
1255: }
1256: ```
1257: 
1258: ## File: src/main/java/com/bht/ludonova/model/Review.java
1259: ```java
1260: package com.bht.ludonova.model;
1261: 
1262: import jakarta.persistence.*;
1263: import jakarta.validation.constraints.Max;
1264: import jakarta.validation.constraints.Min;
1265: import lombok.AllArgsConstructor;
1266: import lombok.Builder;
1267: import lombok.Data;
1268: import lombok.NoArgsConstructor;
1269: 
1270: import java.time.LocalDateTime;
1271: 
1272: @Data
1273: @Builder
1274: @NoArgsConstructor
1275: @AllArgsConstructor
1276: @Entity
1277: @Table(name = "reviews")
1278: public class Review {
1279:     @Id
1280:     @GeneratedValue(strategy = GenerationType.IDENTITY)
1281:     private Long id;
1282: 
1283:     @ManyToOne(fetch = FetchType.LAZY)
1284:     @JoinColumn(name = "user_id", nullable = false)
1285:     private User user;
1286: 
1287:     @ManyToOne(fetch = FetchType.LAZY)
1288:     @JoinColumn(name = "game_id", nullable = false)
1289:     private Game game;
1290: 
1291:     @Min(1)
1292:     @Max(5)
1293:     private Integer rating;
1294: 
1295:     @Column(name = "review_text")
1296:     private String reviewText;
1297: 
1298:     @Column(name = "created_at")
1299:     private LocalDateTime createdAt;
1300: }
1301: ```
1302: 
1303: ## File: src/main/java/com/bht/ludonova/model/SteamUser.java
1304: ```java
1305: package com.bht.ludonova.model;
1306: 
1307: import lombok.Data;
1308: import jakarta.persistence.Entity;
1309: import jakarta.persistence.Table;
1310: import jakarta.persistence.Id;
1311: import jakarta.persistence.OneToOne;
1312: 
1313: @Data
1314: @Entity
1315: @Table(name = "steam_users")
1316: public class SteamUser {
1317:     @Id
1318:     private String steamId;
1319:     
1320:     private String personaName;
1321:     private String profileUrl;
1322:     private String avatarUrl;
1323:     
1324:     @OneToOne(mappedBy = "steamUser")
1325:     private User user;
1326: }
1327: ```
1328: 
1329: ## File: src/main/java/com/bht/ludonova/model/User.java
1330: ```java
1331: package com.bht.ludonova.model;
1332: 
1333: import com.bht.ludonova.model.enums.Role;
1334: import jakarta.persistence.*;
1335: import lombok.Data;
1336: import lombok.Builder;
1337: import lombok.NoArgsConstructor;
1338: import lombok.AllArgsConstructor;
1339: 
1340: @Data
1341: @Builder
1342: @NoArgsConstructor
1343: @AllArgsConstructor
1344: @Entity
1345: @Table(name = "users")
1346: public class User {
1347:     @Id
1348:     @GeneratedValue(strategy = GenerationType.IDENTITY)
1349:     private Long id;
1350: 
1351:     @Column(unique = true, nullable = false)
1352:     private String username;
1353: 
1354:     @Column(nullable = false)
1355:     private String password;
1356: 
1357:     @Column
1358:     private String email;
1359: 
1360:     @OneToOne(cascade = CascadeType.ALL)
1361:     @JoinColumn(name = "steam_id")
1362:     private SteamUser steamUser;
1363: 
1364:     @Enumerated(EnumType.STRING)
1365:     @Column(nullable = false)
1366:     private Role role = Role.USER;  // Default to USER role
1367: }
1368: ```
1369: 
1370: ## File: src/main/java/com/bht/ludonova/repository/GameInstanceRepository.java
1371: ```java
1372: package com.bht.ludonova.repository;
1373: 
1374: import com.bht.ludonova.model.GameInstance;
1375: import com.bht.ludonova.model.enums.GameStatus;
1376: import org.springframework.data.jpa.repository.JpaRepository;
1377: import org.springframework.data.jpa.repository.Query;
1378: import org.springframework.stereotype.Repository;
1379: 
1380: import java.util.List;
1381: import java.util.Optional;
1382: 
1383: @Repository
1384: public interface GameInstanceRepository extends JpaRepository<GameInstance, Long> {
1385:     List<GameInstance> findByUserId(Long userId);
1386:     Optional<GameInstance> findByUserIdAndGameId(Long userId, Long gameId);
1387:     boolean existsByUserIdAndGameId(Long userId, Long gameId);
1388: 
1389:     @Query("SELECT gi FROM GameInstance gi WHERE gi.user.id = :userId AND gi.status = :status")
1390:     List<GameInstance> findByUserIdAndStatus(Long userId, GameStatus status);
1391: }
1392: ```
1393: 
1394: ## File: src/main/java/com/bht/ludonova/repository/GameRepository.java
1395: ```java
1396: package com.bht.ludonova.repository;
1397: 
1398: import com.bht.ludonova.model.Game;
1399: import com.bht.ludonova.model.enums.GameSource;
1400: import com.bht.ludonova.model.enums.Platform;
1401: import org.springframework.data.jpa.repository.JpaRepository;
1402: import org.springframework.stereotype.Repository;
1403: 
1404: import java.util.List;
1405: import java.util.Optional;
1406: 
1407: @Repository
1408: public interface GameRepository extends JpaRepository<Game, Long> {
1409:     Optional<Game> findByApiIdAndSource(String apiId, GameSource source);
1410:     List<Game> findByPlatform(Platform platform);
1411: }
1412: ```
1413: 
1414: ## File: src/main/java/com/bht/ludonova/repository/ReviewRepository.java
1415: ```java
1416: package com.bht.ludonova.repository;
1417: 
1418: import com.bht.ludonova.model.Review;
1419: import org.springframework.data.jpa.repository.JpaRepository;
1420: import org.springframework.stereotype.Repository;
1421: 
1422: import java.util.List;
1423: import java.util.Optional;
1424: 
1425: @Repository
1426: public interface ReviewRepository extends JpaRepository<Review, Long> {
1427:     List<Review> findByGameId(Long gameId);
1428:     List<Review> findByUserId(Long userId);
1429:     Optional<Review> findByUserIdAndGameId(Long userId, Long gameId);
1430: }
1431: ```
1432: 
1433: ## File: src/main/java/com/bht/ludonova/repository/UserRepository.java
1434: ```java
1435: package com.bht.ludonova.repository;
1436: 
1437: import com.bht.ludonova.model.User;
1438: import org.springframework.data.jpa.repository.JpaRepository;
1439: import org.springframework.stereotype.Repository;
1440: import java.util.Optional;
1441: 
1442: @Repository
1443: public interface UserRepository extends JpaRepository<User, Long> {
1444:     Optional<User> findByUsername(String username);
1445:     Optional<User> findBySteamUser_SteamId(String steamId);
1446: }
1447: ```
1448: 
1449: ## File: src/main/java/com/bht/ludonova/security/AuthenticationExceptionHandler.java
1450: ```java
1451: package com.bht.ludonova.security;
1452: 
1453: import com.fasterxml.jackson.databind.ObjectMapper;
1454: import jakarta.servlet.ServletException;
1455: import jakarta.servlet.http.HttpServletRequest;
1456: import jakarta.servlet.http.HttpServletResponse;
1457: import lombok.extern.slf4j.Slf4j;
1458: import org.springframework.http.MediaType;
1459: import org.springframework.security.core.AuthenticationException;
1460: import org.springframework.security.web.AuthenticationEntryPoint;
1461: import org.springframework.security.web.access.AccessDeniedHandler;
1462: import org.springframework.security.access.AccessDeniedException;
1463: import org.springframework.stereotype.Component;
1464: 
1465: import java.io.IOException;
1466: import java.util.HashMap;
1467: import java.util.Map;
1468: 
1469: @Slf4j
1470: @Component
1471: public class AuthenticationExceptionHandler implements AuthenticationEntryPoint, AccessDeniedHandler {
1472: 
1473:     private final ObjectMapper objectMapper = new ObjectMapper();
1474: 
1475:     @Override
1476:     public void commence(HttpServletRequest request, HttpServletResponse response,
1477:                          AuthenticationException authException) throws IOException, ServletException {
1478:         log.error("Unauthorized error: {}", authException.getMessage());
1479: 
1480:         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
1481:         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
1482: 
1483:         Map<String, Object> body = new HashMap<>();
1484:         body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
1485:         body.put("error", "Unauthorized");
1486:         body.put("message", authException.getMessage());
1487:         body.put("path", request.getServletPath());
1488: 
1489:         objectMapper.writeValue(response.getOutputStream(), body);
1490:     }
1491: 
1492:     @Override
1493:     public void handle(HttpServletRequest request, HttpServletResponse response,
1494:                        AccessDeniedException accessDeniedException) throws IOException, ServletException {
1495:         log.error("Access denied error: {}", accessDeniedException.getMessage());
1496: 
1497:         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
1498:         response.setStatus(HttpServletResponse.SC_FORBIDDEN);
1499: 
1500:         Map<String, Object> body = new HashMap<>();
1501:         body.put("status", HttpServletResponse.SC_FORBIDDEN);
1502:         body.put("error", "Forbidden");
1503:         body.put("message", accessDeniedException.getMessage());
1504:         body.put("path", request.getServletPath());
1505: 
1506:         objectMapper.writeValue(response.getOutputStream(), body);
1507:     }
1508: }
1509: ```
1510: 
1511: ## File: src/main/java/com/bht/ludonova/security/CustomUserDetailsService.java
1512: ```java
1513: package com.bht.ludonova.security;
1514: 
1515: import com.bht.ludonova.model.User;
1516: import com.bht.ludonova.repository.UserRepository;
1517: import lombok.RequiredArgsConstructor;
1518: import lombok.extern.slf4j.Slf4j;
1519: import org.springframework.security.core.authority.SimpleGrantedAuthority;
1520: import org.springframework.security.core.userdetails.UserDetails;
1521: import org.springframework.security.core.userdetails.UserDetailsService;
1522: import org.springframework.security.core.userdetails.UsernameNotFoundException;
1523: import org.springframework.stereotype.Service;
1524: import org.springframework.transaction.annotation.Transactional;
1525: 
1526: import java.util.Collections;
1527: 
1528: @Slf4j
1529: @Service
1530: @RequiredArgsConstructor
1531: public class CustomUserDetailsService implements UserDetailsService {
1532: 
1533:     private final UserRepository userRepository;
1534: 
1535:     @Override
1536:     @Transactional(readOnly = true)
1537:     public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
1538:         User user = userRepository.findByUsername(username)
1539:                 .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));
1540: 
1541:         return org.springframework.security.core.userdetails.User.builder()
1542:                 .username(user.getUsername())
1543:                 .password(user.getPassword())
1544:                 .authorities(Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")))
1545:                 .accountExpired(false)
1546:                 .accountLocked(false)
1547:                 .credentialsExpired(false)
1548:                 .disabled(false)
1549:                 .build();
1550:     }
1551: }
1552: ```
1553: 
1554: ## File: src/main/java/com/bht/ludonova/security/JwtAuthenticationFilter.java
1555: ```java
1556: package com.bht.ludonova.security;
1557: 
1558: import com.bht.ludonova.exception.AuthenticationException;
1559: import jakarta.servlet.FilterChain;
1560: import jakarta.servlet.ServletException;
1561: import jakarta.servlet.http.HttpServletRequest;
1562: import jakarta.servlet.http.HttpServletResponse;
1563: import lombok.RequiredArgsConstructor;
1564: import lombok.extern.slf4j.Slf4j;
1565: import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
1566: import org.springframework.security.core.context.SecurityContextHolder;
1567: import org.springframework.security.core.userdetails.UserDetails;
1568: import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
1569: import org.springframework.stereotype.Component;
1570: import org.springframework.util.AntPathMatcher;
1571: import org.springframework.util.StringUtils;
1572: import org.springframework.web.filter.OncePerRequestFilter;
1573: 
1574: import java.io.IOException;
1575: import java.util.Arrays;
1576: import java.util.List;
1577: 
1578: @Slf4j
1579: @Component
1580: @RequiredArgsConstructor
1581: public class JwtAuthenticationFilter extends OncePerRequestFilter {
1582: 
1583:     private final JwtTokenProvider tokenProvider;
1584:     private final CustomUserDetailsService customUserDetailsService;
1585:     private final AntPathMatcher pathMatcher = new AntPathMatcher();
1586: 
1587:     // List of paths that don't require authentication
1588:     private final List<String> publicPaths = Arrays.asList(
1589:             "/api/auth/**",
1590:             "/api/test/public"
1591:     );
1592: 
1593:     @Override
1594:     protected boolean shouldNotFilter(HttpServletRequest request) {
1595:         String path = request.getServletPath();
1596:         return publicPaths.stream()
1597:                 .anyMatch(pattern -> pathMatcher.match(pattern, path));
1598:     }
1599: 
1600:     @Override
1601:     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
1602:             throws ServletException, IOException {
1603:         try {
1604:             String jwt = getJwtFromRequest(request);
1605: 
1606:             if (StringUtils.hasText(jwt)) {
1607:                 if (!tokenProvider.validateToken(jwt)) {
1608:                     throw new AuthenticationException("Invalid or expired JWT token");
1609:                 }
1610: 
1611:                 String username = tokenProvider.getUsernameFromToken(jwt);
1612:                 UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);
1613: 
1614:                 UsernamePasswordAuthenticationToken authentication =
1615:                         new UsernamePasswordAuthenticationToken(
1616:                                 userDetails,
1617:                                 null,
1618:                                 userDetails.getAuthorities()
1619:                         );
1620:                 authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
1621: 
1622:                 SecurityContextHolder.getContext().setAuthentication(authentication);
1623:             }
1624:         } catch (Exception ex) {
1625:             log.error("Could not set user authentication in security context", ex);
1626:             SecurityContextHolder.clearContext();
1627: 
1628:             if (ex instanceof AuthenticationException) {
1629:                 throw ex;
1630:             }
1631:         }
1632: 
1633:         filterChain.doFilter(request, response);
1634:     }
1635: 
1636:     private String getJwtFromRequest(HttpServletRequest request) {
1637:         String bearerToken = request.getHeader("Authorization");
1638:         if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
1639:             return bearerToken.substring(7);
1640:         }
1641:         return null;
1642:     }
1643: 
1644:     /**
1645:      * Helper method to check if token is about to expire
1646:      * Could be used to implement token refresh logic
1647:      */
1648:     private boolean shouldRefreshToken(String token) {
1649:         return tokenProvider.isTokenExpired(token, false);
1650:     }
1651: }
1652: ```
1653: 
1654: ## File: src/main/java/com/bht/ludonova/security/JwtTokenProvider.java
1655: ```java
1656: package com.bht.ludonova.security;
1657: 
1658: 
1659: import io.jsonwebtoken.*;
1660: import io.jsonwebtoken.security.Keys;
1661: import io.jsonwebtoken.security.SignatureException;
1662: import lombok.extern.slf4j.Slf4j;
1663: import org.springframework.beans.factory.annotation.Value;
1664: import org.springframework.security.core.Authentication;
1665: import org.springframework.security.core.GrantedAuthority;
1666: import org.springframework.stereotype.Component;
1667: 
1668: import javax.crypto.SecretKey;
1669: import java.nio.charset.StandardCharsets;
1670: import java.util.Date;
1671: import java.util.HashMap;
1672: import java.util.Map;
1673: import java.util.stream.Collectors;
1674: 
1675: @Slf4j
1676: @Component
1677: public class JwtTokenProvider {
1678: 
1679:     private final SecretKey accessTokenKey;
1680:     private final SecretKey refreshTokenKey;
1681:     private final long accessTokenExpirationMs; // Changed to long
1682:     private final long refreshTokenExpirationMs; // Changed to long
1683: 
1684:     public JwtTokenProvider(
1685:             @Value("${jwt.secret}") String jwtSecret,
1686:             @Value("${jwt.refresh-secret:${jwt.secret}}") String refreshSecret,
1687:             @Value("${jwt.expiration}") long accessTokenExpirationMs, // Changed to long
1688:             @Value("${jwt.refresh-expiration:2592000000}") long refreshTokenExpirationMs) { // Changed to long
1689:         this.accessTokenKey = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
1690:         this.refreshTokenKey = Keys.hmacShaKeyFor(refreshSecret.getBytes(StandardCharsets.UTF_8));
1691:         this.accessTokenExpirationMs = accessTokenExpirationMs;
1692:         this.refreshTokenExpirationMs = refreshTokenExpirationMs;
1693:     }
1694: 
1695:     public String generateAccessToken(Authentication authentication) {
1696:         return generateAccessToken(authentication.getName(), createClaims(authentication));
1697:     }
1698: 
1699:     public String generateAccessToken(String username) {
1700:         return generateAccessToken(username, new HashMap<>());
1701:     }
1702: 
1703:     public String generateAccessToken(String username, Map<String, Object> claims) {
1704:         return generateToken(username, claims, accessTokenKey, accessTokenExpirationMs);
1705:     }
1706: 
1707:     public String generateRefreshToken(String username) {
1708:         return generateToken(username, new HashMap<>(), refreshTokenKey, refreshTokenExpirationMs);
1709:     }
1710: 
1711:     private String generateToken(String username, Map<String, Object> claims, SecretKey key, long expirationMs) {
1712:         Date now = new Date();
1713:         Date expiryDate = new Date(now.getTime() + expirationMs);
1714: 
1715:         return Jwts.builder()
1716:                 .setClaims(claims)
1717:                 .setSubject(username)
1718:                 .setIssuedAt(now)
1719:                 .setExpiration(expiryDate)
1720:                 .signWith(key, SignatureAlgorithm.HS512)
1721:                 .compact();
1722:     }
1723: 
1724:     private Map<String, Object> createClaims(Authentication authentication) {
1725:         Map<String, Object> claims = new HashMap<>();
1726: 
1727:         // Add user authorities/roles
1728:         String authorities = authentication.getAuthorities().stream()
1729:                 .map(GrantedAuthority::getAuthority)
1730:                 .collect(Collectors.joining(","));
1731:         claims.put("authorities", authorities);
1732: 
1733:         // Add token type
1734:         claims.put("type", "Bearer");
1735: 
1736:         return claims;
1737:     }
1738: 
1739:     public String getUsernameFromToken(String token, boolean isRefreshToken) {
1740:         return getClaimsFromToken(token, isRefreshToken).getSubject();
1741:     }
1742: 
1743:     public String getUsernameFromToken(String token) {
1744:         return getUsernameFromToken(token, false);
1745:     }
1746: 
1747:     public boolean validateToken(String token) {
1748:         return validateToken(token, false);
1749:     }
1750: 
1751:     public boolean validateToken(String token, boolean isRefreshToken) {
1752:         try {
1753:             SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
1754:             Jwts.parserBuilder()
1755:                     .setSigningKey(key)
1756:                     .build()
1757:                     .parseClaimsJws(token);
1758:             return true;
1759:         } catch (SignatureException e) {
1760:             log.error("Invalid JWT signature: {}", e.getMessage());
1761:         } catch (MalformedJwtException e) {
1762:             log.error("Invalid JWT token: {}", e.getMessage());
1763:         } catch (ExpiredJwtException e) {
1764:             log.error("JWT token is expired: {}", e.getMessage());
1765:         } catch (UnsupportedJwtException e) {
1766:             log.error("JWT token is unsupported: {}", e.getMessage());
1767:         } catch (IllegalArgumentException e) {
1768:             log.error("JWT claims string is empty: {}", e.getMessage());
1769:         }
1770:         return false;
1771:     }
1772: 
1773:     public Claims getClaimsFromToken(String token, boolean isRefreshToken) {
1774:         SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
1775:         return Jwts.parserBuilder()
1776:                 .setSigningKey(key)
1777:                 .build()
1778:                 .parseClaimsJws(token)
1779:                 .getBody();
1780:     }
1781: 
1782:     public boolean isTokenExpired(String token, boolean isRefreshToken) {
1783:         try {
1784:             Claims claims = getClaimsFromToken(token, isRefreshToken);
1785:             return claims.getExpiration().before(new Date());
1786:         } catch (ExpiredJwtException e) {
1787:             return true;
1788:         }
1789:     }
1790: 
1791:     public long getAccessTokenExpirationMs() {
1792:         return accessTokenExpirationMs;
1793:     }
1794: 
1795:     public long getRefreshTokenExpirationMs() {
1796:         return refreshTokenExpirationMs;
1797:     }
1798: }
1799: ```
1800: 
1801: ## File: src/main/java/com/bht/ludonova/security/SecurityConfig.java
1802: ```java
1803: package com.bht.ludonova.security;
1804: 
1805: import lombok.RequiredArgsConstructor;
1806: import org.springframework.context.annotation.Bean;
1807: import org.springframework.context.annotation.Configuration;
1808: import org.springframework.security.authentication.AuthenticationManager;
1809: import org.springframework.security.authentication.AuthenticationProvider;
1810: import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
1811: import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
1812: import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
1813: import org.springframework.security.config.annotation.web.builders.HttpSecurity;
1814: import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
1815: import org.springframework.security.config.http.SessionCreationPolicy;
1816: import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
1817: import org.springframework.security.crypto.password.PasswordEncoder;
1818: import org.springframework.security.web.SecurityFilterChain;
1819: import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
1820: import org.springframework.web.cors.CorsConfigurationSource;
1821: 
1822: @Configuration
1823: @EnableWebSecurity
1824: @EnableMethodSecurity
1825: @RequiredArgsConstructor
1826: public class SecurityConfig {
1827: 
1828:     private final CustomUserDetailsService userDetailsService;
1829:     private final JwtAuthenticationFilter jwtAuthFilter;
1830:     private final CorsConfigurationSource corsConfigurationSource;
1831:     private final AuthenticationExceptionHandler authenticationExceptionHandler;
1832: 
1833: //    @Bean
1834: //    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
1835: //        return http
1836: //                .cors(cors -> cors.configurationSource(corsConfigurationSource))
1837: //                .csrf(csrf -> csrf.disable())
1838: //                .authorizeHttpRequests(auth -> auth
1839: //                        // Public endpoints
1840: //                        .requestMatchers(
1841: //                                "/api/auth/login",
1842: //                                "/api/auth/refresh",
1843: //                                "/api/auth/steam/login",
1844: //                                "/api/auth/steam/return"
1845: //                        ).permitAll()
1846: //                        .requestMatchers("/api/test/public").permitAll()
1847: //                        // Protected endpoints
1848: //                        .requestMatchers("/api/games/**").authenticated()
1849: //                        .requestMatchers("/api/user/**").authenticated()
1850: //                        .anyRequest().authenticated()
1851: //                )
1852: //                .sessionManagement(session -> session
1853: //                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
1854: //                )
1855: //                .authenticationProvider(authenticationProvider())
1856: //                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
1857: //                .exceptionHandling(exc -> exc
1858: //                        .authenticationEntryPoint(authenticationExceptionHandler)
1859: //                        .accessDeniedHandler(authenticationExceptionHandler)
1860: //                )
1861: //                .build();
1862: //    }
1863: 
1864:     @Bean
1865:     public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
1866:         return http
1867:                 .cors(cors -> cors.configurationSource(corsConfigurationSource))
1868:                 .csrf(csrf -> csrf.disable())
1869:                 .authorizeHttpRequests(auth -> auth
1870:                         // Public endpoints
1871:                         .requestMatchers(
1872:                                 "/api/auth/login",
1873:                                 "/api/auth/refresh",
1874:                                 "/api/auth/steam/login",
1875:                                 "/api/auth/steam/return",
1876:                                 // Swagger UI and OpenAPI endpoints
1877:                                 "/swagger-ui/**",
1878:                                 "/v3/api-docs/**",
1879:                                 "/swagger-ui.html"
1880:                         ).permitAll()
1881:                         // Protected endpoints
1882:                         .requestMatchers("/api/games/**").authenticated()
1883:                         .requestMatchers("/api/user/**").authenticated()
1884:                         .anyRequest().authenticated()
1885:                 )
1886:                 .sessionManagement(session -> session
1887:                         .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
1888:                 )
1889:                 .authenticationProvider(authenticationProvider())
1890:                 .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
1891:                 .exceptionHandling(exc -> exc
1892:                         .authenticationEntryPoint(authenticationExceptionHandler)
1893:                         .accessDeniedHandler(authenticationExceptionHandler)
1894:                 )
1895:                 .build();
1896:     }
1897: 
1898: 
1899:     @Bean
1900:     public PasswordEncoder passwordEncoder() {
1901:         return new BCryptPasswordEncoder();
1902:     }
1903: 
1904:     @Bean
1905:     public AuthenticationProvider authenticationProvider() {
1906:         DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
1907:         authProvider.setUserDetailsService(userDetailsService);
1908:         authProvider.setPasswordEncoder(passwordEncoder());
1909:         return authProvider;
1910:     }
1911: 
1912:     @Bean
1913:     public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
1914:         return config.getAuthenticationManager();
1915:     }
1916: }
1917: ```
1918: 
1919: ## File: src/main/java/com/bht/ludonova/service/auth/AuthenticationStrategy.java
1920: ```java
1921: package com.bht.ludonova.service.auth;
1922: 
1923: import com.bht.ludonova.dto.auth.AuthenticationResponse;
1924: 
1925: import java.util.Map;
1926: 
1927: public interface AuthenticationStrategy {
1928:     AuthenticationResponse authenticate(Map<String, String> credentials);
1929:     AuthenticationResponse refresh(String refreshToken);
1930: }
1931: ```
1932: 
1933: ## File: src/main/java/com/bht/ludonova/service/auth/BasicAuthenticationStrategy.java
1934: ```java
1935: package com.bht.ludonova.service.auth;
1936: 
1937: import com.bht.ludonova.dto.auth.AuthenticationResponse;
1938: import com.bht.ludonova.dto.auth.TokenResponse;
1939: import com.bht.ludonova.dto.user.UserDTO;
1940: import com.bht.ludonova.exception.AuthenticationException;
1941: import com.bht.ludonova.security.JwtTokenProvider;
1942: import com.bht.ludonova.service.UserService;
1943: import lombok.extern.slf4j.Slf4j;
1944: import org.springframework.security.authentication.AuthenticationManager;
1945: import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
1946: import org.springframework.security.core.Authentication;
1947: import org.springframework.security.core.context.SecurityContextHolder;
1948: import org.springframework.stereotype.Service;
1949: 
1950: import java.util.Map;
1951: 
1952: @Service
1953: @Slf4j
1954: public class BasicAuthenticationStrategy implements AuthenticationStrategy {
1955:     private final AuthenticationManager authenticationManager;
1956:     private final JwtTokenProvider tokenProvider;
1957:     private final UserService userService;
1958: 
1959:     public BasicAuthenticationStrategy(
1960:             AuthenticationManager authenticationManager,
1961:             JwtTokenProvider tokenProvider,
1962:             UserService userService) {
1963:         this.authenticationManager = authenticationManager;
1964:         this.tokenProvider = tokenProvider;
1965:         this.userService = userService;
1966:     }
1967: 
1968:     @Override
1969:     public AuthenticationResponse authenticate(Map<String, String> credentials) {
1970:         try {
1971:             Authentication authentication = authenticationManager.authenticate(
1972:                     new UsernamePasswordAuthenticationToken(
1973:                             credentials.get("username"),
1974:                             credentials.get("password")
1975:                     )
1976:             );
1977:             SecurityContextHolder.getContext().setAuthentication(authentication);
1978: 
1979:             String accessToken = tokenProvider.generateAccessToken(authentication);
1980:             String refreshToken = tokenProvider.generateRefreshToken(authentication.getName());
1981:             UserDTO user = userService.getCurrentUserDTO();
1982: 
1983:             TokenResponse tokens = TokenResponse.of(
1984:                     accessToken,
1985:                     refreshToken,
1986:                     tokenProvider.getAccessTokenExpirationMs()
1987:             );
1988: 
1989:             return new AuthenticationResponse(tokens, user);
1990:         } catch (org.springframework.security.core.AuthenticationException e) {
1991:             log.error("Authentication failed", e);
1992:             throw new AuthenticationException("Invalid username or password");
1993:         }
1994:     }
1995: 
1996:     @Override
1997:     public AuthenticationResponse refresh(String refreshToken) {
1998:         try {
1999:             if (!tokenProvider.validateToken(refreshToken, true)) {
2000:                 throw new AuthenticationException("Invalid refresh token");
2001:             }
2002: 
2003:             String username = tokenProvider.getUsernameFromToken(refreshToken, true);
2004:             UserDTO user = userService.getUserDTOByUsername(username);
2005: 
2006:             String newAccessToken = tokenProvider.generateAccessToken(username);
2007:             String newRefreshToken = tokenProvider.generateRefreshToken(username);
2008: 
2009:             TokenResponse tokens = TokenResponse.of(
2010:                     newAccessToken,
2011:                     newRefreshToken,
2012:                     tokenProvider.getAccessTokenExpirationMs()
2013:             );
2014: 
2015:             return new AuthenticationResponse(tokens, user);
2016:         } catch (Exception e) {
2017:             log.error("Token refresh failed", e);
2018:             throw new AuthenticationException("Failed to refresh token");
2019:         }
2020:     }
2021: }
2022: ```
2023: 
2024: ## File: src/main/java/com/bht/ludonova/service/auth/SteamAuthenticationStrategy.java
2025: ```java
2026: package com.bht.ludonova.service.auth;
2027: 
2028: import com.bht.ludonova.dto.auth.AuthenticationResponse;
2029: import com.bht.ludonova.dto.auth.TokenResponse;
2030: import com.bht.ludonova.dto.user.UserDTO;
2031: import com.bht.ludonova.exception.SteamAuthenticationException;
2032: import com.bht.ludonova.model.SteamUser;
2033: import com.bht.ludonova.model.User;
2034: import com.bht.ludonova.security.JwtTokenProvider;
2035: import com.bht.ludonova.service.SteamService;
2036: import com.bht.ludonova.service.UserService;
2037: import lombok.extern.slf4j.Slf4j;
2038: import org.springframework.stereotype.Service;
2039: 
2040: import java.util.Map;
2041: 
2042: @Service
2043: @Slf4j
2044: public class SteamAuthenticationStrategy implements AuthenticationStrategy {
2045:     private final SteamService steamService;
2046:     private final UserService userService;
2047:     private final JwtTokenProvider tokenProvider;
2048: 
2049:     public SteamAuthenticationStrategy(
2050:             SteamService steamService,
2051:             UserService userService,
2052:             JwtTokenProvider tokenProvider) {
2053:         this.steamService = steamService;
2054:         this.userService = userService;
2055:         this.tokenProvider = tokenProvider;
2056:     }
2057: 
2058:     @Override
2059:     public AuthenticationResponse authenticate(Map<String, String> openIdParams) {
2060:         try {
2061:             log.debug("Starting Steam authentication with params: {}", openIdParams);
2062: 
2063:             if (!steamService.validateSteamResponse(openIdParams)) {
2064:                 log.error("Steam validation failed");
2065:                 throw new SteamAuthenticationException("Invalid Steam response");
2066:             }
2067: 
2068:             log.debug("Steam response validated successfully");
2069:             String steamId = extractSteamId(openIdParams);
2070: 
2071:             if (steamId == null) {
2072:                 log.error("Could not extract Steam ID from params");
2073:                 throw new SteamAuthenticationException("Could not extract Steam ID");
2074:             }
2075: 
2076:             log.debug("Extracted Steam ID: {}", steamId);
2077:             SteamUser steamUser = steamService.fetchUserDetails(steamId);
2078:             log.debug("Fetched Steam user details: {}", steamUser);
2079: 
2080:             User user = userService.getOrCreateSteamUser(steamUser);
2081:             log.debug("Got/Created user: {}", user);
2082: 
2083:             String accessToken = tokenProvider.generateAccessToken(user.getUsername());
2084:             String refreshToken = tokenProvider.generateRefreshToken(user.getUsername());
2085:             UserDTO userDTO = userService.convertToDTO(user);
2086: 
2087:             log.debug("Generated tokens and converted user to DTO");
2088: 
2089:             TokenResponse tokens = TokenResponse.of(
2090:                     accessToken,
2091:                     refreshToken,
2092:                     tokenProvider.getAccessTokenExpirationMs()
2093:             );
2094: 
2095:             return new AuthenticationResponse(tokens, userDTO);
2096:         } catch (Exception e) {
2097:             log.error("Steam authentication failed", e);
2098:             throw new SteamAuthenticationException(e.getMessage());
2099:         }
2100:     }
2101: 
2102:     @Override
2103:     public AuthenticationResponse refresh(String refreshToken) {
2104:         return null; // Steam users use the same refresh mechanism as basic auth
2105:     }
2106: 
2107:     private String extractSteamId(Map<String, String> params) {
2108:         String identity = params.get("openid.claimed_id");
2109:         if (identity != null && identity.matches("https://steamcommunity.com/openid/id/\\d+")) {
2110:             return identity.substring(identity.lastIndexOf("/") + 1);
2111:         }
2112:         return null;
2113:     }
2114: }
2115: ```
2116: 
2117: ## File: src/main/java/com/bht/ludonova/service/AuthenticationService.java
2118: ```java
2119: package com.bht.ludonova.service;
2120: 
2121: import com.bht.ludonova.dto.auth.AuthenticationResponse;
2122: import com.bht.ludonova.exception.AuthenticationException;
2123: import com.bht.ludonova.service.auth.AuthenticationStrategy;
2124: import com.bht.ludonova.service.auth.BasicAuthenticationStrategy;
2125: import com.bht.ludonova.service.auth.SteamAuthenticationStrategy;
2126: import lombok.extern.slf4j.Slf4j;
2127: import org.springframework.stereotype.Service;
2128: 
2129: import java.util.Map;
2130: 
2131: @Service
2132: @Slf4j
2133: public class AuthenticationService {
2134:     private final Map<String, AuthenticationStrategy> authenticationStrategies;
2135: 
2136:     public AuthenticationService(
2137:             BasicAuthenticationStrategy basicAuthStrategy,
2138:             SteamAuthenticationStrategy steamAuthStrategy) {
2139:         this.authenticationStrategies = Map.of(
2140:                 "basic", basicAuthStrategy,
2141:                 "steam", steamAuthStrategy
2142:         );
2143:     }
2144: 
2145:     public AuthenticationResponse authenticate(String strategy, Map<String, String> credentials) {
2146:         AuthenticationStrategy authStrategy = authenticationStrategies.get(strategy);
2147:         if (authStrategy == null) {
2148:             throw new AuthenticationException("Unsupported authentication strategy: " + strategy);
2149:         }
2150: 
2151:         return authStrategy.authenticate(credentials);
2152:     }
2153: 
2154:     public AuthenticationResponse refresh(String refreshToken) {
2155:         // We use the basic strategy for refresh tokens as the mechanism is the same
2156:         return authenticationStrategies.get("basic").refresh(refreshToken);
2157:     }
2158: }
2159: ```
2160: 
2161: ## File: src/main/java/com/bht/ludonova/service/GameInstanceService.java
2162: ```java
2163: package com.bht.ludonova.service;
2164: 
2165: import java.time.LocalDateTime;
2166: import java.util.List;
2167: import java.util.Optional;
2168: 
2169: import org.springframework.stereotype.Service;
2170: import org.springframework.transaction.annotation.Transactional;
2171: 
2172: import lombok.RequiredArgsConstructor;
2173: 
2174: import com.bht.ludonova.model.GameInstance;
2175: import com.bht.ludonova.model.enums.GameStatus;
2176: import com.bht.ludonova.repository.GameInstanceRepository;
2177: 
2178: @Service
2179: @Transactional
2180: @RequiredArgsConstructor
2181: public class GameInstanceService {
2182:     private final GameInstanceRepository gameInstanceRepository;
2183: 
2184:     public GameInstance save(GameInstance gameInstance) {
2185:         if (gameInstance.getStatus() == GameStatus.PLAYING) {
2186:             gameInstance.setLastPlayed(LocalDateTime.now());
2187:         }
2188:         return gameInstanceRepository.save(gameInstance);
2189:     }
2190: 
2191:     public Optional<GameInstance> findById(Long id) {
2192:         return gameInstanceRepository.findById(id);
2193:     }
2194: 
2195:     public List<GameInstance> findByUserId(Long userId) {
2196:         return gameInstanceRepository.findByUserId(userId);
2197:     }
2198: 
2199:     public List<GameInstance> findByUserIdAndStatus(Long userId, GameStatus status) {
2200:         return gameInstanceRepository.findByUserIdAndStatus(userId, status);
2201:     }
2202: 
2203:     public Optional<GameInstance> findByUserIdAndGameId(Long userId, Long gameId) {
2204:         return gameInstanceRepository.findByUserIdAndGameId(userId, gameId);
2205:     }
2206: 
2207:     public boolean existsByUserIdAndGameId(Long userId, Long gameId) {
2208:         return gameInstanceRepository.existsByUserIdAndGameId(userId, gameId);
2209:     }
2210: 
2211:     public void updateStatus(Long id, GameStatus newStatus) {
2212:         findById(id).ifPresent(instance -> {
2213:             instance.setStatus(newStatus);
2214:             if (newStatus == GameStatus.PLAYING) {
2215:                 instance.setLastPlayed(LocalDateTime.now());
2216:             }
2217:             save(instance);
2218:         });
2219:     }
2220: 
2221:     public void deleteById(Long id) {
2222:         gameInstanceRepository.deleteById(id);
2223:     }
2224: }
2225: ```
2226: 
2227: ## File: src/main/java/com/bht/ludonova/service/GameService.java
2228: ```java
2229: package com.bht.ludonova.service;
2230: 
2231: import java.util.List;
2232: import java.util.Optional;
2233: 
2234: import org.springframework.stereotype.Service;
2235: import org.springframework.transaction.annotation.Transactional;
2236: 
2237: import com.bht.ludonova.model.Game;
2238: import com.bht.ludonova.model.enums.GameSource;
2239: import com.bht.ludonova.model.enums.Platform;
2240: import com.bht.ludonova.repository.GameRepository;
2241: 
2242: import lombok.RequiredArgsConstructor;
2243: 
2244: @Service
2245: @Transactional
2246: @RequiredArgsConstructor
2247: public class GameService {
2248:     private final GameRepository gameRepository;
2249: 
2250:     public Game save(Game game) {
2251:         return gameRepository.save(game);
2252:     }
2253: 
2254:     public Optional<Game> findById(Long id) {
2255:         return gameRepository.findById(id);
2256:     }
2257: 
2258:     public List<Game> findAll() {
2259:         return gameRepository.findAll();
2260:     }
2261: 
2262:     public List<Game> findByPlatform(Platform platform) {
2263:         return gameRepository.findByPlatform(platform);
2264:     }
2265: 
2266:     public Optional<Game> findByApiIdAndSource(String apiId, GameSource source) {
2267:         return gameRepository.findByApiIdAndSource(apiId, source);
2268:     }
2269: 
2270:     public void deleteById(Long id) {
2271:         gameRepository.deleteById(id);
2272:     }
2273: }
2274: ```
2275: 
2276: ## File: src/main/java/com/bht/ludonova/service/SteamService.java
2277: ```java
2278: package com.bht.ludonova.service;
2279: 
2280: import com.bht.ludonova.dto.steam.SteamApiResponseDTO;
2281: import com.bht.ludonova.exception.SteamAuthenticationException;
2282: import org.springframework.beans.factory.annotation.Value;
2283: import org.springframework.stereotype.Service;
2284: import org.springframework.web.reactive.function.client.WebClient;
2285: import com.bht.ludonova.model.SteamUser;
2286: import lombok.extern.slf4j.Slf4j;
2287: import java.io.UnsupportedEncodingException;
2288: import java.net.URLEncoder;
2289: import java.nio.charset.StandardCharsets;
2290: import java.util.HashMap;
2291: import java.util.Map;
2292: import java.util.stream.Collectors;
2293: 
2294: @Slf4j
2295: @Service
2296: public class SteamService {
2297:     @Value("${steam.api.key}")
2298:     private String steamApiKey;
2299: 
2300:     private final WebClient steamApiClient;
2301:     private final WebClient openIdClient;
2302: 
2303:     public SteamService() {
2304:         this.steamApiClient = WebClient.builder()
2305:                 .baseUrl("https://api.steampowered.com")
2306:                 .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
2307:                 .build();
2308: 
2309:         this.openIdClient = WebClient.builder()
2310:                 .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
2311:                 .build();
2312:     }
2313: 
2314:     public boolean validateSteamResponse(Map<String, String> params) {
2315:         try {
2316:             log.info("Validating Steam response with params: {}", params);
2317:             String url = "https://steamcommunity.com/openid/login";
2318: 
2319:             // Create a new map with check_authentication mode
2320:             Map<String, String> validationParams = new HashMap<>(params);
2321:             validationParams.put("openid.mode", "check_authentication");
2322: 
2323:             // Convert map to form data
2324:             String formData = validationParams.entrySet().stream()
2325:                     .map(entry -> entry.getKey() + "=" + encodeValue(entry.getValue()))
2326:                     .collect(Collectors.joining("&"));
2327: 
2328:             String responseBody = openIdClient.post()
2329:                     .uri(url)
2330:                     .header("Content-Type", "application/x-www-form-urlencoded")
2331:                     .bodyValue(formData)
2332:                     .retrieve()
2333:                     .bodyToMono(String.class)
2334:                     .block();
2335: 
2336:             log.info("Steam validation response: {}", responseBody);
2337:             return responseBody != null && responseBody.contains("is_valid:true");
2338:         } catch (Exception e) {
2339:             log.error("Error validating Steam response", e);
2340:             return false;
2341:         }
2342:     }
2343: 
2344:     public SteamUser fetchUserDetails(String steamId) {
2345:         String url = "/ISteamUser/GetPlayerSummaries/v2/";
2346: 
2347:         try {
2348:             SteamApiResponseDTO dto = steamApiClient.get()
2349:                     .uri(uriBuilder -> uriBuilder
2350:                             .path(url)
2351:                             .queryParam("key", steamApiKey)
2352:                             .queryParam("steamids", steamId)
2353:                             .build())
2354:                     .retrieve()
2355:                     .bodyToMono(SteamApiResponseDTO.class)
2356:                     .block();
2357: 
2358:             if (dto != null && dto.getResponse() != null && !dto.getResponse().getPlayers().isEmpty()) {
2359:                 SteamApiResponseDTO.Player player = dto.getResponse().getPlayers().get(0);
2360:                 return mapToSteamUser(player);
2361:             }
2362: 
2363:             throw new SteamApiException("Failed to fetch Steam user details");
2364:         } catch (Exception e) {
2365:             log.error("Error fetching Steam user details", e);
2366:             throw new SteamApiException("Failed to fetch Steam user details", e);
2367:         }
2368:     }
2369: 
2370:     private String encodeValue(String value) {
2371:         try {
2372:             return URLEncoder.encode(value, StandardCharsets.UTF_8.toString());
2373:         } catch (UnsupportedEncodingException e) {
2374:             return value;
2375:         }
2376:     }
2377: 
2378:     private SteamUser mapToSteamUser(SteamApiResponseDTO.Player player) {
2379:         SteamUser steamUser = new SteamUser();
2380:         steamUser.setSteamId(player.getSteamId());
2381:         steamUser.setPersonaName(player.getPersonaName());
2382:         steamUser.setProfileUrl(player.getProfileUrl());
2383:         steamUser.setAvatarUrl(player.getAvatarUrl());
2384:         return steamUser;
2385:     }
2386: 
2387:     public static class SteamApiException extends RuntimeException {
2388:         public SteamApiException(String message) {
2389:             super(message);
2390:         }
2391: 
2392:         public SteamApiException(String message, Throwable cause) {
2393:             super(message, cause);
2394:         }
2395:     }
2396: }
2397: ```
2398: 
2399: ## File: src/main/java/com/bht/ludonova/service/UserService.java
2400: ```java
2401: package com.bht.ludonova.service;
2402: 
2403: import com.bht.ludonova.dto.steam.SteamUserDTO;
2404: import com.bht.ludonova.dto.user.UserDTO;
2405: import com.bht.ludonova.dto.user.UserUpdateDTO;
2406: import com.bht.ludonova.exception.AuthenticationException;
2407: import com.bht.ludonova.exception.UnauthorizedException;
2408: import com.bht.ludonova.model.enums.Role;
2409: import org.springframework.security.core.context.SecurityContextHolder;
2410: import org.springframework.security.crypto.password.PasswordEncoder;
2411: import org.springframework.stereotype.Service;
2412: import org.springframework.transaction.annotation.Transactional;
2413: 
2414: import com.bht.ludonova.model.SteamUser;
2415: import com.bht.ludonova.model.User;
2416: import com.bht.ludonova.repository.UserRepository;
2417: 
2418: import java.util.List;
2419: import java.util.UUID;
2420: import java.util.stream.Collectors;
2421: 
2422: @Service
2423: @Transactional
2424: public class UserService {
2425:     private final UserRepository userRepository;
2426:     private final PasswordEncoder passwordEncoder;
2427: 
2428:     public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
2429:         this.userRepository = userRepository;
2430:         this.passwordEncoder = passwordEncoder;
2431:     }
2432: 
2433:     public User getOrCreateSteamUser(SteamUser steamUser) {
2434:         return userRepository.findBySteamUser_SteamId(steamUser.getSteamId())
2435:                 .orElseGet(() -> createSteamUser(steamUser));
2436:     }
2437: 
2438:     private User createSteamUser(SteamUser steamUser) {
2439:         User user = new User();
2440:         user.setUsername("steam_" + steamUser.getSteamId());
2441:         user.setPassword(passwordEncoder.encode(UUID.randomUUID().toString()));
2442:         user.setRole(Role.USER);
2443:         user.setSteamUser(steamUser);
2444:         return userRepository.save(user);
2445:     }
2446: 
2447:     public UserDTO getCurrentUserDTO() {
2448:         String username = SecurityContextHolder.getContext().getAuthentication().getName();
2449:         return userRepository.findByUsername(username)
2450:                 .map(this::convertToDTO)
2451:                 .orElseThrow(() -> new AuthenticationException("User not found"));
2452:     }
2453: 
2454:     public UserDTO getUserDTOByUsername(String username) {
2455:         return userRepository.findByUsername(username)
2456:                 .map(this::convertToDTO)
2457:                 .orElseThrow(() -> new AuthenticationException("User not found: " + username));
2458:     }
2459: 
2460:     public UserDTO convertToDTO(User user) {
2461:         UserDTO dto = new UserDTO();
2462:         dto.setId(user.getId());
2463:         dto.setUsername(user.getUsername());
2464:         dto.setEmail(user.getEmail());
2465:         dto.setRole(user.getRole());
2466: 
2467:         if (user.getSteamUser() != null) {
2468:             SteamUserDTO steamUserDTO = new SteamUserDTO();
2469:             steamUserDTO.setSteamId(user.getSteamUser().getSteamId());
2470:             steamUserDTO.setPersonaName(user.getSteamUser().getPersonaName());
2471:             steamUserDTO.setProfileUrl(user.getSteamUser().getProfileUrl());
2472:             steamUserDTO.setAvatarUrl(user.getSteamUser().getAvatarUrl());
2473:             dto.setSteamUser(steamUserDTO);
2474:         }
2475: 
2476:         return dto;
2477:     }
2478: 
2479:     public List<UserDTO> getAllUsers() {
2480:         checkAdminAccess();
2481:         return userRepository.findAll().stream()
2482:                 .map(this::convertToDTO)
2483:                 .collect(Collectors.toList());
2484:     }
2485: 
2486:     public UserDTO getUserById(Long id) {
2487:         checkAdminAccess();
2488:         return userRepository.findById(id)
2489:                 .map(this::convertToDTO)
2490:                 .orElseThrow(() -> new AuthenticationException("User not found: " + id));
2491:     }
2492: 
2493:     public UserDTO updateUser(Long id, UserUpdateDTO updateDTO) {
2494:         User currentUser = getCurrentUser();
2495:         User userToUpdate = userRepository.findById(id)
2496:                 .orElseThrow(() -> new AuthenticationException("User not found: " + id));
2497: 
2498:         if (!currentUser.getRole().equals(Role.ADMIN) && !currentUser.getId().equals(id)) {
2499:             throw new UnauthorizedException("You can only update your own profile");
2500:         }
2501: 
2502:         if (updateDTO.getRole() != null) {
2503:             if (!currentUser.getRole().equals(Role.ADMIN)) {
2504:                 throw new UnauthorizedException("Only admins can update roles");
2505:             }
2506:             userToUpdate.setRole(updateDTO.getRole());
2507:         }
2508: 
2509:         if (updateDTO.getEmail() != null) {
2510:             userToUpdate.setEmail(updateDTO.getEmail());
2511:         }
2512: 
2513:         return convertToDTO(userRepository.save(userToUpdate));
2514:     }
2515: 
2516:     public void deleteUser(Long id) {
2517:         checkAdminAccess();
2518:         userRepository.deleteById(id);
2519:     }
2520: 
2521:     private User getCurrentUser() {
2522:         String username = SecurityContextHolder.getContext().getAuthentication().getName();
2523:         return userRepository.findByUsername(username)
2524:                 .orElseThrow(() -> new AuthenticationException("User not found"));
2525:     }
2526: 
2527:     private void checkAdminAccess() {
2528:         User currentUser = getCurrentUser();
2529:         if (!currentUser.getRole().equals(Role.ADMIN)) {
2530:             throw new UnauthorizedException("Admin access required");
2531:         }
2532:     }
2533: }
2534: ```
2535: 
2536: ## File: src/main/java/com/bht/ludonova/LudoNovaApplication.java
2537: ```java
2538: package com.bht.ludonova;
2539: 
2540: import org.springframework.boot.SpringApplication;
2541: import org.springframework.boot.autoconfigure.SpringBootApplication;
2542: import org.springframework.boot.autoconfigure.domain.EntityScan;
2543: import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
2544: 
2545: @SpringBootApplication
2546: @EntityScan("com.bht.ludonova.model")
2547: @EnableJpaRepositories("com.bht.ludonova.repository")
2548: public class LudoNovaApplication {
2549:     public static void main(String[] args) {
2550:         SpringApplication.run(LudoNovaApplication.class, args);
2551:     }
2552: }
2553: ```
2554: 
2555: ## File: src/main/resources/db/migration/V1__create_base_schema.sql
2556: ```sql
2557: -- Steam Users table first (because it's referenced by users)
2558: CREATE TABLE IF NOT EXISTS steam_users (
2559:     steam_id VARCHAR(255) PRIMARY KEY,
2560:     persona_name VARCHAR(255),
2561:     profile_url VARCHAR(255),
2562:     avatar_url VARCHAR(255)
2563: );
2564: 
2565: -- Then Users table (with the foreign key)
2566: CREATE TABLE IF NOT EXISTS users (
2567:     id BIGSERIAL PRIMARY KEY,
2568:     username VARCHAR(255) NOT NULL UNIQUE,
2569:     email VARCHAR(255),
2570:     password VARCHAR(255) NOT NULL,
2571:     role VARCHAR(50) NOT NULL DEFAULT 'USER',
2572:     steam_id VARCHAR(255) REFERENCES steam_users(steam_id),
2573:     created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
2574: );
2575: 
2576: -- Games and related tables
2577: CREATE TABLE games (
2578:                        id BIGSERIAL PRIMARY KEY,
2579:                        title VARCHAR(255) NOT NULL,
2580:                        platform VARCHAR(50) NOT NULL,
2581:                        api_id VARCHAR(100),
2582:                        release_date DATE,
2583:                        source VARCHAR(20) NOT NULL,
2584:                        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
2585: );
2586: 
2587: CREATE TABLE game_genres (
2588:                              game_id BIGINT REFERENCES games(id) ON DELETE CASCADE,
2589:                              genre VARCHAR(50),
2590:                              PRIMARY KEY (game_id, genre)
2591: );
2592: 
2593: CREATE TABLE game_instances (
2594:                                 id BIGSERIAL PRIMARY KEY,
2595:                                 user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
2596:                                 game_id BIGINT REFERENCES games(id) ON DELETE CASCADE,
2597:                                 status VARCHAR(20) NOT NULL,
2598:                                 progress_percentage INTEGER CHECK (progress_percentage BETWEEN 0 AND 100),
2599:                                 play_time INTEGER,
2600:                                 last_played TIMESTAMP,
2601:                                 notes TEXT,
2602:                                 created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
2603:                                 updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
2604:                                 UNIQUE(user_id, game_id)
2605: );
2606: 
2607: -- Reviews table
2608: CREATE TABLE reviews (
2609:                          id BIGSERIAL PRIMARY KEY,
2610:                          user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
2611:                          game_id BIGINT REFERENCES games(id) ON DELETE CASCADE,
2612:                          rating INTEGER CHECK (rating BETWEEN 1 AND 5),
2613:                          review_text TEXT,
2614:                          created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
2615:                          updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
2616:                          UNIQUE(user_id, game_id)
2617: );
2618: ```
2619: 
2620: ## File: src/main/resources/application.properties
2621: ```
2622: # Server Configuration
2623: server.port=8080
2624: 
2625: # PostgreSQL Database Configuration
2626: spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
2627: spring.datasource.username=postgres
2628: spring.datasource.password=postgres
2629: 
2630: # JPA/Hibernate Configuration
2631: spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
2632: spring.jpa.hibernate.ddl-auto=validate
2633: spring.jpa.show-sql=true
2634: spring.jpa.properties.hibernate.format_sql=true
2635: 
2636: # Flyway Configuration
2637: spring.flyway.enabled=true
2638: spring.flyway.baseline-on-migrate=true
2639: spring.flyway.clean-disabled=false
2640: spring.flyway.locations=classpath:db/migration
2641: 
2642: # Enable SQL initialization
2643: spring.sql.init.mode=always
2644: 
2645: # JWT Configuration
2646: jwt.secret=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
2647: jwt.refresh-secret=7338782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E
2648: 
2649: # Token expiration times (in milliseconds)
2650: # Access token: 1 hour = 3600000 ms
2651: jwt.expiration=3600000
2652: # Refresh token: 30 days = 2592000000 ms
2653: jwt.refresh-expiration=2592000000
2654: 
2655: # CORS Configuration
2656: #spring.web.cors.allowed-origins=http://localhost:3000
2657: #spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
2658: #spring.web.cors.allowed-headers=*
2659: #spring.web.cors.allow-credentials=true
2660: 
2661: # CORS Configuration
2662: cors.allowed-origins=http://localhost:3000
2663: 
2664: # Logging Configuration
2665: logging.level.com.bht.ludonova=DEBUG
2666: logging.level.org.hibernate.SQL=DEBUG
2667: logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
2668: 
2669: # Steam Configuration
2670: steam.api.key=${STEAM_API_KEY}
2671: steam.return.url=${STEAM_RETURN_URL:http://localhost:3000/auth/steam/callback}
2672: steam.realm.url=${STEAM_REALM_URL:http://localhost:3000}
2673: 
2674: # Swagger UI custom path
2675: springdoc.swagger-ui.path=/swagger-ui.html
2676: # Enable or disable Swagger UI
2677: springdoc.swagger-ui.enabled=true
2678: # Sort APIs alphabetically
2679: springdoc.swagger-ui.operationsSorter=alpha
2680: ```
2681: 
2682: ## File: .env.example
2683: ```
2684: # Steam Configuration
2685: STEAM_API_KEY=your_steam_api_key_here
2686: STEAM_RETURN_URL=http://localhost:3000/auth/steam/callback
2687: ```
2688: 
2689: ## File: .gitignore
2690: ```
2691: HELP.md
2692: target/
2693: !.mvn/wrapper/maven-wrapper.jar
2694: !**/src/main/**/target/
2695: !**/src/test/**/target/
2696: 
2697: ### STS ###
2698: .apt_generated
2699: .classpath
2700: .factorypath
2701: .project
2702: .settings
2703: .springBeans
2704: .sts4-cache
2705: 
2706: ### IntelliJ IDEA ###
2707: .idea
2708: *.iws
2709: *.iml
2710: *.ipr
2711: 
2712: ### NetBeans ###
2713: /nbproject/private/
2714: /nbbuild/
2715: /dist/
2716: /nbdist/
2717: /.nb-gradle/
2718: build/
2719: !**/src/main/**/build/
2720: !**/src/test/**/build/
2721: 
2722: ### VS Code ###
2723: .vscode/
2724: 
2725: ### Environment Files ###
2726: .env
2727: application-local.properties
2728: application-dev.properties
2729: application-prod.properties
2730: 
2731: ### Logs ###
2732: *.log
2733: logs/
2734: log/
2735: 
2736: ### Docker ###
2737: docker-compose.override.yml
2738: 
2739: ### OS generated files ###
2740: .DS_Store
2741: .DS_Store?
2742: ._*
2743: .Spotlight-V100
2744: .Trashes
2745: ehthumbs.db
2746: Thumbs.db
2747: 
2748: ### Java ###
2749: # Compiled class file
2750: *.class
2751: 
2752: # Package Files #
2753: *.jar
2754: *.war
2755: *.nar
2756: *.ear
2757: *.zip
2758: *.tar.gz
2759: *.rar
2760: 
2761: # virtual machine crash logs
2762: hs_err_pid*
2763: replay_pid*
2764: ```
2765: 
2766: ## File: backend-overview.md
2767: ```markdown
2768: # LudoNova Backend Overview
2769: 
2770: The LudoNova backend is a robust and scalable **Spring Boot** application that powers the game backlog management system. It is designed with a focus on security, maintainability, and performance, ensuring a seamless experience for both developers and users.
2771: 
2772: ## Understanding Spring and Spring Boot
2773: 
2774: Before diving into the architecture and components of the LudoNova backend, it's essential to understand the foundational frameworks it leverages: **Spring** and **Spring Boot**.
2775: 
2776: ### What is Spring?
2777: 
2778: **Spring** is a comprehensive framework for building Java applications. It provides a wide range of features, including:
2779: 
2780: - **Dependency Injection (DI):** Allows for loose coupling of components by managing their dependencies.
2781: - **Aspect-Oriented Programming (AOP):** Enables separation of cross-cutting concerns like logging and security.
2782: - **Data Access:** Simplifies interactions with databases through modules like Spring JDBC and Spring Data.
2783: - **Transaction Management:** Provides declarative transaction management for consistent data operations.
2784: - **Model-View-Controller (MVC) Framework:** Facilitates the creation of web applications with clear separation between the model, view, and controller layers.
2785: 
2786: However, setting up a Spring application often involves extensive configuration, which can be time-consuming and error-prone.
2787: 
2788: ### What is Spring Boot?
2789: 
2790: **Spring Boot** builds upon the Spring framework to simplify the development process. It offers:
2791: 
2792: - **Auto-Configuration:** Automatically configures Spring components based on the dependencies present in the project.
2793: - **Starter POMs:** Pre-configured Maven or Gradle dependencies that simplify dependency management.
2794: - **Embedded Servers:** Allows running applications with embedded servers like Tomcat or Jetty without the need for external deployment.
2795: - **Production-Ready Features:** Includes metrics, health checks, and externalized configuration to prepare applications for production environments.
2796: 
2797: In essence, Spring Boot reduces the boilerplate configuration, enabling developers to focus more on business logic rather than setup.
2798: 
2799: ## Architecture
2800: 
2801: The backend follows a **layered architecture**, a common design pattern in Spring Boot applications that separates concerns to enhance modularity and ease of maintenance. This structure aligns with Spring's philosophy of separation of concerns and facilitates scalability and testability. The primary layers include:
2802: 
2803: - **Controller Layer:** Handles incoming HTTP requests and maps them to appropriate services.
2804:   
2805:   - **Why It's Separate:** Isolating controllers ensures that request handling logic is decoupled from business logic, making the system more modular and easier to manage.
2806: 
2807: - **Service Layer:** Contains the business logic and processes data between the controller and repository layers.
2808:   
2809:   - **Role in Spring Boot:** Services are annotated with `@Service`, a specialization of `@Component`, which allows Spring to detect and manage them as beans. This layer orchestrates operations, enforces business rules, and acts as an intermediary between controllers and repositories.
2810: 
2811: - **Repository Layer:** Manages data persistence and interacts with the PostgreSQL database using JPA/Hibernate.
2812:   
2813:   - **Integration with Spring Data:** Repositories are typically interfaces annotated with `@Repository`. Spring Data JPA provides implementations at runtime, abstracting the data access layer and enabling CRUD operations without boilerplate code.
2814: 
2815: ### How These Layers Work Together
2816: 
2817: 1. **Request Flow:**
2818:    - A client sends an HTTP request to the application.
2819:    - The **Controller** receives the request and delegates processing to the **Service** layer.
2820:    - The **Service** contains the business logic and interacts with the **Repository** to perform CRUD operations.
2821:    - The **Repository** communicates with the PostgreSQL database to fetch or persist data.
2822:    - The **Service** processes the data and returns the result to the **Controller**.
2823:    - The **Controller** sends the appropriate HTTP response back to the client.
2824: 
2825: 2. **Benefits of Layered Architecture:**
2826:    - **Modularity:** Each layer has a distinct responsibility, making the codebase easier to navigate and maintain.
2827:    - **Testability:** Layers can be tested independently, facilitating unit and integration testing.
2828:    - **Scalability:** Allows for individual layers to be scaled or modified without affecting others.
2829:    - **Maintainability:** Enhances code readability and simplifies the addition of new features.
2830: 
2831: ## Authentication and Security
2832: 
2833: Security is a paramount concern in the LudoNova backend. Leveraging Spring Boot's robust security features, the application employs a JWT (JSON Web Token) based authentication system to ensure secure and stateless user sessions.
2834: 
2835: ### Understanding Spring Security
2836: 
2837: **Spring Security** is a powerful and highly customizable authentication and access-control framework. It integrates seamlessly with Spring Boot applications, providing:
2838: 
2839: - **Authentication:** Verifies the identity of users.
2840: - **Authorization:** Controls access to resources based on user roles and permissions.
2841: - **Protection Against Common Vulnerabilities:** Guards against threats like CSRF, XSS, and session fixation.
2842: 
2843: ### Key Components:
2844: 
2845: - **JwtTokenProvider:** Generates, validates, and parses JWT tokens. It uses HMAC-SHA for token signing with a configurable secret key and expiration time.
2846:   
2847:   ```java
2848:   public String generateToken(String username) { /* ... */ }
2849:   public String getUsernameFromJWT(String token) { /* ... */ }
2850:   public boolean validateToken(String authToken) { /* ... */ }
2851:   ```
2852:   
2853:   - **Role in Spring Security:** Acts as a utility for managing JWT operations, ensuring tokens are securely created and validated.
2854: 
2855: - **JwtAuthenticationFilter:** Intercepts incoming requests to extract and validate JWT tokens. If valid, it sets the authentication in the Spring Security context.
2856:   
2857:   - **Integration with Spring Boot:** Extends `OncePerRequestFilter` to ensure that each request is processed once. It leverages the `JwtTokenProvider` to manage token validation and sets the security context accordingly.
2858: 
2859: - **SecurityConfig:** Configures Spring Security, defining public and protected endpoints, setting up the authentication provider, and applying security filters.
2860:   
2861:   - **Configuration Highlights:**
2862:     - **CORS:** Configures Cross-Origin Resource Sharing to allow or restrict requests from specific origins.
2863:     - **CSRF:** Disables Cross-Site Request Forgery protection for stateless APIs.
2864:     - **Session Management:** Configures the application to be stateless, relying solely on JWT tokens without maintaining server-side sessions.
2865:     - **Authentication Provider:** Sets up how authentication is handled, typically using a `DaoAuthenticationProvider` that retrieves user details from a data source.
2866: 
2867: ### Security Features:
2868: 
2869: - **Stateless Authentication:** No server-side sessions are maintained. All authentication is handled via JWT tokens sent with each request.
2870:   
2871:   - **Advantages:** Enhances scalability as the server doesn't need to store session information. It also simplifies horizontal scaling and load balancing.
2872: 
2873: - **Password Encryption:** User passwords are hashed using BCrypt to ensure they are not stored in plain text.
2874:   
2875:   - **Security Best Practice:** Hashing passwords protects user credentials even if the database is compromised.
2876: 
2877: - **CORS Configuration:** Restricts backend access to authorized frontend origins and specific HTTP methods.
2878:   
2879:   - **Purpose:** Prevents unauthorized domains from making requests to the backend, mitigating potential cross-origin attacks.
2880: 
2881: ## API Endpoints
2882: 
2883: The backend exposes a set of RESTful API endpoints to manage user authentication, games, and user profiles. Leveraging Spring Boot's **Spring MVC** framework, these endpoints are defined using annotations that map HTTP requests to handler methods.
2884: 
2885: ### Examples:
2886: 
2887: - **Authentication:**
2888:   - `POST /api/auth/login`: Authenticates a user and returns a JWT token.
2889:   - `POST /api/auth/register`: Registers a new user.
2890: 
2891: - **Games Management:**
2892:   - `GET /api/games`: Retrieves a list of games.
2893:   - `POST /api/games`: Adds a new game to the backlog.
2894:   - `PUT /api/games/{id}`: Updates game details.
2895:   - `DELETE /api/games/{id}`: Removes a game from the backlog.
2896: 
2897: - **User Profiles:**
2898:   - `GET /api/user`: Retrieves the authenticated user's profile information.
2899: 
2900: ### Leveraging Spring MVC:
2901: 
2902: - **Controllers:** Annotated with `@RestController`, these classes handle HTTP requests and return responses.
2903: - **Request Mappings:** Methods within controllers use annotations like `@GetMapping`, `@PostMapping`, etc., to map specific HTTP methods and URLs to handler functions.
2904: - **Response Entities:** Facilitates building HTTP responses with appropriate status codes and headers.
2905: 
2906: ## Database Management
2907: 
2908: The application uses **PostgreSQL** as its primary database, with the schema managed by **JPA/Hibernate**. Spring Boot's integration with Spring Data JPA simplifies database interactions, allowing developers to work with databases using Java objects rather than writing SQL queries.
2909: 
2910: ### Benefits of Using JPA/Hibernate:
2911: 
2912: - **Object-Relational Mapping (ORM):** Translates Java objects to database tables, enabling developers to interact with the database using familiar Java constructs.
2913: - **Schema Generation:** Automatically creates and updates the database schema based on entity classes, reducing manual configuration.
2914: - **Query Abstraction:** Provides a high-level API for querying the database, such as JPQL or the Criteria API, abstracting the underlying SQL.
2915: 
2916: ### Configuration:
2917: 
2918: ```properties
2919: # application.properties
2920: spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
2921: spring.datasource.username=yourusername
2922: spring.datasource.password=yourpassword
2923: spring.jpa.hibernate.ddl-auto=update
2924: ```
2925: 
2926: - **spring.datasource.url:** Specifies the JDBC URL for the PostgreSQL database.
2927: - **spring.jpa.hibernate.ddl-auto:** Determines how Hibernate handles schema generation. The `update` value ensures that the schema is automatically updated based on entity changes.
2928: 
2929: ## Testing and Deployment
2930: 
2931: ### Testing:
2932: 
2933: Comprehensive tests are implemented to ensure the reliability and correctness of the backend functionalities. Leveraging **Spring Boot's testing framework**, developers can write unit and integration tests with ease.
2934: 
2935: - **Running Tests:**
2936:   
2937:   ```bash
2938:   ./mvnw test
2939:   ```
2940:   
2941:   - **Spring Boot Test Annotations:** Annotations like `@SpringBootTest` facilitate loading the application context and testing components in an integrated environment.
2942:   
2943: - **Benefits:**
2944:   - **Continuous Integration:** Ensures that new changes do not break existing functionalities.
2945:   - **Quality Assurance:** Maintains high code quality and reliability.
2946: 
2947: ### Deployment:
2948: 
2949: The backend can be containerized using **Docker** and managed with **Docker Compose**. This facilitates consistent environments across development, testing, and production.
2950: 
2951: - **Containerization with Docker:**
2952:   
2953:   ```bash
2954:   docker-compose up -d
2955:   ```
2956:   
2957:   - **Advantages:**
2958:     - **Isolation:** Ensures that the application runs in a consistent environment, eliminating "it works on my machine" issues.
2959:     - **Scalability:** Simplifies scaling services horizontally.
2960:     - **Portability:** Enables easy deployment across different environments and cloud platforms.
2961: 
2962: ### Prerequisites:
2963: 
2964: - **Java 17+:** Required to run the Spring Boot application.
2965: - **Maven:** For building and managing dependencies.
2966: - **Docker and Docker Compose:** For containerization and deployment.
2967: 
2968: ## Integration with Frontend
2969: 
2970: The backend seamlessly integrates with the **React/Next.js** frontend of the LudoNova application. Authentication tokens are managed on the frontend and included in API requests to secure endpoints.
2971: 
2972: ### API Client:
2973: 
2974: A configured Axios instance is used on the frontend to handle API requests, automatically attaching JWT tokens and handling authentication errors.
2975: 
2976: ```javascript
2977: const api = axios.create({
2978:   baseURL: process.env.NEXT_PUBLIC_API_URL,
2979:   headers: {
2980:     'Content-Type': 'application/json',
2981:   },
2982: });
2983: ```
2984: 
2985: - **Interceptors:** Axios interceptors can be set up to inject JWT tokens into request headers and handle responses globally, such as redirecting to the login page on a `401 Unauthorized` response.
2986: 
2987: ## Conclusion
2988: 
2989: The LudoNova backend is meticulously crafted using **Spring Boot** to provide a secure, efficient, and scalable foundation for the game backlog management system. Its thoughtful layered architecture and robust security measures ensure a reliable service for users, while Spring Boot's auto-configuration and integration capabilities facilitate ease of development and maintenance. Understanding how Spring Boot orchestrates its components and leverages frameworks like Spring MVC and Spring Data JPA empowers developers to effectively manage and extend the backend functionalities.
2990: 
2991: ```
2992: ```
2993: 
2994: ## File: docker-compose.yml
2995: ```yaml
2996: version: '3.8'
2997: 
2998: services:
2999:   postgres:
3000:     image: postgres:16
3001:     container_name: ludonova_db
3002:     environment:
3003:       POSTGRES_DB: ludonova
3004:       POSTGRES_USER: postgres
3005:       POSTGRES_PASSWORD: postgres
3006:     ports:
3007:       - "5432:5432"
3008:     volumes:
3009:       - postgres_data:/var/lib/postgresql/data
3010: 
3011: volumes:
3012:   postgres_data:
3013: ```
3014: 
3015: ## File: ludonova-backend-overview.xml
3016: ```xml
3017: This file is a merged representation of the entire codebase, combining all repository files into a single document.
3018: Generated by Repomix on: 2024-11-17T17:49:58.136Z
3019: 
3020: <file_summary>
3021: This section contains a summary of this file.
3022: 
3023: <purpose>
3024: This file contains a packed representation of the entire repository's contents.
3025: It is designed to be easily consumable by AI systems for analysis, code review,
3026: or other automated processes.
3027: </purpose>
3028: 
3029: <file_format>
3030: The content is organized as follows:
3031: 1. This summary section
3032: 2. Repository information
3033: 3. Repository structure
3034: 4. Repository files, each consisting of:
3035:   - File path as an attribute
3036:   - Full contents of the file
3037: </file_format>
3038: 
3039: <usage_guidelines>
3040: - This file should be treated as read-only. Any changes should be made to the
3041:   original repository files, not this packed version.
3042: - When processing this file, use the file path to distinguish
3043:   between different files in the repository.
3044: - Be aware that this file may contain sensitive information. Handle it with
3045:   the same level of security as you would the original repository.
3046: </usage_guidelines>
3047: 
3048: <notes>
3049: - Some files may have been excluded based on .gitignore rules and Repomix's
3050:   configuration.
3051: - Binary files are not included in this packed representation. Please refer to
3052:   the Repository Structure section for a complete list of file paths, including
3053:   binary files.
3054: </notes>
3055: 
3056: <additional_info>
3057: 
3058: For more information about Repomix, visit: https://github.com/yamadashy/repomix
3059: </additional_info>
3060: 
3061: </file_summary>
3062: 
3063: <repository_structure>
3064: src/
3065:   main/
3066:     java/
3067:       com/
3068:         bht/
3069:           ludonova/
3070:             config/
3071:               DataInitializer.java
3072:               WebConfig.java
3073:             controller/
3074:               AuthController.java
3075:               GameController.java
3076:               SteamAuthController.java
3077:               TestController.java
3078:               UserController.java
3079:             dto/
3080:               auth/
3081:                 AuthenticationResponse.java
3082:                 LoginRequest.java
3083:                 RefreshTokenRequest.java
3084:                 TokenResponse.java
3085:               steam/
3086:                 SteamApiResponseDTO.java
3087:                 SteamAuthRequest.java
3088:                 SteamUserDTO.java
3089:               user/
3090:                 UserDTO.java
3091:               ErrorResponse.java
3092:             exception/
3093:               AuthenticationException.java
3094:               GlobalExceptionHandler.java
3095:               LudoNovaException.java
3096:               SteamAuthenticationException.java
3097:             model/
3098:               Game.java
3099:               SteamUser.java
3100:               User.java
3101:             repository/
3102:               GameRepository.java
3103:               UserRepository.java
3104:             security/
3105:               AuthenticationExceptionHandler.java
3106:               CustomUserDetailsService.java
3107:               JwtAuthenticationFilter.java
3108:               JwtTokenProvider.java
3109:               SecurityConfig.java
3110:             service/
3111:               auth/
3112:                 AuthenticationStrategy.java
3113:                 BasicAuthenticationStrategy.java
3114:                 SteamAuthenticationStrategy.java
3115:               AuthenticationService.java
3116:               SteamService.java
3117:               UserService.java
3118:             LudoNovaApplication.java
3119:     resources/
3120:       application.properties
3121: .env.example
3122: .gitignore
3123: backend-overview.md
3124: docker-compose.yml
3125: ludonova-backend-overview.xml
3126: pom.xml
3127: README.md
3128: setup.sh
3129: </repository_structure>
3130: 
3131: <repository_files>
3132: This section contains the contents of the repository's files.
3133: 
3134: <file path="src/main/java/com/bht/ludonova/config/DataInitializer.java">
3135: package com.bht.ludonova.config;
3136: 
3137: import com.bht.ludonova.model.User;
3138: import com.bht.ludonova.repository.UserRepository;
3139: import org.springframework.boot.CommandLineRunner;
3140: import org.springframework.context.annotation.Bean;
3141: import org.springframework.context.annotation.Configuration;
3142: import org.springframework.security.crypto.password.PasswordEncoder;
3143: 
3144: @Configuration
3145: public class DataInitializer {
3146: 
3147:     @Bean
3148:     CommandLineRunner initDatabase(UserRepository userRepository, PasswordEncoder passwordEncoder) {
3149:         return args -> {
3150:             // Create test user if it doesn't exist
3151:             if (userRepository.findByUsername("test").isEmpty()) {
3152:                 User testUser = User.builder()
3153:                         .username("test")
3154:                         .password(passwordEncoder.encode("test123"))
3155:                         .email("test@example.com")
3156:                         .build();
3157:                 userRepository.save(testUser);
3158:                 System.out.println("Test user created successfully");
3159:             }
3160:         };
3161:     }
3162: }
3163: </file>
3164: 
3165: <file path="src/main/java/com/bht/ludonova/config/WebConfig.java">
3166: package com.bht.ludonova.config;
3167: 
3168: import org.springframework.beans.factory.annotation.Value;
3169: import org.springframework.context.annotation.Bean;
3170: import org.springframework.context.annotation.Configuration;
3171: import org.springframework.web.cors.CorsConfiguration;
3172: import org.springframework.web.cors.CorsConfigurationSource;
3173: import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
3174: 
3175: import java.util.List;
3176: 
3177: @Configuration
3178: public class WebConfig {
3179: 
3180:     @Value("${cors.allowed-origins}")
3181:     private List<String> allowedOrigins;
3182: 
3183:     @Bean
3184:     public CorsConfigurationSource corsConfigurationSource() {
3185:         CorsConfiguration configuration = new CorsConfiguration();
3186:         configuration.setAllowedOrigins(allowedOrigins);
3187:         configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
3188:         configuration.setAllowedHeaders(List.of(
3189:                 "Authorization",
3190:                 "Content-Type",
3191:                 "X-Requested-With",
3192:                 "Accept",
3193:                 "Origin",
3194:                 "Access-Control-Request-Method",
3195:                 "Access-Control-Request-Headers"
3196:         ));
3197:         configuration.setExposedHeaders(List.of(
3198:                 "Access-Control-Allow-Origin",
3199:                 "Access-Control-Allow-Credentials"
3200:         ));
3201:         configuration.setAllowCredentials(true);
3202:         configuration.setMaxAge(3600L);
3203: 
3204:         UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
3205:         source.registerCorsConfiguration("/api/**", configuration);
3206:         return source;
3207:     }
3208: }
3209: </file>
3210: 
3211: <file path="src/main/java/com/bht/ludonova/controller/AuthController.java">
3212: package com.bht.ludonova.controller;
3213: 
3214: import com.bht.ludonova.dto.auth.AuthenticationResponse;
3215: import com.bht.ludonova.dto.auth.RefreshTokenRequest;
3216: import com.bht.ludonova.dto.auth.LoginRequest;
3217: import com.bht.ludonova.service.AuthenticationService;
3218: import jakarta.validation.Valid;
3219: import lombok.extern.slf4j.Slf4j;
3220: import org.springframework.http.ResponseEntity;
3221: import org.springframework.web.bind.annotation.*;
3222: 
3223: import java.util.Map;
3224: 
3225: @RestController
3226: @RequestMapping("/api/auth")
3227: @Slf4j
3228: public class AuthController {
3229:     private final AuthenticationService authService;
3230: 
3231:     public AuthController(AuthenticationService authService) {
3232:         this.authService = authService;
3233:     }
3234: 
3235:     @PostMapping("/login")
3236:     public ResponseEntity<AuthenticationResponse> login(@Valid @RequestBody LoginRequest loginRequest) {
3237:         Map<String, String> credentials = Map.of(
3238:                 "username", loginRequest.getUsername(),
3239:                 "password", loginRequest.getPassword()
3240:         );
3241: 
3242:         AuthenticationResponse response = authService.authenticate("basic", credentials);
3243:         return ResponseEntity.ok(response);
3244:     }
3245: 
3246:     @PostMapping("/refresh")
3247:     public ResponseEntity<AuthenticationResponse> refresh(@Valid @RequestBody RefreshTokenRequest request) {
3248:         AuthenticationResponse response = authService.refresh(request.getRefreshToken());
3249:         return ResponseEntity.ok(response);
3250:     }
3251: }
3252: </file>
3253: 
3254: <file path="src/main/java/com/bht/ludonova/controller/GameController.java">
3255: package com.bht.ludonova.controller;
3256: 
3257: import com.bht.ludonova.model.Game;
3258: import com.bht.ludonova.repository.GameRepository;
3259: import org.springframework.beans.factory.annotation.Autowired;
3260: import org.springframework.http.ResponseEntity;
3261: import org.springframework.security.core.annotation.AuthenticationPrincipal;
3262: import org.springframework.security.core.userdetails.UserDetails;
3263: import org.springframework.web.bind.annotation.*;
3264: 
3265: import java.util.List;
3266: 
3267: @RestController
3268: @RequestMapping("/api/games")
3269: public class GameController {
3270: 
3271:     @Autowired
3272:     private GameRepository gameRepository;
3273: 
3274:     @GetMapping
3275:     public ResponseEntity<List<Game>> getGames(@AuthenticationPrincipal UserDetails userDetails) {
3276:         // For now, return an empty list rather than null
3277:         return ResponseEntity.ok(List.of());
3278:     }
3279: 
3280:     @GetMapping("/{id}")
3281:     public ResponseEntity<Game> getGame(@PathVariable Long id) {
3282:         return gameRepository.findById(id)
3283:                 .map(ResponseEntity::ok)
3284:                 .orElse(ResponseEntity.notFound().build());
3285:     }
3286: }
3287: </file>
3288: 
3289: <file path="src/main/java/com/bht/ludonova/controller/SteamAuthController.java">
3290: package com.bht.ludonova.controller;
3291: 
3292: import com.bht.ludonova.dto.auth.AuthenticationResponse;
3293: import com.bht.ludonova.exception.SteamAuthenticationException;
3294: import com.bht.ludonova.service.AuthenticationService;
3295: import lombok.extern.slf4j.Slf4j;
3296: import org.springframework.beans.factory.annotation.Value;
3297: import org.springframework.http.ResponseEntity;
3298: import org.springframework.web.bind.annotation.GetMapping;
3299: import org.springframework.web.bind.annotation.RequestMapping;
3300: import org.springframework.web.bind.annotation.RequestParam;
3301: import org.springframework.web.bind.annotation.RestController;
3302: 
3303: import java.net.URLEncoder;
3304: import java.nio.charset.StandardCharsets;
3305: import java.util.Map;
3306: 
3307: @RestController
3308: @RequestMapping("/api/auth/steam")
3309: @Slf4j
3310: public class SteamAuthController {
3311:     private final AuthenticationService authService;
3312: 
3313:     @Value("${steam.return.url}")
3314:     private String returnUrl;
3315: 
3316:     @Value("${steam.realm.url}")
3317:     private String realmUrl;
3318: 
3319:     public SteamAuthController(AuthenticationService authService) {
3320:         this.authService = authService;
3321:     }
3322: 
3323:     @GetMapping("/login")
3324:     public ResponseEntity<Map<String, String>> steamLogin() {
3325:         try {
3326:             String steamOpenIdUrl = buildSteamOpenIdUrl();
3327:             return ResponseEntity.ok(Map.of("url", steamOpenIdUrl));
3328:         } catch (Exception e) {
3329:             log.error("Error generating Steam login URL", e);
3330:             throw new SteamAuthenticationException("Failed to generate Steam login URL");
3331:         }
3332:     }
3333: 
3334:     @GetMapping("/return")
3335:     public ResponseEntity<AuthenticationResponse> steamReturn(@RequestParam Map<String, String> params) {
3336:         log.debug("Received Steam return params: {}", params);
3337:         AuthenticationResponse response = authService.authenticate("steam", params);
3338:         return ResponseEntity.ok(response);
3339:     }
3340: 
3341:     private String buildSteamOpenIdUrl() {
3342:         try {
3343:             String encodedReturnUrl = URLEncoder.encode(returnUrl, StandardCharsets.UTF_8);
3344:             String encodedRealm = URLEncoder.encode(realmUrl, StandardCharsets.UTF_8);
3345: 
3346:             return String.format(
3347:                     "https://steamcommunity.com/openid/login" +
3348:                             "?openid.ns=%s" +
3349:                             "&openid.mode=checkid_setup" +
3350:                             "&openid.return_to=%s" +
3351:                             "&openid.realm=%s" +
3352:                             "&openid.identity=%s" +
3353:                             "&openid.claimed_id=%s",
3354:                     URLEncoder.encode("http://specs.openid.net/auth/2.0", StandardCharsets.UTF_8),
3355:                     encodedReturnUrl,
3356:                     encodedRealm,
3357:                     URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8),
3358:                     URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8)
3359:             );
3360:         } catch (Exception e) {
3361:             log.error("Error building Steam OpenID URL", e);
3362:             throw new SteamAuthenticationException("Failed to build Steam authentication URL");
3363:         }
3364:     }
3365: }
3366: </file>
3367: 
3368: <file path="src/main/java/com/bht/ludonova/controller/TestController.java">
3369: package com.bht.ludonova.controller;
3370: 
3371: import org.springframework.http.ResponseEntity;
3372: import org.springframework.web.bind.annotation.GetMapping;
3373: import org.springframework.web.bind.annotation.RequestMapping;
3374: import org.springframework.web.bind.annotation.RestController;
3375: 
3376: @RestController
3377: @RequestMapping("/api/test")
3378: public class TestController {
3379: 
3380:     @GetMapping("/public")
3381:     public ResponseEntity<String> publicEndpoint() {
3382:         return ResponseEntity.ok("Public endpoint is working!");
3383:     }
3384: 
3385:     @GetMapping("/protected")
3386:     public ResponseEntity<String> protectedEndpoint() {
3387:         return ResponseEntity.ok("Protected endpoint is working! You are authenticated.");
3388:     }
3389: }
3390: </file>
3391: 
3392: <file path="src/main/java/com/bht/ludonova/controller/UserController.java">
3393: package com.bht.ludonova.controller;
3394: 
3395: import com.bht.ludonova.model.User;
3396: import com.bht.ludonova.repository.UserRepository;
3397: import org.springframework.beans.factory.annotation.Autowired;
3398: import org.springframework.http.ResponseEntity;
3399: import org.springframework.security.core.annotation.AuthenticationPrincipal;
3400: import org.springframework.security.core.userdetails.UserDetails;
3401: import org.springframework.web.bind.annotation.*;
3402: 
3403: @RestController
3404: @RequestMapping("/api/user")
3405: public class UserController {
3406: 
3407:     @Autowired
3408:     private UserRepository userRepository;
3409: 
3410:     @GetMapping
3411:     public ResponseEntity<User> getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
3412:         return userRepository.findByUsername(userDetails.getUsername())
3413:                 .map(user -> {
3414:                     // Don't send the password in the response
3415:                     user.setPassword(null);
3416:                     return ResponseEntity.ok(user);
3417:                 })
3418:                 .orElse(ResponseEntity.notFound().build());
3419:     }
3420: }
3421: </file>
3422: 
3423: <file path="src/main/java/com/bht/ludonova/dto/auth/AuthenticationResponse.java">
3424: package com.bht.ludonova.dto.auth;
3425: 
3426: import com.bht.ludonova.dto.user.UserDTO;
3427: import lombok.Data;
3428: 
3429: @Data
3430: public class AuthenticationResponse {
3431:     private final TokenResponse tokens;
3432:     private final UserDTO user;
3433: }
3434: </file>
3435: 
3436: <file path="src/main/java/com/bht/ludonova/dto/auth/LoginRequest.java">
3437: package com.bht.ludonova.dto.auth;
3438: 
3439: import lombok.Data;
3440: 
3441: @Data
3442: public class LoginRequest {
3443:     private String username;
3444:     private String password;
3445: }
3446: </file>
3447: 
3448: <file path="src/main/java/com/bht/ludonova/dto/auth/RefreshTokenRequest.java">
3449: package com.bht.ludonova.dto.auth;
3450: 
3451: import lombok.Data;
3452: 
3453: @Data
3454: public class RefreshTokenRequest {
3455:     private String refreshToken;
3456: }
3457: </file>
3458: 
3459: <file path="src/main/java/com/bht/ludonova/dto/auth/TokenResponse.java">
3460: package com.bht.ludonova.dto.auth;
3461: 
3462: import lombok.Data;
3463: 
3464: @Data
3465: public class TokenResponse {
3466:     private final String accessToken;
3467:     private final String refreshToken;
3468:     private final String tokenType;
3469:     private final long expiresIn;
3470: 
3471:     public static TokenResponse of(String accessToken, String refreshToken, long expiresIn) {
3472:         return new TokenResponse(accessToken, refreshToken, "Bearer", expiresIn);
3473:     }
3474: }
3475: </file>
3476: 
3477: <file path="src/main/java/com/bht/ludonova/dto/steam/SteamApiResponseDTO.java">
3478: package com.bht.ludonova.dto.steam;
3479: 
3480: import com.fasterxml.jackson.annotation.JsonProperty;
3481: import lombok.Data;
3482: 
3483: import java.util.List;
3484: 
3485: @Data
3486: public class SteamApiResponseDTO {
3487:     private Response response;
3488: 
3489:     @Data
3490:     public static class Response {
3491:         private List<Player> players;
3492:     }
3493: 
3494:     @Data
3495:     public static class Player {
3496:         @JsonProperty("steamid")
3497:         private String steamId;
3498: 
3499:         @JsonProperty("personaname")
3500:         private String personaName;
3501: 
3502:         @JsonProperty("profileurl")
3503:         private String profileUrl;
3504: 
3505:         @JsonProperty("avatar")
3506:         private String avatarUrl;
3507:     }
3508: }
3509: </file>
3510: 
3511: <file path="src/main/java/com/bht/ludonova/dto/steam/SteamAuthRequest.java">
3512: package com.bht.ludonova.dto.steam;
3513: 
3514: import lombok.Data;
3515: 
3516: import java.util.Map;
3517: 
3518: @Data
3519: public class SteamAuthRequest {
3520:     private final Map<String, String> openIdParams;
3521: }
3522: </file>
3523: 
3524: <file path="src/main/java/com/bht/ludonova/dto/steam/SteamUserDTO.java">
3525: package com.bht.ludonova.dto.steam;
3526: 
3527: import lombok.Data;
3528: 
3529: @Data
3530: public class SteamUserDTO {
3531:     private String steamId;
3532:     private String personaName;
3533:     private String profileUrl;
3534:     private String avatarUrl;
3535: }
3536: </file>
3537: 
3538: <file path="src/main/java/com/bht/ludonova/dto/user/UserDTO.java">
3539: package com.bht.ludonova.dto.user;
3540: 
3541: import com.bht.ludonova.dto.steam.SteamUserDTO;
3542: import lombok.Data;
3543: 
3544: @Data
3545: public class UserDTO {
3546:     private Long id;
3547:     private String username;
3548:     private String email;
3549:     private SteamUserDTO steamUser;
3550: }
3551: </file>
3552: 
3553: <file path="src/main/java/com/bht/ludonova/dto/ErrorResponse.java">
3554: package com.bht.ludonova.dto;
3555: 
3556: import lombok.Data;
3557: 
3558: @Data
3559: public class ErrorResponse {
3560:     private final String errorCode;
3561:     private final String message;
3562:     private final int status;
3563: }
3564: </file>
3565: 
3566: <file path="src/main/java/com/bht/ludonova/exception/AuthenticationException.java">
3567: package com.bht.ludonova.exception;
3568: 
3569: public class AuthenticationException extends LudoNovaException {
3570:     public AuthenticationException(String message) {
3571:         super(message, "AUTH_ERROR");
3572:     }
3573: }
3574: </file>
3575: 
3576: <file path="src/main/java/com/bht/ludonova/exception/GlobalExceptionHandler.java">
3577: package com.bht.ludonova.exception;
3578: 
3579: import com.bht.ludonova.dto.ErrorResponse;
3580: import org.springframework.http.HttpStatus;
3581: import org.springframework.http.ResponseEntity;
3582: import org.springframework.web.bind.annotation.ExceptionHandler;
3583: import org.springframework.web.bind.annotation.RestControllerAdvice;
3584: 
3585: @RestControllerAdvice
3586: public class GlobalExceptionHandler {
3587: 
3588:     @ExceptionHandler(AuthenticationException.class)
3589:     public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {
3590:         ErrorResponse error = new ErrorResponse(
3591:                 ex.getErrorCode(),
3592:                 ex.getMessage(),
3593:                 HttpStatus.UNAUTHORIZED.value()
3594:         );
3595:         return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
3596:     }
3597: 
3598:     @ExceptionHandler(SteamAuthenticationException.class)
3599:     public ResponseEntity<ErrorResponse> handleSteamAuthenticationException(SteamAuthenticationException ex) {
3600:         ErrorResponse error = new ErrorResponse(
3601:                 ex.getErrorCode(),
3602:                 ex.getMessage(),
3603:                 HttpStatus.UNAUTHORIZED.value()
3604:         );
3605:         return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
3606:     }
3607: 
3608:     @ExceptionHandler(Exception.class)
3609:     public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
3610:         ErrorResponse error = new ErrorResponse(
3611:                 "INTERNAL_ERROR",
3612:                 "An unexpected error occurred",
3613:                 HttpStatus.INTERNAL_SERVER_ERROR.value()
3614:         );
3615:         return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
3616:     }
3617: }
3618: </file>
3619: 
3620: <file path="src/main/java/com/bht/ludonova/exception/LudoNovaException.java">
3621: package com.bht.ludonova.exception;
3622: 
3623: public class LudoNovaException extends RuntimeException {
3624:     private final String errorCode;
3625: 
3626:     public LudoNovaException(String message, String errorCode) {
3627:         super(message);
3628:         this.errorCode = errorCode;
3629:     }
3630: 
3631:     public String getErrorCode() {
3632:         return errorCode;
3633:     }
3634: }
3635: </file>
3636: 
3637: <file path="src/main/java/com/bht/ludonova/exception/SteamAuthenticationException.java">
3638: package com.bht.ludonova.exception;
3639: 
3640: public class SteamAuthenticationException extends AuthenticationException {
3641:     public SteamAuthenticationException(String message) {
3642:         super("Steam authentication failed: " + message);
3643:     }
3644: }
3645: </file>
3646: 
3647: <file path="src/main/java/com/bht/ludonova/model/Game.java">
3648: package com.bht.ludonova.model;
3649: 
3650: import jakarta.persistence.*;
3651: import lombok.Data;
3652: import lombok.Builder;
3653: import lombok.NoArgsConstructor;
3654: import lombok.AllArgsConstructor;
3655: 
3656: @Data
3657: @Builder
3658: @NoArgsConstructor
3659: @AllArgsConstructor
3660: @Entity
3661: @Table(name = "games")
3662: public class Game {
3663:     @Id
3664:     @GeneratedValue(strategy = GenerationType.IDENTITY)
3665:     private Long id;
3666: 
3667:     @Column(nullable = false)
3668:     private String title;
3669: 
3670:     @Column(nullable = false)
3671:     private String platform;
3672: 
3673:     @Column(nullable = false)
3674:     private String status;
3675: 
3676:     private Double rating;
3677: 
3678:     private String notes;
3679: 
3680:     @Column(name = "last_played")
3681:     private String lastPlayed;
3682: 
3683:     @Column(name = "play_time")
3684:     private Integer playTime;
3685: 
3686:     @ManyToOne(fetch = FetchType.LAZY)
3687:     @JoinColumn(name = "user_id")
3688:     private User user;
3689: }
3690: </file>
3691: 
3692: <file path="src/main/java/com/bht/ludonova/model/SteamUser.java">
3693: package com.bht.ludonova.model;
3694: 
3695: import lombok.Data;
3696: import jakarta.persistence.Entity;
3697: import jakarta.persistence.Table;
3698: import jakarta.persistence.Id;
3699: import jakarta.persistence.OneToOne;
3700: 
3701: @Data
3702: @Entity
3703: @Table(name = "steam_users")
3704: public class SteamUser {
3705:     @Id
3706:     private String steamId;
3707:     
3708:     private String personaName;
3709:     private String profileUrl;
3710:     private String avatarUrl;
3711:     
3712:     @OneToOne(mappedBy = "steamUser")
3713:     private User user;
3714: }
3715: </file>
3716: 
3717: <file path="src/main/java/com/bht/ludonova/model/User.java">
3718: package com.bht.ludonova.model;
3719: 
3720: import jakarta.persistence.*;
3721: import lombok.Data;
3722: import lombok.Builder;
3723: import lombok.NoArgsConstructor;
3724: import lombok.AllArgsConstructor;
3725: 
3726: @Data
3727: @Builder
3728: @NoArgsConstructor
3729: @AllArgsConstructor
3730: @Entity
3731: @Table(name = "users")
3732: public class User {
3733:     @Id
3734:     @GeneratedValue(strategy = GenerationType.IDENTITY)
3735:     private Long id;
3736: 
3737:     @Column(unique = true, nullable = false)
3738:     private String username;
3739: 
3740:     @Column(nullable = false)
3741:     private String password;
3742: 
3743:     @Column
3744:     private String email;
3745: 
3746:     @OneToOne(cascade = CascadeType.ALL)
3747:     @JoinColumn(name = "steam_id")
3748:     private SteamUser steamUser;
3749: }
3750: </file>
3751: 
3752: <file path="src/main/java/com/bht/ludonova/repository/GameRepository.java">
3753: package com.bht.ludonova.repository;
3754: 
3755: import com.bht.ludonova.model.Game;
3756: import org.springframework.data.jpa.repository.JpaRepository;
3757: import org.springframework.stereotype.Repository;
3758: 
3759: import java.util.List;
3760: 
3761: @Repository
3762: public interface GameRepository extends JpaRepository<Game, Long> {
3763:     List<Game> findByUserId(Long userId);
3764: }
3765: </file>
3766: 
3767: <file path="src/main/java/com/bht/ludonova/repository/UserRepository.java">
3768: package com.bht.ludonova.repository;
3769: 
3770: import com.bht.ludonova.model.User;
3771: import org.springframework.data.jpa.repository.JpaRepository;
3772: import org.springframework.stereotype.Repository;
3773: import java.util.Optional;
3774: 
3775: @Repository
3776: public interface UserRepository extends JpaRepository<User, Long> {
3777:     Optional<User> findByUsername(String username);
3778:     Optional<User> findBySteamUser_SteamId(String steamId);
3779: }
3780: </file>
3781: 
3782: <file path="src/main/java/com/bht/ludonova/security/AuthenticationExceptionHandler.java">
3783: package com.bht.ludonova.security;
3784: 
3785: import com.fasterxml.jackson.databind.ObjectMapper;
3786: import jakarta.servlet.ServletException;
3787: import jakarta.servlet.http.HttpServletRequest;
3788: import jakarta.servlet.http.HttpServletResponse;
3789: import lombok.extern.slf4j.Slf4j;
3790: import org.springframework.http.MediaType;
3791: import org.springframework.security.core.AuthenticationException;
3792: import org.springframework.security.web.AuthenticationEntryPoint;
3793: import org.springframework.security.web.access.AccessDeniedHandler;
3794: import org.springframework.security.access.AccessDeniedException;
3795: import org.springframework.stereotype.Component;
3796: 
3797: import java.io.IOException;
3798: import java.util.HashMap;
3799: import java.util.Map;
3800: 
3801: @Slf4j
3802: @Component
3803: public class AuthenticationExceptionHandler implements AuthenticationEntryPoint, AccessDeniedHandler {
3804: 
3805:     private final ObjectMapper objectMapper = new ObjectMapper();
3806: 
3807:     @Override
3808:     public void commence(HttpServletRequest request, HttpServletResponse response,
3809:                          AuthenticationException authException) throws IOException, ServletException {
3810:         log.error("Unauthorized error: {}", authException.getMessage());
3811: 
3812:         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
3813:         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
3814: 
3815:         Map<String, Object> body = new HashMap<>();
3816:         body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
3817:         body.put("error", "Unauthorized");
3818:         body.put("message", authException.getMessage());
3819:         body.put("path", request.getServletPath());
3820: 
3821:         objectMapper.writeValue(response.getOutputStream(), body);
3822:     }
3823: 
3824:     @Override
3825:     public void handle(HttpServletRequest request, HttpServletResponse response,
3826:                        AccessDeniedException accessDeniedException) throws IOException, ServletException {
3827:         log.error("Access denied error: {}", accessDeniedException.getMessage());
3828: 
3829:         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
3830:         response.setStatus(HttpServletResponse.SC_FORBIDDEN);
3831: 
3832:         Map<String, Object> body = new HashMap<>();
3833:         body.put("status", HttpServletResponse.SC_FORBIDDEN);
3834:         body.put("error", "Forbidden");
3835:         body.put("message", accessDeniedException.getMessage());
3836:         body.put("path", request.getServletPath());
3837: 
3838:         objectMapper.writeValue(response.getOutputStream(), body);
3839:     }
3840: }
3841: </file>
3842: 
3843: <file path="src/main/java/com/bht/ludonova/security/CustomUserDetailsService.java">
3844: package com.bht.ludonova.security;
3845: 
3846: import com.bht.ludonova.model.User;
3847: import com.bht.ludonova.repository.UserRepository;
3848: import lombok.RequiredArgsConstructor;
3849: import lombok.extern.slf4j.Slf4j;
3850: import org.springframework.security.core.authority.SimpleGrantedAuthority;
3851: import org.springframework.security.core.userdetails.UserDetails;
3852: import org.springframework.security.core.userdetails.UserDetailsService;
3853: import org.springframework.security.core.userdetails.UsernameNotFoundException;
3854: import org.springframework.stereotype.Service;
3855: import org.springframework.transaction.annotation.Transactional;
3856: 
3857: import java.util.Collections;
3858: 
3859: @Slf4j
3860: @Service
3861: @RequiredArgsConstructor
3862: public class CustomUserDetailsService implements UserDetailsService {
3863: 
3864:     private final UserRepository userRepository;
3865: 
3866:     @Override
3867:     @Transactional(readOnly = true)
3868:     public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
3869:         User user = userRepository.findByUsername(username)
3870:                 .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));
3871: 
3872:         return org.springframework.security.core.userdetails.User.builder()
3873:                 .username(user.getUsername())
3874:                 .password(user.getPassword())
3875:                 .authorities(Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")))
3876:                 .accountExpired(false)
3877:                 .accountLocked(false)
3878:                 .credentialsExpired(false)
3879:                 .disabled(false)
3880:                 .build();
3881:     }
3882: }
3883: </file>
3884: 
3885: <file path="src/main/java/com/bht/ludonova/security/JwtAuthenticationFilter.java">
3886: package com.bht.ludonova.security;
3887: 
3888: import com.bht.ludonova.exception.AuthenticationException;
3889: import jakarta.servlet.FilterChain;
3890: import jakarta.servlet.ServletException;
3891: import jakarta.servlet.http.HttpServletRequest;
3892: import jakarta.servlet.http.HttpServletResponse;
3893: import lombok.RequiredArgsConstructor;
3894: import lombok.extern.slf4j.Slf4j;
3895: import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
3896: import org.springframework.security.core.context.SecurityContextHolder;
3897: import org.springframework.security.core.userdetails.UserDetails;
3898: import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
3899: import org.springframework.stereotype.Component;
3900: import org.springframework.util.AntPathMatcher;
3901: import org.springframework.util.StringUtils;
3902: import org.springframework.web.filter.OncePerRequestFilter;
3903: 
3904: import java.io.IOException;
3905: import java.util.Arrays;
3906: import java.util.List;
3907: 
3908: @Slf4j
3909: @Component
3910: @RequiredArgsConstructor
3911: public class JwtAuthenticationFilter extends OncePerRequestFilter {
3912: 
3913:     private final JwtTokenProvider tokenProvider;
3914:     private final CustomUserDetailsService customUserDetailsService;
3915:     private final AntPathMatcher pathMatcher = new AntPathMatcher();
3916: 
3917:     // List of paths that don't require authentication
3918:     private final List<String> publicPaths = Arrays.asList(
3919:             "/api/auth/**",
3920:             "/api/test/public"
3921:     );
3922: 
3923:     @Override
3924:     protected boolean shouldNotFilter(HttpServletRequest request) {
3925:         String path = request.getServletPath();
3926:         return publicPaths.stream()
3927:                 .anyMatch(pattern -> pathMatcher.match(pattern, path));
3928:     }
3929: 
3930:     @Override
3931:     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
3932:             throws ServletException, IOException {
3933:         try {
3934:             String jwt = getJwtFromRequest(request);
3935: 
3936:             if (StringUtils.hasText(jwt)) {
3937:                 if (!tokenProvider.validateToken(jwt)) {
3938:                     throw new AuthenticationException("Invalid or expired JWT token");
3939:                 }
3940: 
3941:                 String username = tokenProvider.getUsernameFromToken(jwt);
3942:                 UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);
3943: 
3944:                 UsernamePasswordAuthenticationToken authentication =
3945:                         new UsernamePasswordAuthenticationToken(
3946:                                 userDetails,
3947:                                 null,
3948:                                 userDetails.getAuthorities()
3949:                         );
3950:                 authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
3951: 
3952:                 SecurityContextHolder.getContext().setAuthentication(authentication);
3953:             }
3954:         } catch (Exception ex) {
3955:             log.error("Could not set user authentication in security context", ex);
3956:             SecurityContextHolder.clearContext();
3957: 
3958:             if (ex instanceof AuthenticationException) {
3959:                 throw ex;
3960:             }
3961:         }
3962: 
3963:         filterChain.doFilter(request, response);
3964:     }
3965: 
3966:     private String getJwtFromRequest(HttpServletRequest request) {
3967:         String bearerToken = request.getHeader("Authorization");
3968:         if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
3969:             return bearerToken.substring(7);
3970:         }
3971:         return null;
3972:     }
3973: 
3974:     /**
3975:      * Helper method to check if token is about to expire
3976:      * Could be used to implement token refresh logic
3977:      */
3978:     private boolean shouldRefreshToken(String token) {
3979:         return tokenProvider.isTokenExpired(token, false);
3980:     }
3981: }
3982: </file>
3983: 
3984: <file path="src/main/java/com/bht/ludonova/security/JwtTokenProvider.java">
3985: package com.bht.ludonova.security;
3986: 
3987: 
3988: import io.jsonwebtoken.*;
3989: import io.jsonwebtoken.security.Keys;
3990: import io.jsonwebtoken.security.SignatureException;
3991: import lombok.extern.slf4j.Slf4j;
3992: import org.springframework.beans.factory.annotation.Value;
3993: import org.springframework.security.core.Authentication;
3994: import org.springframework.security.core.GrantedAuthority;
3995: import org.springframework.stereotype.Component;
3996: 
3997: import javax.crypto.SecretKey;
3998: import java.nio.charset.StandardCharsets;
3999: import java.util.Date;
4000: import java.util.HashMap;
4001: import java.util.Map;
4002: import java.util.stream.Collectors;
4003: 
4004: @Slf4j
4005: @Component
4006: public class JwtTokenProvider {
4007: 
4008:     private final SecretKey accessTokenKey;
4009:     private final SecretKey refreshTokenKey;
4010:     private final long accessTokenExpirationMs; // Changed to long
4011:     private final long refreshTokenExpirationMs; // Changed to long
4012: 
4013:     public JwtTokenProvider(
4014:             @Value("${jwt.secret}") String jwtSecret,
4015:             @Value("${jwt.refresh-secret:${jwt.secret}}") String refreshSecret,
4016:             @Value("${jwt.expiration}") long accessTokenExpirationMs, // Changed to long
4017:             @Value("${jwt.refresh-expiration:2592000000}") long refreshTokenExpirationMs) { // Changed to long
4018:         this.accessTokenKey = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
4019:         this.refreshTokenKey = Keys.hmacShaKeyFor(refreshSecret.getBytes(StandardCharsets.UTF_8));
4020:         this.accessTokenExpirationMs = accessTokenExpirationMs;
4021:         this.refreshTokenExpirationMs = refreshTokenExpirationMs;
4022:     }
4023: 
4024:     public String generateAccessToken(Authentication authentication) {
4025:         return generateAccessToken(authentication.getName(), createClaims(authentication));
4026:     }
4027: 
4028:     public String generateAccessToken(String username) {
4029:         return generateAccessToken(username, new HashMap<>());
4030:     }
4031: 
4032:     public String generateAccessToken(String username, Map<String, Object> claims) {
4033:         return generateToken(username, claims, accessTokenKey, accessTokenExpirationMs);
4034:     }
4035: 
4036:     public String generateRefreshToken(String username) {
4037:         return generateToken(username, new HashMap<>(), refreshTokenKey, refreshTokenExpirationMs);
4038:     }
4039: 
4040:     private String generateToken(String username, Map<String, Object> claims, SecretKey key, long expirationMs) {
4041:         Date now = new Date();
4042:         Date expiryDate = new Date(now.getTime() + expirationMs);
4043: 
4044:         return Jwts.builder()
4045:                 .setClaims(claims)
4046:                 .setSubject(username)
4047:                 .setIssuedAt(now)
4048:                 .setExpiration(expiryDate)
4049:                 .signWith(key, SignatureAlgorithm.HS512)
4050:                 .compact();
4051:     }
4052: 
4053:     private Map<String, Object> createClaims(Authentication authentication) {
4054:         Map<String, Object> claims = new HashMap<>();
4055: 
4056:         // Add user authorities/roles
4057:         String authorities = authentication.getAuthorities().stream()
4058:                 .map(GrantedAuthority::getAuthority)
4059:                 .collect(Collectors.joining(","));
4060:         claims.put("authorities", authorities);
4061: 
4062:         // Add token type
4063:         claims.put("type", "Bearer");
4064: 
4065:         return claims;
4066:     }
4067: 
4068:     public String getUsernameFromToken(String token, boolean isRefreshToken) {
4069:         return getClaimsFromToken(token, isRefreshToken).getSubject();
4070:     }
4071: 
4072:     public String getUsernameFromToken(String token) {
4073:         return getUsernameFromToken(token, false);
4074:     }
4075: 
4076:     public boolean validateToken(String token) {
4077:         return validateToken(token, false);
4078:     }
4079: 
4080:     public boolean validateToken(String token, boolean isRefreshToken) {
4081:         try {
4082:             SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
4083:             Jwts.parserBuilder()
4084:                     .setSigningKey(key)
4085:                     .build()
4086:                     .parseClaimsJws(token);
4087:             return true;
4088:         } catch (SignatureException e) {
4089:             log.error("Invalid JWT signature: {}", e.getMessage());
4090:         } catch (MalformedJwtException e) {
4091:             log.error("Invalid JWT token: {}", e.getMessage());
4092:         } catch (ExpiredJwtException e) {
4093:             log.error("JWT token is expired: {}", e.getMessage());
4094:         } catch (UnsupportedJwtException e) {
4095:             log.error("JWT token is unsupported: {}", e.getMessage());
4096:         } catch (IllegalArgumentException e) {
4097:             log.error("JWT claims string is empty: {}", e.getMessage());
4098:         }
4099:         return false;
4100:     }
4101: 
4102:     public Claims getClaimsFromToken(String token, boolean isRefreshToken) {
4103:         SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
4104:         return Jwts.parserBuilder()
4105:                 .setSigningKey(key)
4106:                 .build()
4107:                 .parseClaimsJws(token)
4108:                 .getBody();
4109:     }
4110: 
4111:     public boolean isTokenExpired(String token, boolean isRefreshToken) {
4112:         try {
4113:             Claims claims = getClaimsFromToken(token, isRefreshToken);
4114:             return claims.getExpiration().before(new Date());
4115:         } catch (ExpiredJwtException e) {
4116:             return true;
4117:         }
4118:     }
4119: 
4120:     public long getAccessTokenExpirationMs() {
4121:         return accessTokenExpirationMs;
4122:     }
4123: 
4124:     public long getRefreshTokenExpirationMs() {
4125:         return refreshTokenExpirationMs;
4126:     }
4127: }
4128: </file>
4129: 
4130: <file path="src/main/java/com/bht/ludonova/security/SecurityConfig.java">
4131: package com.bht.ludonova.security;
4132: 
4133: import lombok.RequiredArgsConstructor;
4134: import org.springframework.context.annotation.Bean;
4135: import org.springframework.context.annotation.Configuration;
4136: import org.springframework.security.authentication.AuthenticationManager;
4137: import org.springframework.security.authentication.AuthenticationProvider;
4138: import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
4139: import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
4140: import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
4141: import org.springframework.security.config.annotation.web.builders.HttpSecurity;
4142: import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
4143: import org.springframework.security.config.http.SessionCreationPolicy;
4144: import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
4145: import org.springframework.security.crypto.password.PasswordEncoder;
4146: import org.springframework.security.web.SecurityFilterChain;
4147: import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
4148: import org.springframework.web.cors.CorsConfigurationSource;
4149: 
4150: @Configuration
4151: @EnableWebSecurity
4152: @EnableMethodSecurity
4153: @RequiredArgsConstructor
4154: public class SecurityConfig {
4155: 
4156:     private final CustomUserDetailsService userDetailsService;
4157:     private final JwtAuthenticationFilter jwtAuthFilter;
4158:     private final CorsConfigurationSource corsConfigurationSource;
4159:     private final AuthenticationExceptionHandler authenticationExceptionHandler;
4160: 
4161:     @Bean
4162:     public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
4163:         return http
4164:                 .cors(cors -> cors.configurationSource(corsConfigurationSource))
4165:                 .csrf(csrf -> csrf.disable())
4166:                 .authorizeHttpRequests(auth -> auth
4167:                         // Public endpoints
4168:                         .requestMatchers(
4169:                                 "/api/auth/login",
4170:                                 "/api/auth/refresh",
4171:                                 "/api/auth/steam/login",
4172:                                 "/api/auth/steam/return"
4173:                         ).permitAll()
4174:                         .requestMatchers("/api/test/public").permitAll()
4175:                         // Protected endpoints
4176:                         .requestMatchers("/api/games/**").authenticated()
4177:                         .requestMatchers("/api/user/**").authenticated()
4178:                         .anyRequest().authenticated()
4179:                 )
4180:                 .sessionManagement(session -> session
4181:                         .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
4182:                 )
4183:                 .authenticationProvider(authenticationProvider())
4184:                 .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
4185:                 .exceptionHandling(exc -> exc
4186:                         .authenticationEntryPoint(authenticationExceptionHandler)
4187:                         .accessDeniedHandler(authenticationExceptionHandler)
4188:                 )
4189:                 .build();
4190:     }
4191: 
4192:     @Bean
4193:     public PasswordEncoder passwordEncoder() {
4194:         return new BCryptPasswordEncoder();
4195:     }
4196: 
4197:     @Bean
4198:     public AuthenticationProvider authenticationProvider() {
4199:         DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
4200:         authProvider.setUserDetailsService(userDetailsService);
4201:         authProvider.setPasswordEncoder(passwordEncoder());
4202:         return authProvider;
4203:     }
4204: 
4205:     @Bean
4206:     public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
4207:         return config.getAuthenticationManager();
4208:     }
4209: }
4210: </file>
4211: 
4212: <file path="src/main/java/com/bht/ludonova/service/auth/AuthenticationStrategy.java">
4213: package com.bht.ludonova.service.auth;
4214: 
4215: import com.bht.ludonova.dto.auth.AuthenticationResponse;
4216: 
4217: import java.util.Map;
4218: 
4219: public interface AuthenticationStrategy {
4220:     AuthenticationResponse authenticate(Map<String, String> credentials);
4221:     AuthenticationResponse refresh(String refreshToken);
4222: }
4223: </file>
4224: 
4225: <file path="src/main/java/com/bht/ludonova/service/auth/BasicAuthenticationStrategy.java">
4226: package com.bht.ludonova.service.auth;
4227: 
4228: import com.bht.ludonova.dto.auth.AuthenticationResponse;
4229: import com.bht.ludonova.dto.auth.TokenResponse;
4230: import com.bht.ludonova.dto.user.UserDTO;
4231: import com.bht.ludonova.exception.AuthenticationException;
4232: import com.bht.ludonova.security.JwtTokenProvider;
4233: import com.bht.ludonova.service.UserService;
4234: import lombok.extern.slf4j.Slf4j;
4235: import org.springframework.security.authentication.AuthenticationManager;
4236: import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
4237: import org.springframework.security.core.Authentication;
4238: import org.springframework.security.core.context.SecurityContextHolder;
4239: import org.springframework.stereotype.Service;
4240: 
4241: import java.util.Map;
4242: 
4243: @Service
4244: @Slf4j
4245: public class BasicAuthenticationStrategy implements AuthenticationStrategy {
4246:     private final AuthenticationManager authenticationManager;
4247:     private final JwtTokenProvider tokenProvider;
4248:     private final UserService userService;
4249: 
4250:     public BasicAuthenticationStrategy(
4251:             AuthenticationManager authenticationManager,
4252:             JwtTokenProvider tokenProvider,
4253:             UserService userService) {
4254:         this.authenticationManager = authenticationManager;
4255:         this.tokenProvider = tokenProvider;
4256:         this.userService = userService;
4257:     }
4258: 
4259:     @Override
4260:     public AuthenticationResponse authenticate(Map<String, String> credentials) {
4261:         try {
4262:             Authentication authentication = authenticationManager.authenticate(
4263:                     new UsernamePasswordAuthenticationToken(
4264:                             credentials.get("username"),
4265:                             credentials.get("password")
4266:                     )
4267:             );
4268:             SecurityContextHolder.getContext().setAuthentication(authentication);
4269: 
4270:             String accessToken = tokenProvider.generateAccessToken(authentication);
4271:             String refreshToken = tokenProvider.generateRefreshToken(authentication.getName());
4272:             UserDTO user = userService.getCurrentUserDTO();
4273: 
4274:             TokenResponse tokens = TokenResponse.of(
4275:                     accessToken,
4276:                     refreshToken,
4277:                     tokenProvider.getAccessTokenExpirationMs()
4278:             );
4279: 
4280:             return new AuthenticationResponse(tokens, user);
4281:         } catch (org.springframework.security.core.AuthenticationException e) {
4282:             log.error("Authentication failed", e);
4283:             throw new AuthenticationException("Invalid username or password");
4284:         }
4285:     }
4286: 
4287:     @Override
4288:     public AuthenticationResponse refresh(String refreshToken) {
4289:         try {
4290:             if (!tokenProvider.validateToken(refreshToken, true)) {
4291:                 throw new AuthenticationException("Invalid refresh token");
4292:             }
4293: 
4294:             String username = tokenProvider.getUsernameFromToken(refreshToken, true);
4295:             UserDTO user = userService.getUserDTOByUsername(username);
4296: 
4297:             String newAccessToken = tokenProvider.generateAccessToken(username);
4298:             String newRefreshToken = tokenProvider.generateRefreshToken(username);
4299: 
4300:             TokenResponse tokens = TokenResponse.of(
4301:                     newAccessToken,
4302:                     newRefreshToken,
4303:                     tokenProvider.getAccessTokenExpirationMs()
4304:             );
4305: 
4306:             return new AuthenticationResponse(tokens, user);
4307:         } catch (Exception e) {
4308:             log.error("Token refresh failed", e);
4309:             throw new AuthenticationException("Failed to refresh token");
4310:         }
4311:     }
4312: }
4313: </file>
4314: 
4315: <file path="src/main/java/com/bht/ludonova/service/auth/SteamAuthenticationStrategy.java">
4316: package com.bht.ludonova.service.auth;
4317: 
4318: import com.bht.ludonova.dto.auth.AuthenticationResponse;
4319: import com.bht.ludonova.dto.auth.TokenResponse;
4320: import com.bht.ludonova.dto.user.UserDTO;
4321: import com.bht.ludonova.exception.SteamAuthenticationException;
4322: import com.bht.ludonova.model.SteamUser;
4323: import com.bht.ludonova.model.User;
4324: import com.bht.ludonova.security.JwtTokenProvider;
4325: import com.bht.ludonova.service.SteamService;
4326: import com.bht.ludonova.service.UserService;
4327: import lombok.extern.slf4j.Slf4j;
4328: import org.springframework.stereotype.Service;
4329: 
4330: import java.util.Map;
4331: 
4332: @Service
4333: @Slf4j
4334: public class SteamAuthenticationStrategy implements AuthenticationStrategy {
4335:     private final SteamService steamService;
4336:     private final UserService userService;
4337:     private final JwtTokenProvider tokenProvider;
4338: 
4339:     public SteamAuthenticationStrategy(
4340:             SteamService steamService,
4341:             UserService userService,
4342:             JwtTokenProvider tokenProvider) {
4343:         this.steamService = steamService;
4344:         this.userService = userService;
4345:         this.tokenProvider = tokenProvider;
4346:     }
4347: 
4348:     @Override
4349:     public AuthenticationResponse authenticate(Map<String, String> openIdParams) {
4350:         try {
4351:             log.debug("Starting Steam authentication with params: {}", openIdParams);
4352: 
4353:             if (!steamService.validateSteamResponse(openIdParams)) {
4354:                 log.error("Steam validation failed");
4355:                 throw new SteamAuthenticationException("Invalid Steam response");
4356:             }
4357: 
4358:             log.debug("Steam response validated successfully");
4359:             String steamId = extractSteamId(openIdParams);
4360: 
4361:             if (steamId == null) {
4362:                 log.error("Could not extract Steam ID from params");
4363:                 throw new SteamAuthenticationException("Could not extract Steam ID");
4364:             }
4365: 
4366:             log.debug("Extracted Steam ID: {}", steamId);
4367:             SteamUser steamUser = steamService.fetchUserDetails(steamId);
4368:             log.debug("Fetched Steam user details: {}", steamUser);
4369: 
4370:             User user = userService.getOrCreateSteamUser(steamUser);
4371:             log.debug("Got/Created user: {}", user);
4372: 
4373:             String accessToken = tokenProvider.generateAccessToken(user.getUsername());
4374:             String refreshToken = tokenProvider.generateRefreshToken(user.getUsername());
4375:             UserDTO userDTO = userService.convertToDTO(user);
4376: 
4377:             log.debug("Generated tokens and converted user to DTO");
4378: 
4379:             TokenResponse tokens = TokenResponse.of(
4380:                     accessToken,
4381:                     refreshToken,
4382:                     tokenProvider.getAccessTokenExpirationMs()
4383:             );
4384: 
4385:             return new AuthenticationResponse(tokens, userDTO);
4386:         } catch (Exception e) {
4387:             log.error("Steam authentication failed", e);
4388:             throw new SteamAuthenticationException(e.getMessage());
4389:         }
4390:     }
4391: 
4392:     @Override
4393:     public AuthenticationResponse refresh(String refreshToken) {
4394:         return null; // Steam users use the same refresh mechanism as basic auth
4395:     }
4396: 
4397:     private String extractSteamId(Map<String, String> params) {
4398:         String identity = params.get("openid.claimed_id");
4399:         if (identity != null && identity.matches("https://steamcommunity.com/openid/id/\\d+")) {
4400:             return identity.substring(identity.lastIndexOf("/") + 1);
4401:         }
4402:         return null;
4403:     }
4404: }
4405: </file>
4406: 
4407: <file path="src/main/java/com/bht/ludonova/service/AuthenticationService.java">
4408: package com.bht.ludonova.service;
4409: 
4410: import com.bht.ludonova.dto.auth.AuthenticationResponse;
4411: import com.bht.ludonova.exception.AuthenticationException;
4412: import com.bht.ludonova.service.auth.AuthenticationStrategy;
4413: import com.bht.ludonova.service.auth.BasicAuthenticationStrategy;
4414: import com.bht.ludonova.service.auth.SteamAuthenticationStrategy;
4415: import lombok.extern.slf4j.Slf4j;
4416: import org.springframework.stereotype.Service;
4417: 
4418: import java.util.Map;
4419: 
4420: @Service
4421: @Slf4j
4422: public class AuthenticationService {
4423:     private final Map<String, AuthenticationStrategy> authenticationStrategies;
4424: 
4425:     public AuthenticationService(
4426:             BasicAuthenticationStrategy basicAuthStrategy,
4427:             SteamAuthenticationStrategy steamAuthStrategy) {
4428:         this.authenticationStrategies = Map.of(
4429:                 "basic", basicAuthStrategy,
4430:                 "steam", steamAuthStrategy
4431:         );
4432:     }
4433: 
4434:     public AuthenticationResponse authenticate(String strategy, Map<String, String> credentials) {
4435:         AuthenticationStrategy authStrategy = authenticationStrategies.get(strategy);
4436:         if (authStrategy == null) {
4437:             throw new AuthenticationException("Unsupported authentication strategy: " + strategy);
4438:         }
4439: 
4440:         return authStrategy.authenticate(credentials);
4441:     }
4442: 
4443:     public AuthenticationResponse refresh(String refreshToken) {
4444:         // We use the basic strategy for refresh tokens as the mechanism is the same
4445:         return authenticationStrategies.get("basic").refresh(refreshToken);
4446:     }
4447: }
4448: </file>
4449: 
4450: <file path="src/main/java/com/bht/ludonova/service/SteamService.java">
4451: package com.bht.ludonova.service;
4452: 
4453: import com.bht.ludonova.dto.steam.SteamApiResponseDTO;
4454: import com.bht.ludonova.exception.SteamAuthenticationException;
4455: import org.springframework.beans.factory.annotation.Value;
4456: import org.springframework.stereotype.Service;
4457: import org.springframework.web.reactive.function.client.WebClient;
4458: import com.bht.ludonova.model.SteamUser;
4459: import lombok.extern.slf4j.Slf4j;
4460: import java.io.UnsupportedEncodingException;
4461: import java.net.URLEncoder;
4462: import java.nio.charset.StandardCharsets;
4463: import java.util.HashMap;
4464: import java.util.Map;
4465: import java.util.stream.Collectors;
4466: 
4467: @Slf4j
4468: @Service
4469: public class SteamService {
4470:     @Value("${steam.api.key}")
4471:     private String steamApiKey;
4472: 
4473:     private final WebClient steamApiClient;
4474:     private final WebClient openIdClient;
4475: 
4476:     public SteamService() {
4477:         this.steamApiClient = WebClient.builder()
4478:                 .baseUrl("https://api.steampowered.com")
4479:                 .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
4480:                 .build();
4481: 
4482:         this.openIdClient = WebClient.builder()
4483:                 .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
4484:                 .build();
4485:     }
4486: 
4487:     public boolean validateSteamResponse(Map<String, String> params) {
4488:         try {
4489:             log.info("Validating Steam response with params: {}", params);
4490:             String url = "https://steamcommunity.com/openid/login";
4491: 
4492:             // Create a new map with check_authentication mode
4493:             Map<String, String> validationParams = new HashMap<>(params);
4494:             validationParams.put("openid.mode", "check_authentication");
4495: 
4496:             // Convert map to form data
4497:             String formData = validationParams.entrySet().stream()
4498:                     .map(entry -> entry.getKey() + "=" + encodeValue(entry.getValue()))
4499:                     .collect(Collectors.joining("&"));
4500: 
4501:             String responseBody = openIdClient.post()
4502:                     .uri(url)
4503:                     .header("Content-Type", "application/x-www-form-urlencoded")
4504:                     .bodyValue(formData)
4505:                     .retrieve()
4506:                     .bodyToMono(String.class)
4507:                     .block();
4508: 
4509:             log.info("Steam validation response: {}", responseBody);
4510:             return responseBody != null && responseBody.contains("is_valid:true");
4511:         } catch (Exception e) {
4512:             log.error("Error validating Steam response", e);
4513:             return false;
4514:         }
4515:     }
4516: 
4517:     public SteamUser fetchUserDetails(String steamId) {
4518:         String url = "/ISteamUser/GetPlayerSummaries/v2/";
4519: 
4520:         try {
4521:             SteamApiResponseDTO dto = steamApiClient.get()
4522:                     .uri(uriBuilder -> uriBuilder
4523:                             .path(url)
4524:                             .queryParam("key", steamApiKey)
4525:                             .queryParam("steamids", steamId)
4526:                             .build())
4527:                     .retrieve()
4528:                     .bodyToMono(SteamApiResponseDTO.class)
4529:                     .block();
4530: 
4531:             if (dto != null && dto.getResponse() != null && !dto.getResponse().getPlayers().isEmpty()) {
4532:                 SteamApiResponseDTO.Player player = dto.getResponse().getPlayers().get(0);
4533:                 return mapToSteamUser(player);
4534:             }
4535: 
4536:             throw new SteamApiException("Failed to fetch Steam user details");
4537:         } catch (Exception e) {
4538:             log.error("Error fetching Steam user details", e);
4539:             throw new SteamApiException("Failed to fetch Steam user details", e);
4540:         }
4541:     }
4542: 
4543:     private String encodeValue(String value) {
4544:         try {
4545:             return URLEncoder.encode(value, StandardCharsets.UTF_8.toString());
4546:         } catch (UnsupportedEncodingException e) {
4547:             return value;
4548:         }
4549:     }
4550: 
4551:     private SteamUser mapToSteamUser(SteamApiResponseDTO.Player player) {
4552:         SteamUser steamUser = new SteamUser();
4553:         steamUser.setSteamId(player.getSteamId());
4554:         steamUser.setPersonaName(player.getPersonaName());
4555:         steamUser.setProfileUrl(player.getProfileUrl());
4556:         steamUser.setAvatarUrl(player.getAvatarUrl());
4557:         return steamUser;
4558:     }
4559: 
4560:     public static class SteamApiException extends RuntimeException {
4561:         public SteamApiException(String message) {
4562:             super(message);
4563:         }
4564: 
4565:         public SteamApiException(String message, Throwable cause) {
4566:             super(message, cause);
4567:         }
4568:     }
4569: }
4570: </file>
4571: 
4572: <file path="src/main/java/com/bht/ludonova/service/UserService.java">
4573: package com.bht.ludonova.service;
4574: 
4575: import com.bht.ludonova.dto.steam.SteamUserDTO;
4576: import com.bht.ludonova.dto.user.UserDTO;
4577: import com.bht.ludonova.exception.AuthenticationException;
4578: import org.springframework.security.core.context.SecurityContextHolder;
4579: import org.springframework.security.crypto.password.PasswordEncoder;
4580: import org.springframework.stereotype.Service;
4581: import org.springframework.transaction.annotation.Transactional;
4582: 
4583: import com.bht.ludonova.model.SteamUser;
4584: import com.bht.ludonova.model.User;
4585: import com.bht.ludonova.repository.UserRepository;
4586: 
4587: import java.util.UUID;
4588: 
4589: @Service
4590: @Transactional
4591: public class UserService {
4592:     private final UserRepository userRepository;
4593:     private final PasswordEncoder passwordEncoder;
4594: 
4595:     public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
4596:         this.userRepository = userRepository;
4597:         this.passwordEncoder = passwordEncoder;
4598:     }
4599: 
4600:     public User getOrCreateSteamUser(SteamUser steamUser) {
4601:         return userRepository.findBySteamUser_SteamId(steamUser.getSteamId())
4602:                 .orElseGet(() -> createSteamUser(steamUser));
4603:     }
4604: 
4605:     private User createSteamUser(SteamUser steamUser) {
4606:         User user = new User();
4607:         user.setUsername("steam_" + steamUser.getSteamId());
4608:         user.setPassword(passwordEncoder.encode(UUID.randomUUID().toString()));
4609:         user.setSteamUser(steamUser);
4610:         return userRepository.save(user);
4611:     }
4612: 
4613:     public UserDTO getCurrentUserDTO() {
4614:         String username = SecurityContextHolder.getContext().getAuthentication().getName();
4615:         return userRepository.findByUsername(username)
4616:                 .map(this::convertToDTO)
4617:                 .orElseThrow(() -> new AuthenticationException("User not found"));
4618:     }
4619: 
4620:     public UserDTO getUserDTOByUsername(String username) {
4621:         return userRepository.findByUsername(username)
4622:                 .map(this::convertToDTO)
4623:                 .orElseThrow(() -> new AuthenticationException("User not found: " + username));
4624:     }
4625: 
4626:     public UserDTO convertToDTO(User user) {
4627:         UserDTO dto = new UserDTO();
4628:         dto.setId(user.getId());
4629:         dto.setUsername(user.getUsername());
4630:         dto.setEmail(user.getEmail());
4631: 
4632:         if (user.getSteamUser() != null) {
4633:             SteamUserDTO steamUserDTO = new SteamUserDTO();
4634:             steamUserDTO.setSteamId(user.getSteamUser().getSteamId());
4635:             steamUserDTO.setPersonaName(user.getSteamUser().getPersonaName());
4636:             steamUserDTO.setProfileUrl(user.getSteamUser().getProfileUrl());
4637:             steamUserDTO.setAvatarUrl(user.getSteamUser().getAvatarUrl());
4638:             dto.setSteamUser(steamUserDTO);
4639:         }
4640: 
4641:         return dto;
4642:     }
4643: }
4644: </file>
4645: 
4646: <file path="src/main/java/com/bht/ludonova/LudoNovaApplication.java">
4647: package com.bht.ludonova;
4648: 
4649: import org.springframework.boot.SpringApplication;
4650: import org.springframework.boot.autoconfigure.SpringBootApplication;
4651: import org.springframework.boot.autoconfigure.domain.EntityScan;
4652: import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
4653: 
4654: @SpringBootApplication
4655: @EntityScan("com.bht.ludonova.model")
4656: @EnableJpaRepositories("com.bht.ludonova.repository")
4657: public class LudoNovaApplication {
4658:     public static void main(String[] args) {
4659:         SpringApplication.run(LudoNovaApplication.class, args);
4660:     }
4661: }
4662: </file>
4663: 
4664: <file path="src/main/resources/application.properties">
4665: # Server Configuration
4666: server.port=8080
4667: 
4668: # PostgreSQL Database Configuration
4669: spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
4670: spring.datasource.username=postgres
4671: spring.datasource.password=postgres
4672: 
4673: # JPA/Hibernate Configuration
4674: spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
4675: spring.jpa.hibernate.ddl-auto=create-drop
4676: spring.jpa.show-sql=true
4677: spring.jpa.properties.hibernate.format_sql=true
4678: 
4679: # Enable SQL initialization
4680: spring.sql.init.mode=always
4681: 
4682: # JWT Configuration
4683: jwt.secret=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
4684: jwt.refresh-secret=7338782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E
4685: 
4686: # Token expiration times (in milliseconds)
4687: # Access token: 1 hour = 3600000 ms
4688: jwt.expiration=3600000
4689: # Refresh token: 30 days = 2592000000 ms
4690: jwt.refresh-expiration=2592000000
4691: 
4692: # CORS Configuration
4693: #spring.web.cors.allowed-origins=http://localhost:3000
4694: #spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
4695: #spring.web.cors.allowed-headers=*
4696: #spring.web.cors.allow-credentials=true
4697: 
4698: # CORS Configuration
4699: cors.allowed-origins=http://localhost:3000
4700: 
4701: # Logging Configuration
4702: logging.level.com.bht.ludonova=DEBUG
4703: logging.level.org.hibernate.SQL=DEBUG
4704: logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
4705: 
4706: # Steam Configuration
4707: steam.api.key=${STEAM_API_KEY}
4708: steam.return.url=${STEAM_RETURN_URL:http://localhost:3000/auth/steam/callback}
4709: steam.realm.url=${STEAM_REALM_URL:http://localhost:3000}
4710: </file>
4711: 
4712: <file path=".env.example">
4713: # Steam Configuration
4714: STEAM_API_KEY=your_steam_api_key_here
4715: STEAM_RETURN_URL=http://localhost:3000/auth/steam/callback
4716: </file>
4717: 
4718: <file path=".gitignore">
4719: HELP.md
4720: target/
4721: !.mvn/wrapper/maven-wrapper.jar
4722: !**/src/main/**/target/
4723: !**/src/test/**/target/
4724: 
4725: ### STS ###
4726: .apt_generated
4727: .classpath
4728: .factorypath
4729: .project
4730: .settings
4731: .springBeans
4732: .sts4-cache
4733: 
4734: ### IntelliJ IDEA ###
4735: .idea
4736: *.iws
4737: *.iml
4738: *.ipr
4739: 
4740: ### NetBeans ###
4741: /nbproject/private/
4742: /nbbuild/
4743: /dist/
4744: /nbdist/
4745: /.nb-gradle/
4746: build/
4747: !**/src/main/**/build/
4748: !**/src/test/**/build/
4749: 
4750: ### VS Code ###
4751: .vscode/
4752: 
4753: ### Environment Files ###
4754: .env
4755: application-local.properties
4756: application-dev.properties
4757: application-prod.properties
4758: 
4759: ### Logs ###
4760: *.log
4761: logs/
4762: log/
4763: 
4764: ### Docker ###
4765: docker-compose.override.yml
4766: 
4767: ### OS generated files ###
4768: .DS_Store
4769: .DS_Store?
4770: ._*
4771: .Spotlight-V100
4772: .Trashes
4773: ehthumbs.db
4774: Thumbs.db
4775: 
4776: ### Java ###
4777: # Compiled class file
4778: *.class
4779: 
4780: # Package Files #
4781: *.jar
4782: *.war
4783: *.nar
4784: *.ear
4785: *.zip
4786: *.tar.gz
4787: *.rar
4788: 
4789: # virtual machine crash logs
4790: hs_err_pid*
4791: replay_pid*
4792: </file>
4793: 
4794: <file path="backend-overview.md">
4795: # LudoNova Backend Overview
4796: 
4797: The LudoNova backend is a robust and scalable **Spring Boot** application that powers the game backlog management system. It is designed with a focus on security, maintainability, and performance, ensuring a seamless experience for both developers and users.
4798: 
4799: ## Understanding Spring and Spring Boot
4800: 
4801: Before diving into the architecture and components of the LudoNova backend, it's essential to understand the foundational frameworks it leverages: **Spring** and **Spring Boot**.
4802: 
4803: ### What is Spring?
4804: 
4805: **Spring** is a comprehensive framework for building Java applications. It provides a wide range of features, including:
4806: 
4807: - **Dependency Injection (DI):** Allows for loose coupling of components by managing their dependencies.
4808: - **Aspect-Oriented Programming (AOP):** Enables separation of cross-cutting concerns like logging and security.
4809: - **Data Access:** Simplifies interactions with databases through modules like Spring JDBC and Spring Data.
4810: - **Transaction Management:** Provides declarative transaction management for consistent data operations.
4811: - **Model-View-Controller (MVC) Framework:** Facilitates the creation of web applications with clear separation between the model, view, and controller layers.
4812: 
4813: However, setting up a Spring application often involves extensive configuration, which can be time-consuming and error-prone.
4814: 
4815: ### What is Spring Boot?
4816: 
4817: **Spring Boot** builds upon the Spring framework to simplify the development process. It offers:
4818: 
4819: - **Auto-Configuration:** Automatically configures Spring components based on the dependencies present in the project.
4820: - **Starter POMs:** Pre-configured Maven or Gradle dependencies that simplify dependency management.
4821: - **Embedded Servers:** Allows running applications with embedded servers like Tomcat or Jetty without the need for external deployment.
4822: - **Production-Ready Features:** Includes metrics, health checks, and externalized configuration to prepare applications for production environments.
4823: 
4824: In essence, Spring Boot reduces the boilerplate configuration, enabling developers to focus more on business logic rather than setup.
4825: 
4826: ## Architecture
4827: 
4828: The backend follows a **layered architecture**, a common design pattern in Spring Boot applications that separates concerns to enhance modularity and ease of maintenance. This structure aligns with Spring's philosophy of separation of concerns and facilitates scalability and testability. The primary layers include:
4829: 
4830: - **Controller Layer:** Handles incoming HTTP requests and maps them to appropriate services.
4831:   
4832:   - **Why It's Separate:** Isolating controllers ensures that request handling logic is decoupled from business logic, making the system more modular and easier to manage.
4833: 
4834: - **Service Layer:** Contains the business logic and processes data between the controller and repository layers.
4835:   
4836:   - **Role in Spring Boot:** Services are annotated with `@Service`, a specialization of `@Component`, which allows Spring to detect and manage them as beans. This layer orchestrates operations, enforces business rules, and acts as an intermediary between controllers and repositories.
4837: 
4838: - **Repository Layer:** Manages data persistence and interacts with the PostgreSQL database using JPA/Hibernate.
4839:   
4840:   - **Integration with Spring Data:** Repositories are typically interfaces annotated with `@Repository`. Spring Data JPA provides implementations at runtime, abstracting the data access layer and enabling CRUD operations without boilerplate code.
4841: 
4842: ### How These Layers Work Together
4843: 
4844: 1. **Request Flow:**
4845:    - A client sends an HTTP request to the application.
4846:    - The **Controller** receives the request and delegates processing to the **Service** layer.
4847:    - The **Service** contains the business logic and interacts with the **Repository** to perform CRUD operations.
4848:    - The **Repository** communicates with the PostgreSQL database to fetch or persist data.
4849:    - The **Service** processes the data and returns the result to the **Controller**.
4850:    - The **Controller** sends the appropriate HTTP response back to the client.
4851: 
4852: 2. **Benefits of Layered Architecture:**
4853:    - **Modularity:** Each layer has a distinct responsibility, making the codebase easier to navigate and maintain.
4854:    - **Testability:** Layers can be tested independently, facilitating unit and integration testing.
4855:    - **Scalability:** Allows for individual layers to be scaled or modified without affecting others.
4856:    - **Maintainability:** Enhances code readability and simplifies the addition of new features.
4857: 
4858: ## Authentication and Security
4859: 
4860: Security is a paramount concern in the LudoNova backend. Leveraging Spring Boot's robust security features, the application employs a JWT (JSON Web Token) based authentication system to ensure secure and stateless user sessions.
4861: 
4862: ### Understanding Spring Security
4863: 
4864: **Spring Security** is a powerful and highly customizable authentication and access-control framework. It integrates seamlessly with Spring Boot applications, providing:
4865: 
4866: - **Authentication:** Verifies the identity of users.
4867: - **Authorization:** Controls access to resources based on user roles and permissions.
4868: - **Protection Against Common Vulnerabilities:** Guards against threats like CSRF, XSS, and session fixation.
4869: 
4870: ### Key Components:
4871: 
4872: - **JwtTokenProvider:** Generates, validates, and parses JWT tokens. It uses HMAC-SHA for token signing with a configurable secret key and expiration time.
4873:   
4874:   ```java
4875:   public String generateToken(String username) { /* ... */ }
4876:   public String getUsernameFromJWT(String token) { /* ... */ }
4877:   public boolean validateToken(String authToken) { /* ... */ }
4878:   ```
4879:   
4880:   - **Role in Spring Security:** Acts as a utility for managing JWT operations, ensuring tokens are securely created and validated.
4881: 
4882: - **JwtAuthenticationFilter:** Intercepts incoming requests to extract and validate JWT tokens. If valid, it sets the authentication in the Spring Security context.
4883:   
4884:   - **Integration with Spring Boot:** Extends `OncePerRequestFilter` to ensure that each request is processed once. It leverages the `JwtTokenProvider` to manage token validation and sets the security context accordingly.
4885: 
4886: - **SecurityConfig:** Configures Spring Security, defining public and protected endpoints, setting up the authentication provider, and applying security filters.
4887:   
4888:   - **Configuration Highlights:**
4889:     - **CORS:** Configures Cross-Origin Resource Sharing to allow or restrict requests from specific origins.
4890:     - **CSRF:** Disables Cross-Site Request Forgery protection for stateless APIs.
4891:     - **Session Management:** Configures the application to be stateless, relying solely on JWT tokens without maintaining server-side sessions.
4892:     - **Authentication Provider:** Sets up how authentication is handled, typically using a `DaoAuthenticationProvider` that retrieves user details from a data source.
4893: 
4894: ### Security Features:
4895: 
4896: - **Stateless Authentication:** No server-side sessions are maintained. All authentication is handled via JWT tokens sent with each request.
4897:   
4898:   - **Advantages:** Enhances scalability as the server doesn't need to store session information. It also simplifies horizontal scaling and load balancing.
4899: 
4900: - **Password Encryption:** User passwords are hashed using BCrypt to ensure they are not stored in plain text.
4901:   
4902:   - **Security Best Practice:** Hashing passwords protects user credentials even if the database is compromised.
4903: 
4904: - **CORS Configuration:** Restricts backend access to authorized frontend origins and specific HTTP methods.
4905:   
4906:   - **Purpose:** Prevents unauthorized domains from making requests to the backend, mitigating potential cross-origin attacks.
4907: 
4908: ## API Endpoints
4909: 
4910: The backend exposes a set of RESTful API endpoints to manage user authentication, games, and user profiles. Leveraging Spring Boot's **Spring MVC** framework, these endpoints are defined using annotations that map HTTP requests to handler methods.
4911: 
4912: ### Examples:
4913: 
4914: - **Authentication:**
4915:   - `POST /api/auth/login`: Authenticates a user and returns a JWT token.
4916:   - `POST /api/auth/register`: Registers a new user.
4917: 
4918: - **Games Management:**
4919:   - `GET /api/games`: Retrieves a list of games.
4920:   - `POST /api/games`: Adds a new game to the backlog.
4921:   - `PUT /api/games/{id}`: Updates game details.
4922:   - `DELETE /api/games/{id}`: Removes a game from the backlog.
4923: 
4924: - **User Profiles:**
4925:   - `GET /api/user`: Retrieves the authenticated user's profile information.
4926: 
4927: ### Leveraging Spring MVC:
4928: 
4929: - **Controllers:** Annotated with `@RestController`, these classes handle HTTP requests and return responses.
4930: - **Request Mappings:** Methods within controllers use annotations like `@GetMapping`, `@PostMapping`, etc., to map specific HTTP methods and URLs to handler functions.
4931: - **Response Entities:** Facilitates building HTTP responses with appropriate status codes and headers.
4932: 
4933: ## Database Management
4934: 
4935: The application uses **PostgreSQL** as its primary database, with the schema managed by **JPA/Hibernate**. Spring Boot's integration with Spring Data JPA simplifies database interactions, allowing developers to work with databases using Java objects rather than writing SQL queries.
4936: 
4937: ### Benefits of Using JPA/Hibernate:
4938: 
4939: - **Object-Relational Mapping (ORM):** Translates Java objects to database tables, enabling developers to interact with the database using familiar Java constructs.
4940: - **Schema Generation:** Automatically creates and updates the database schema based on entity classes, reducing manual configuration.
4941: - **Query Abstraction:** Provides a high-level API for querying the database, such as JPQL or the Criteria API, abstracting the underlying SQL.
4942: 
4943: ### Configuration:
4944: 
4945: ```properties
4946: # application.properties
4947: spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
4948: spring.datasource.username=yourusername
4949: spring.datasource.password=yourpassword
4950: spring.jpa.hibernate.ddl-auto=update
4951: ```
4952: 
4953: - **spring.datasource.url:** Specifies the JDBC URL for the PostgreSQL database.
4954: - **spring.jpa.hibernate.ddl-auto:** Determines how Hibernate handles schema generation. The `update` value ensures that the schema is automatically updated based on entity changes.
4955: 
4956: ## Testing and Deployment
4957: 
4958: ### Testing:
4959: 
4960: Comprehensive tests are implemented to ensure the reliability and correctness of the backend functionalities. Leveraging **Spring Boot's testing framework**, developers can write unit and integration tests with ease.
4961: 
4962: - **Running Tests:**
4963:   
4964:   ```bash
4965:   ./mvnw test
4966:   ```
4967:   
4968:   - **Spring Boot Test Annotations:** Annotations like `@SpringBootTest` facilitate loading the application context and testing components in an integrated environment.
4969:   
4970: - **Benefits:**
4971:   - **Continuous Integration:** Ensures that new changes do not break existing functionalities.
4972:   - **Quality Assurance:** Maintains high code quality and reliability.
4973: 
4974: ### Deployment:
4975: 
4976: The backend can be containerized using **Docker** and managed with **Docker Compose**. This facilitates consistent environments across development, testing, and production.
4977: 
4978: - **Containerization with Docker:**
4979:   
4980:   ```bash
4981:   docker-compose up -d
4982:   ```
4983:   
4984:   - **Advantages:**
4985:     - **Isolation:** Ensures that the application runs in a consistent environment, eliminating "it works on my machine" issues.
4986:     - **Scalability:** Simplifies scaling services horizontally.
4987:     - **Portability:** Enables easy deployment across different environments and cloud platforms.
4988: 
4989: ### Prerequisites:
4990: 
4991: - **Java 17+:** Required to run the Spring Boot application.
4992: - **Maven:** For building and managing dependencies.
4993: - **Docker and Docker Compose:** For containerization and deployment.
4994: 
4995: ## Integration with Frontend
4996: 
4997: The backend seamlessly integrates with the **React/Next.js** frontend of the LudoNova application. Authentication tokens are managed on the frontend and included in API requests to secure endpoints.
4998: 
4999: ### API Client:
5000: 
5001: A configured Axios instance is used on the frontend to handle API requests, automatically attaching JWT tokens and handling authentication errors.
5002: 
5003: ```javascript
5004: const api = axios.create({
5005:   baseURL: process.env.NEXT_PUBLIC_API_URL,
5006:   headers: {
5007:     'Content-Type': 'application/json',
5008:   },
5009: });
5010: ```
5011: 
5012: - **Interceptors:** Axios interceptors can be set up to inject JWT tokens into request headers and handle responses globally, such as redirecting to the login page on a `401 Unauthorized` response.
5013: 
5014: ## Conclusion
5015: 
5016: The LudoNova backend is meticulously crafted using **Spring Boot** to provide a secure, efficient, and scalable foundation for the game backlog management system. Its thoughtful layered architecture and robust security measures ensure a reliable service for users, while Spring Boot's auto-configuration and integration capabilities facilitate ease of development and maintenance. Understanding how Spring Boot orchestrates its components and leverages frameworks like Spring MVC and Spring Data JPA empowers developers to effectively manage and extend the backend functionalities.
5017: 
5018: ```
5019: </file>
5020: 
5021: <file path="docker-compose.yml">
5022: version: '3.8'
5023: 
5024: services:
5025:   postgres:
5026:     image: postgres:16
5027:     container_name: ludonova_db
5028:     environment:
5029:       POSTGRES_DB: ludonova
5030:       POSTGRES_USER: postgres
5031:       POSTGRES_PASSWORD: postgres
5032:     ports:
5033:       - "5432:5432"
5034:     volumes:
5035:       - postgres_data:/var/lib/postgresql/data
5036: 
5037: volumes:
5038:   postgres_data:
5039: </file>
5040: 
5041: <file path="ludonova-backend-overview.xml">
5042: This file is a merged representation of the entire codebase, combining all repository files into a single document.
5043: Generated by Repomix on: 2024-11-17T15:08:49.780Z
5044: 
5045: <file_summary>
5046: This section contains a summary of this file.
5047: 
5048: <purpose>
5049: This file contains a packed representation of the entire repository's contents.
5050: It is designed to be easily consumable by AI systems for analysis, code review,
5051: or other automated processes.
5052: </purpose>
5053: 
5054: <file_format>
5055: The content is organized as follows:
5056: 1. This summary section
5057: 2. Repository information
5058: 3. Repository structure
5059: 4. Repository files, each consisting of:
5060:   - File path as an attribute
5061:   - Full contents of the file
5062: </file_format>
5063: 
5064: <usage_guidelines>
5065: - This file should be treated as read-only. Any changes should be made to the
5066:   original repository files, not this packed version.
5067: - When processing this file, use the file path to distinguish
5068:   between different files in the repository.
5069: - Be aware that this file may contain sensitive information. Handle it with
5070:   the same level of security as you would the original repository.
5071: </usage_guidelines>
5072: 
5073: <notes>
5074: - Some files may have been excluded based on .gitignore rules and Repomix's
5075:   configuration.
5076: - Binary files are not included in this packed representation. Please refer to
5077:   the Repository Structure section for a complete list of file paths, including
5078:   binary files.
5079: </notes>
5080: 
5081: <additional_info>
5082: 
5083: For more information about Repomix, visit: https://github.com/yamadashy/repomix
5084: </additional_info>
5085: 
5086: </file_summary>
5087: 
5088: <repository_structure>
5089: src/
5090:   main/
5091:     java/
5092:       com/
5093:         bht/
5094:           ludonova/
5095:             config/
5096:               DataInitializer.java
5097:               WebConfig.java
5098:             controller/
5099:               AuthController.java
5100:               GameController.java
5101:               SteamAuthController.java
5102:               TestController.java
5103:               UserController.java
5104:             dto/
5105:               auth/
5106:                 AuthenticationResponse.java
5107:                 LoginRequest.java
5108:                 RefreshTokenRequest.java
5109:                 TokenResponse.java
5110:               steam/
5111:                 SteamApiResponseDTO.java
5112:                 SteamAuthRequest.java
5113:                 SteamUserDTO.java
5114:               user/
5115:                 UserDTO.java
5116:               ErrorResponse.java
5117:             exception/
5118:               AuthenticationException.java
5119:               GlobalExceptionHandler.java
5120:               LudoNovaException.java
5121:               SteamAuthenticationException.java
5122:             model/
5123:               Game.java
5124:               SteamUser.java
5125:               User.java
5126:             repository/
5127:               GameRepository.java
5128:               UserRepository.java
5129:             security/
5130:               AuthenticationExceptionHandler.java
5131:               CustomUserDetailsService.java
5132:               JwtAuthenticationFilter.java
5133:               JwtTokenProvider.java
5134:               SecurityConfig.java
5135:             service/
5136:               auth/
5137:                 AuthenticationStrategy.java
5138:                 BasicAuthenticationStrategy.java
5139:                 SteamAuthenticationStrategy.java
5140:               AuthenticationService.java
5141:               SteamService.java
5142:               UserService.java
5143:             LudoNovaApplication.java
5144:     resources/
5145:       application.properties
5146: .env.example
5147: .gitignore
5148: backend-overview.md
5149: docker-compose.yml
5150: pom.xml
5151: README.md
5152: setup.sh
5153: </repository_structure>
5154: 
5155: <repository_files>
5156: This section contains the contents of the repository's files.
5157: 
5158: <file path="src/main/java/com/bht/ludonova/config/DataInitializer.java">
5159: package com.bht.ludonova.config;
5160: 
5161: import com.bht.ludonova.model.User;
5162: import com.bht.ludonova.repository.UserRepository;
5163: import org.springframework.boot.CommandLineRunner;
5164: import org.springframework.context.annotation.Bean;
5165: import org.springframework.context.annotation.Configuration;
5166: import org.springframework.security.crypto.password.PasswordEncoder;
5167: 
5168: @Configuration
5169: public class DataInitializer {
5170: 
5171:     @Bean
5172:     CommandLineRunner initDatabase(UserRepository userRepository, PasswordEncoder passwordEncoder) {
5173:         return args -> {
5174:             // Create test user if it doesn't exist
5175:             if (userRepository.findByUsername("test").isEmpty()) {
5176:                 User testUser = User.builder()
5177:                         .username("test")
5178:                         .password(passwordEncoder.encode("test123"))
5179:                         .email("test@example.com")
5180:                         .build();
5181:                 userRepository.save(testUser);
5182:                 System.out.println("Test user created successfully");
5183:             }
5184:         };
5185:     }
5186: }
5187: </file>
5188: 
5189: <file path="src/main/java/com/bht/ludonova/config/WebConfig.java">
5190: package com.bht.ludonova.config;
5191: 
5192: import org.springframework.beans.factory.annotation.Value;
5193: import org.springframework.context.annotation.Bean;
5194: import org.springframework.context.annotation.Configuration;
5195: import org.springframework.web.cors.CorsConfiguration;
5196: import org.springframework.web.cors.CorsConfigurationSource;
5197: import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
5198: 
5199: import java.util.List;
5200: 
5201: @Configuration
5202: public class WebConfig {
5203: 
5204:     @Value("${cors.allowed-origins}")
5205:     private List<String> allowedOrigins;
5206: 
5207:     @Bean
5208:     public CorsConfigurationSource corsConfigurationSource() {
5209:         CorsConfiguration configuration = new CorsConfiguration();
5210:         configuration.setAllowedOrigins(allowedOrigins);
5211:         configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
5212:         configuration.setAllowedHeaders(List.of(
5213:                 "Authorization",
5214:                 "Content-Type",
5215:                 "X-Requested-With",
5216:                 "Accept",
5217:                 "Origin",
5218:                 "Access-Control-Request-Method",
5219:                 "Access-Control-Request-Headers"
5220:         ));
5221:         configuration.setExposedHeaders(List.of(
5222:                 "Access-Control-Allow-Origin",
5223:                 "Access-Control-Allow-Credentials"
5224:         ));
5225:         configuration.setAllowCredentials(true);
5226:         configuration.setMaxAge(3600L);
5227: 
5228:         UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
5229:         source.registerCorsConfiguration("/api/**", configuration);
5230:         return source;
5231:     }
5232: }
5233: </file>
5234: 
5235: <file path="src/main/java/com/bht/ludonova/controller/AuthController.java">
5236: package com.bht.ludonova.controller;
5237: 
5238: import com.bht.ludonova.dto.auth.AuthenticationResponse;
5239: import com.bht.ludonova.dto.auth.RefreshTokenRequest;
5240: import com.bht.ludonova.dto.auth.LoginRequest;
5241: import com.bht.ludonova.service.AuthenticationService;
5242: import jakarta.validation.Valid;
5243: import lombok.extern.slf4j.Slf4j;
5244: import org.springframework.http.ResponseEntity;
5245: import org.springframework.web.bind.annotation.*;
5246: 
5247: import java.util.Map;
5248: 
5249: @RestController
5250: @RequestMapping("/api/auth")
5251: @Slf4j
5252: public class AuthController {
5253:     private final AuthenticationService authService;
5254: 
5255:     public AuthController(AuthenticationService authService) {
5256:         this.authService = authService;
5257:     }
5258: 
5259:     @PostMapping("/login")
5260:     public ResponseEntity<AuthenticationResponse> login(@Valid @RequestBody LoginRequest loginRequest) {
5261:         Map<String, String> credentials = Map.of(
5262:                 "username", loginRequest.getUsername(),
5263:                 "password", loginRequest.getPassword()
5264:         );
5265: 
5266:         AuthenticationResponse response = authService.authenticate("basic", credentials);
5267:         return ResponseEntity.ok(response);
5268:     }
5269: 
5270:     @PostMapping("/refresh")
5271:     public ResponseEntity<AuthenticationResponse> refresh(@Valid @RequestBody RefreshTokenRequest request) {
5272:         AuthenticationResponse response = authService.refresh(request.getRefreshToken());
5273:         return ResponseEntity.ok(response);
5274:     }
5275: }
5276: </file>
5277: 
5278: <file path="src/main/java/com/bht/ludonova/controller/GameController.java">
5279: package com.bht.ludonova.controller;
5280: 
5281: import com.bht.ludonova.model.Game;
5282: import com.bht.ludonova.repository.GameRepository;
5283: import org.springframework.beans.factory.annotation.Autowired;
5284: import org.springframework.http.ResponseEntity;
5285: import org.springframework.security.core.annotation.AuthenticationPrincipal;
5286: import org.springframework.security.core.userdetails.UserDetails;
5287: import org.springframework.web.bind.annotation.*;
5288: 
5289: import java.util.List;
5290: 
5291: @RestController
5292: @RequestMapping("/api/games")
5293: public class GameController {
5294: 
5295:     @Autowired
5296:     private GameRepository gameRepository;
5297: 
5298:     @GetMapping
5299:     public ResponseEntity<List<Game>> getGames(@AuthenticationPrincipal UserDetails userDetails) {
5300:         // For now, return an empty list rather than null
5301:         return ResponseEntity.ok(List.of());
5302:     }
5303: 
5304:     @GetMapping("/{id}")
5305:     public ResponseEntity<Game> getGame(@PathVariable Long id) {
5306:         return gameRepository.findById(id)
5307:                 .map(ResponseEntity::ok)
5308:                 .orElse(ResponseEntity.notFound().build());
5309:     }
5310: }
5311: </file>
5312: 
5313: <file path="src/main/java/com/bht/ludonova/controller/SteamAuthController.java">
5314: package com.bht.ludonova.controller;
5315: 
5316: import com.bht.ludonova.dto.auth.AuthenticationResponse;
5317: import com.bht.ludonova.exception.SteamAuthenticationException;
5318: import com.bht.ludonova.service.AuthenticationService;
5319: import lombok.extern.slf4j.Slf4j;
5320: import org.springframework.beans.factory.annotation.Value;
5321: import org.springframework.http.ResponseEntity;
5322: import org.springframework.web.bind.annotation.GetMapping;
5323: import org.springframework.web.bind.annotation.RequestMapping;
5324: import org.springframework.web.bind.annotation.RequestParam;
5325: import org.springframework.web.bind.annotation.RestController;
5326: 
5327: import java.net.URLEncoder;
5328: import java.nio.charset.StandardCharsets;
5329: import java.util.Map;
5330: 
5331: @RestController
5332: @RequestMapping("/api/auth/steam")
5333: @Slf4j
5334: public class SteamAuthController {
5335:     private final AuthenticationService authService;
5336: 
5337:     @Value("${steam.return.url}")
5338:     private String returnUrl;
5339: 
5340:     @Value("${steam.realm.url}")
5341:     private String realmUrl;
5342: 
5343:     public SteamAuthController(AuthenticationService authService) {
5344:         this.authService = authService;
5345:     }
5346: 
5347:     @GetMapping("/login")
5348:     public ResponseEntity<Map<String, String>> steamLogin() {
5349:         try {
5350:             String steamOpenIdUrl = buildSteamOpenIdUrl();
5351:             return ResponseEntity.ok(Map.of("url", steamOpenIdUrl));
5352:         } catch (Exception e) {
5353:             log.error("Error generating Steam login URL", e);
5354:             throw new SteamAuthenticationException("Failed to generate Steam login URL");
5355:         }
5356:     }
5357: 
5358:     @GetMapping("/return")
5359:     public ResponseEntity<AuthenticationResponse> steamReturn(@RequestParam Map<String, String> params) {
5360:         log.debug("Received Steam return params: {}", params);
5361:         AuthenticationResponse response = authService.authenticate("steam", params);
5362:         return ResponseEntity.ok(response);
5363:     }
5364: 
5365:     private String buildSteamOpenIdUrl() {
5366:         try {
5367:             String encodedReturnUrl = URLEncoder.encode(returnUrl, StandardCharsets.UTF_8);
5368:             String encodedRealm = URLEncoder.encode(realmUrl, StandardCharsets.UTF_8);
5369: 
5370:             return String.format(
5371:                     "https://steamcommunity.com/openid/login" +
5372:                             "?openid.ns=%s" +
5373:                             "&openid.mode=checkid_setup" +
5374:                             "&openid.return_to=%s" +
5375:                             "&openid.realm=%s" +
5376:                             "&openid.identity=%s" +
5377:                             "&openid.claimed_id=%s",
5378:                     URLEncoder.encode("http://specs.openid.net/auth/2.0", StandardCharsets.UTF_8),
5379:                     encodedReturnUrl,
5380:                     encodedRealm,
5381:                     URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8),
5382:                     URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8)
5383:             );
5384:         } catch (Exception e) {
5385:             log.error("Error building Steam OpenID URL", e);
5386:             throw new SteamAuthenticationException("Failed to build Steam authentication URL");
5387:         }
5388:     }
5389: }
5390: </file>
5391: 
5392: <file path="src/main/java/com/bht/ludonova/controller/TestController.java">
5393: package com.bht.ludonova.controller;
5394: 
5395: import org.springframework.http.ResponseEntity;
5396: import org.springframework.web.bind.annotation.GetMapping;
5397: import org.springframework.web.bind.annotation.RequestMapping;
5398: import org.springframework.web.bind.annotation.RestController;
5399: 
5400: @RestController
5401: @RequestMapping("/api/test")
5402: public class TestController {
5403: 
5404:     @GetMapping("/public")
5405:     public ResponseEntity<String> publicEndpoint() {
5406:         return ResponseEntity.ok("Public endpoint is working!");
5407:     }
5408: 
5409:     @GetMapping("/protected")
5410:     public ResponseEntity<String> protectedEndpoint() {
5411:         return ResponseEntity.ok("Protected endpoint is working! You are authenticated.");
5412:     }
5413: }
5414: </file>
5415: 
5416: <file path="src/main/java/com/bht/ludonova/controller/UserController.java">
5417: package com.bht.ludonova.controller;
5418: 
5419: import com.bht.ludonova.model.User;
5420: import com.bht.ludonova.repository.UserRepository;
5421: import org.springframework.beans.factory.annotation.Autowired;
5422: import org.springframework.http.ResponseEntity;
5423: import org.springframework.security.core.annotation.AuthenticationPrincipal;
5424: import org.springframework.security.core.userdetails.UserDetails;
5425: import org.springframework.web.bind.annotation.*;
5426: 
5427: @RestController
5428: @RequestMapping("/api/user")
5429: public class UserController {
5430: 
5431:     @Autowired
5432:     private UserRepository userRepository;
5433: 
5434:     @GetMapping
5435:     public ResponseEntity<User> getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
5436:         return userRepository.findByUsername(userDetails.getUsername())
5437:                 .map(user -> {
5438:                     // Don't send the password in the response
5439:                     user.setPassword(null);
5440:                     return ResponseEntity.ok(user);
5441:                 })
5442:                 .orElse(ResponseEntity.notFound().build());
5443:     }
5444: }
5445: </file>
5446: 
5447: <file path="src/main/java/com/bht/ludonova/dto/auth/AuthenticationResponse.java">
5448: package com.bht.ludonova.dto.auth;
5449: 
5450: import com.bht.ludonova.dto.user.UserDTO;
5451: import lombok.Data;
5452: 
5453: @Data
5454: public class AuthenticationResponse {
5455:     private final TokenResponse tokens;
5456:     private final UserDTO user;
5457: }
5458: </file>
5459: 
5460: <file path="src/main/java/com/bht/ludonova/dto/auth/LoginRequest.java">
5461: package com.bht.ludonova.dto.auth;
5462: 
5463: import lombok.Data;
5464: 
5465: @Data
5466: public class LoginRequest {
5467:     private String username;
5468:     private String password;
5469: }
5470: </file>
5471: 
5472: <file path="src/main/java/com/bht/ludonova/dto/auth/RefreshTokenRequest.java">
5473: package com.bht.ludonova.dto.auth;
5474: 
5475: import lombok.Data;
5476: 
5477: @Data
5478: public class RefreshTokenRequest {
5479:     private String refreshToken;
5480: }
5481: </file>
5482: 
5483: <file path="src/main/java/com/bht/ludonova/dto/auth/TokenResponse.java">
5484: package com.bht.ludonova.dto.auth;
5485: 
5486: import lombok.Data;
5487: 
5488: @Data
5489: public class TokenResponse {
5490:     private final String accessToken;
5491:     private final String refreshToken;
5492:     private final String tokenType;
5493:     private final long expiresIn;
5494: 
5495:     public static TokenResponse of(String accessToken, String refreshToken, long expiresIn) {
5496:         return new TokenResponse(accessToken, refreshToken, "Bearer", expiresIn);
5497:     }
5498: }
5499: </file>
5500: 
5501: <file path="src/main/java/com/bht/ludonova/dto/steam/SteamApiResponseDTO.java">
5502: package com.bht.ludonova.dto.steam;
5503: 
5504: import com.fasterxml.jackson.annotation.JsonProperty;
5505: import lombok.Data;
5506: 
5507: import java.util.List;
5508: 
5509: @Data
5510: public class SteamApiResponseDTO {
5511:     private Response response;
5512: 
5513:     @Data
5514:     public static class Response {
5515:         private List<Player> players;
5516:     }
5517: 
5518:     @Data
5519:     public static class Player {
5520:         @JsonProperty("steamid")
5521:         private String steamId;
5522: 
5523:         @JsonProperty("personaname")
5524:         private String personaName;
5525: 
5526:         @JsonProperty("profileurl")
5527:         private String profileUrl;
5528: 
5529:         @JsonProperty("avatar")
5530:         private String avatarUrl;
5531:     }
5532: }
5533: </file>
5534: 
5535: <file path="src/main/java/com/bht/ludonova/dto/steam/SteamAuthRequest.java">
5536: package com.bht.ludonova.dto.steam;
5537: 
5538: import lombok.Data;
5539: 
5540: import java.util.Map;
5541: 
5542: @Data
5543: public class SteamAuthRequest {
5544:     private final Map<String, String> openIdParams;
5545: }
5546: </file>
5547: 
5548: <file path="src/main/java/com/bht/ludonova/dto/steam/SteamUserDTO.java">
5549: package com.bht.ludonova.dto.steam;
5550: 
5551: import lombok.Data;
5552: 
5553: @Data
5554: public class SteamUserDTO {
5555:     private String steamId;
5556:     private String personaName;
5557:     private String profileUrl;
5558:     private String avatarUrl;
5559: }
5560: </file>
5561: 
5562: <file path="src/main/java/com/bht/ludonova/dto/user/UserDTO.java">
5563: package com.bht.ludonova.dto.user;
5564: 
5565: import com.bht.ludonova.dto.steam.SteamUserDTO;
5566: import lombok.Data;
5567: 
5568: @Data
5569: public class UserDTO {
5570:     private Long id;
5571:     private String username;
5572:     private String email;
5573:     private SteamUserDTO steamUser;
5574: }
5575: </file>
5576: 
5577: <file path="src/main/java/com/bht/ludonova/dto/ErrorResponse.java">
5578: package com.bht.ludonova.dto;
5579: 
5580: import lombok.Data;
5581: 
5582: @Data
5583: public class ErrorResponse {
5584:     private final String errorCode;
5585:     private final String message;
5586:     private final int status;
5587: }
5588: </file>
5589: 
5590: <file path="src/main/java/com/bht/ludonova/exception/AuthenticationException.java">
5591: package com.bht.ludonova.exception;
5592: 
5593: public class AuthenticationException extends LudoNovaException {
5594:     public AuthenticationException(String message) {
5595:         super(message, "AUTH_ERROR");
5596:     }
5597: }
5598: </file>
5599: 
5600: <file path="src/main/java/com/bht/ludonova/exception/GlobalExceptionHandler.java">
5601: package com.bht.ludonova.exception;
5602: 
5603: import com.bht.ludonova.dto.ErrorResponse;
5604: import org.springframework.http.HttpStatus;
5605: import org.springframework.http.ResponseEntity;
5606: import org.springframework.web.bind.annotation.ExceptionHandler;
5607: import org.springframework.web.bind.annotation.RestControllerAdvice;
5608: 
5609: @RestControllerAdvice
5610: public class GlobalExceptionHandler {
5611: 
5612:     @ExceptionHandler(AuthenticationException.class)
5613:     public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {
5614:         ErrorResponse error = new ErrorResponse(
5615:                 ex.getErrorCode(),
5616:                 ex.getMessage(),
5617:                 HttpStatus.UNAUTHORIZED.value()
5618:         );
5619:         return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
5620:     }
5621: 
5622:     @ExceptionHandler(SteamAuthenticationException.class)
5623:     public ResponseEntity<ErrorResponse> handleSteamAuthenticationException(SteamAuthenticationException ex) {
5624:         ErrorResponse error = new ErrorResponse(
5625:                 ex.getErrorCode(),
5626:                 ex.getMessage(),
5627:                 HttpStatus.UNAUTHORIZED.value()
5628:         );
5629:         return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
5630:     }
5631: 
5632:     @ExceptionHandler(Exception.class)
5633:     public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
5634:         ErrorResponse error = new ErrorResponse(
5635:                 "INTERNAL_ERROR",
5636:                 "An unexpected error occurred",
5637:                 HttpStatus.INTERNAL_SERVER_ERROR.value()
5638:         );
5639:         return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
5640:     }
5641: }
5642: </file>
5643: 
5644: <file path="src/main/java/com/bht/ludonova/exception/LudoNovaException.java">
5645: package com.bht.ludonova.exception;
5646: 
5647: public class LudoNovaException extends RuntimeException {
5648:     private final String errorCode;
5649: 
5650:     public LudoNovaException(String message, String errorCode) {
5651:         super(message);
5652:         this.errorCode = errorCode;
5653:     }
5654: 
5655:     public String getErrorCode() {
5656:         return errorCode;
5657:     }
5658: }
5659: </file>
5660: 
5661: <file path="src/main/java/com/bht/ludonova/exception/SteamAuthenticationException.java">
5662: package com.bht.ludonova.exception;
5663: 
5664: public class SteamAuthenticationException extends AuthenticationException {
5665:     public SteamAuthenticationException(String message) {
5666:         super("Steam authentication failed: " + message);
5667:     }
5668: }
5669: </file>
5670: 
5671: <file path="src/main/java/com/bht/ludonova/model/Game.java">
5672: package com.bht.ludonova.model;
5673: 
5674: import jakarta.persistence.*;
5675: import lombok.Data;
5676: import lombok.Builder;
5677: import lombok.NoArgsConstructor;
5678: import lombok.AllArgsConstructor;
5679: 
5680: @Data
5681: @Builder
5682: @NoArgsConstructor
5683: @AllArgsConstructor
5684: @Entity
5685: @Table(name = "games")
5686: public class Game {
5687:     @Id
5688:     @GeneratedValue(strategy = GenerationType.IDENTITY)
5689:     private Long id;
5690: 
5691:     @Column(nullable = false)
5692:     private String title;
5693: 
5694:     @Column(nullable = false)
5695:     private String platform;
5696: 
5697:     @Column(nullable = false)
5698:     private String status;
5699: 
5700:     private Double rating;
5701: 
5702:     private String notes;
5703: 
5704:     @Column(name = "last_played")
5705:     private String lastPlayed;
5706: 
5707:     @Column(name = "play_time")
5708:     private Integer playTime;
5709: 
5710:     @ManyToOne(fetch = FetchType.LAZY)
5711:     @JoinColumn(name = "user_id")
5712:     private User user;
5713: }
5714: </file>
5715: 
5716: <file path="src/main/java/com/bht/ludonova/model/SteamUser.java">
5717: package com.bht.ludonova.model;
5718: 
5719: import lombok.Data;
5720: import jakarta.persistence.Entity;
5721: import jakarta.persistence.Table;
5722: import jakarta.persistence.Id;
5723: import jakarta.persistence.OneToOne;
5724: 
5725: @Data
5726: @Entity
5727: @Table(name = "steam_users")
5728: public class SteamUser {
5729:     @Id
5730:     private String steamId;
5731:     
5732:     private String personaName;
5733:     private String profileUrl;
5734:     private String avatarUrl;
5735:     
5736:     @OneToOne(mappedBy = "steamUser")
5737:     private User user;
5738: }
5739: </file>
5740: 
5741: <file path="src/main/java/com/bht/ludonova/model/User.java">
5742: package com.bht.ludonova.model;
5743: 
5744: import jakarta.persistence.*;
5745: import lombok.Data;
5746: import lombok.Builder;
5747: import lombok.NoArgsConstructor;
5748: import lombok.AllArgsConstructor;
5749: 
5750: @Data
5751: @Builder
5752: @NoArgsConstructor
5753: @AllArgsConstructor
5754: @Entity
5755: @Table(name = "users")
5756: public class User {
5757:     @Id
5758:     @GeneratedValue(strategy = GenerationType.IDENTITY)
5759:     private Long id;
5760: 
5761:     @Column(unique = true, nullable = false)
5762:     private String username;
5763: 
5764:     @Column(nullable = false)
5765:     private String password;
5766: 
5767:     @Column
5768:     private String email;
5769: 
5770:     @OneToOne(cascade = CascadeType.ALL)
5771:     @JoinColumn(name = "steam_id")
5772:     private SteamUser steamUser;
5773: }
5774: </file>
5775: 
5776: <file path="src/main/java/com/bht/ludonova/repository/GameRepository.java">
5777: package com.bht.ludonova.repository;
5778: 
5779: import com.bht.ludonova.model.Game;
5780: import org.springframework.data.jpa.repository.JpaRepository;
5781: import org.springframework.stereotype.Repository;
5782: 
5783: import java.util.List;
5784: 
5785: @Repository
5786: public interface GameRepository extends JpaRepository<Game, Long> {
5787:     List<Game> findByUserId(Long userId);
5788: }
5789: </file>
5790: 
5791: <file path="src/main/java/com/bht/ludonova/repository/UserRepository.java">
5792: package com.bht.ludonova.repository;
5793: 
5794: import com.bht.ludonova.model.User;
5795: import org.springframework.data.jpa.repository.JpaRepository;
5796: import org.springframework.stereotype.Repository;
5797: import java.util.Optional;
5798: 
5799: @Repository
5800: public interface UserRepository extends JpaRepository<User, Long> {
5801:     Optional<User> findByUsername(String username);
5802:     Optional<User> findBySteamUser_SteamId(String steamId);
5803: }
5804: </file>
5805: 
5806: <file path="src/main/java/com/bht/ludonova/security/AuthenticationExceptionHandler.java">
5807: package com.bht.ludonova.security;
5808: 
5809: import com.fasterxml.jackson.databind.ObjectMapper;
5810: import jakarta.servlet.ServletException;
5811: import jakarta.servlet.http.HttpServletRequest;
5812: import jakarta.servlet.http.HttpServletResponse;
5813: import lombok.extern.slf4j.Slf4j;
5814: import org.springframework.http.MediaType;
5815: import org.springframework.security.core.AuthenticationException;
5816: import org.springframework.security.web.AuthenticationEntryPoint;
5817: import org.springframework.security.web.access.AccessDeniedHandler;
5818: import org.springframework.security.access.AccessDeniedException;
5819: import org.springframework.stereotype.Component;
5820: 
5821: import java.io.IOException;
5822: import java.util.HashMap;
5823: import java.util.Map;
5824: 
5825: @Slf4j
5826: @Component
5827: public class AuthenticationExceptionHandler implements AuthenticationEntryPoint, AccessDeniedHandler {
5828: 
5829:     private final ObjectMapper objectMapper = new ObjectMapper();
5830: 
5831:     @Override
5832:     public void commence(HttpServletRequest request, HttpServletResponse response,
5833:                          AuthenticationException authException) throws IOException, ServletException {
5834:         log.error("Unauthorized error: {}", authException.getMessage());
5835: 
5836:         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
5837:         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
5838: 
5839:         Map<String, Object> body = new HashMap<>();
5840:         body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
5841:         body.put("error", "Unauthorized");
5842:         body.put("message", authException.getMessage());
5843:         body.put("path", request.getServletPath());
5844: 
5845:         objectMapper.writeValue(response.getOutputStream(), body);
5846:     }
5847: 
5848:     @Override
5849:     public void handle(HttpServletRequest request, HttpServletResponse response,
5850:                        AccessDeniedException accessDeniedException) throws IOException, ServletException {
5851:         log.error("Access denied error: {}", accessDeniedException.getMessage());
5852: 
5853:         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
5854:         response.setStatus(HttpServletResponse.SC_FORBIDDEN);
5855: 
5856:         Map<String, Object> body = new HashMap<>();
5857:         body.put("status", HttpServletResponse.SC_FORBIDDEN);
5858:         body.put("error", "Forbidden");
5859:         body.put("message", accessDeniedException.getMessage());
5860:         body.put("path", request.getServletPath());
5861: 
5862:         objectMapper.writeValue(response.getOutputStream(), body);
5863:     }
5864: }
5865: </file>
5866: 
5867: <file path="src/main/java/com/bht/ludonova/security/CustomUserDetailsService.java">
5868: package com.bht.ludonova.security;
5869: 
5870: import com.bht.ludonova.model.User;
5871: import com.bht.ludonova.repository.UserRepository;
5872: import lombok.RequiredArgsConstructor;
5873: import lombok.extern.slf4j.Slf4j;
5874: import org.springframework.security.core.authority.SimpleGrantedAuthority;
5875: import org.springframework.security.core.userdetails.UserDetails;
5876: import org.springframework.security.core.userdetails.UserDetailsService;
5877: import org.springframework.security.core.userdetails.UsernameNotFoundException;
5878: import org.springframework.stereotype.Service;
5879: import org.springframework.transaction.annotation.Transactional;
5880: 
5881: import java.util.Collections;
5882: 
5883: @Slf4j
5884: @Service
5885: @RequiredArgsConstructor
5886: public class CustomUserDetailsService implements UserDetailsService {
5887: 
5888:     private final UserRepository userRepository;
5889: 
5890:     @Override
5891:     @Transactional(readOnly = true)
5892:     public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
5893:         User user = userRepository.findByUsername(username)
5894:                 .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));
5895: 
5896:         return org.springframework.security.core.userdetails.User.builder()
5897:                 .username(user.getUsername())
5898:                 .password(user.getPassword())
5899:                 .authorities(Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")))
5900:                 .accountExpired(false)
5901:                 .accountLocked(false)
5902:                 .credentialsExpired(false)
5903:                 .disabled(false)
5904:                 .build();
5905:     }
5906: }
5907: </file>
5908: 
5909: <file path="src/main/java/com/bht/ludonova/security/JwtAuthenticationFilter.java">
5910: package com.bht.ludonova.security;
5911: 
5912: import com.bht.ludonova.exception.AuthenticationException;
5913: import jakarta.servlet.FilterChain;
5914: import jakarta.servlet.ServletException;
5915: import jakarta.servlet.http.HttpServletRequest;
5916: import jakarta.servlet.http.HttpServletResponse;
5917: import lombok.RequiredArgsConstructor;
5918: import lombok.extern.slf4j.Slf4j;
5919: import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
5920: import org.springframework.security.core.context.SecurityContextHolder;
5921: import org.springframework.security.core.userdetails.UserDetails;
5922: import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
5923: import org.springframework.stereotype.Component;
5924: import org.springframework.util.AntPathMatcher;
5925: import org.springframework.util.StringUtils;
5926: import org.springframework.web.filter.OncePerRequestFilter;
5927: 
5928: import java.io.IOException;
5929: import java.util.Arrays;
5930: import java.util.List;
5931: 
5932: @Slf4j
5933: @Component
5934: @RequiredArgsConstructor
5935: public class JwtAuthenticationFilter extends OncePerRequestFilter {
5936: 
5937:     private final JwtTokenProvider tokenProvider;
5938:     private final CustomUserDetailsService customUserDetailsService;
5939:     private final AntPathMatcher pathMatcher = new AntPathMatcher();
5940: 
5941:     // List of paths that don't require authentication
5942:     private final List<String> publicPaths = Arrays.asList(
5943:             "/api/auth/**",
5944:             "/api/test/public"
5945:     );
5946: 
5947:     @Override
5948:     protected boolean shouldNotFilter(HttpServletRequest request) {
5949:         String path = request.getServletPath();
5950:         return publicPaths.stream()
5951:                 .anyMatch(pattern -> pathMatcher.match(pattern, path));
5952:     }
5953: 
5954:     @Override
5955:     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
5956:             throws ServletException, IOException {
5957:         try {
5958:             String jwt = getJwtFromRequest(request);
5959: 
5960:             if (StringUtils.hasText(jwt)) {
5961:                 if (!tokenProvider.validateToken(jwt)) {
5962:                     throw new AuthenticationException("Invalid or expired JWT token");
5963:                 }
5964: 
5965:                 String username = tokenProvider.getUsernameFromToken(jwt);
5966:                 UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);
5967: 
5968:                 UsernamePasswordAuthenticationToken authentication =
5969:                         new UsernamePasswordAuthenticationToken(
5970:                                 userDetails,
5971:                                 null,
5972:                                 userDetails.getAuthorities()
5973:                         );
5974:                 authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
5975: 
5976:                 SecurityContextHolder.getContext().setAuthentication(authentication);
5977:             }
5978:         } catch (Exception ex) {
5979:             log.error("Could not set user authentication in security context", ex);
5980:             SecurityContextHolder.clearContext();
5981: 
5982:             if (ex instanceof AuthenticationException) {
5983:                 throw ex;
5984:             }
5985:         }
5986: 
5987:         filterChain.doFilter(request, response);
5988:     }
5989: 
5990:     private String getJwtFromRequest(HttpServletRequest request) {
5991:         String bearerToken = request.getHeader("Authorization");
5992:         if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
5993:             return bearerToken.substring(7);
5994:         }
5995:         return null;
5996:     }
5997: 
5998:     /**
5999:      * Helper method to check if token is about to expire
6000:      * Could be used to implement token refresh logic
6001:      */
6002:     private boolean shouldRefreshToken(String token) {
6003:         return tokenProvider.isTokenExpired(token, false);
6004:     }
6005: }
6006: </file>
6007: 
6008: <file path="src/main/java/com/bht/ludonova/security/JwtTokenProvider.java">
6009: package com.bht.ludonova.security;
6010: 
6011: 
6012: import io.jsonwebtoken.*;
6013: import io.jsonwebtoken.security.Keys;
6014: import io.jsonwebtoken.security.SignatureException;
6015: import lombok.extern.slf4j.Slf4j;
6016: import org.springframework.beans.factory.annotation.Value;
6017: import org.springframework.security.core.Authentication;
6018: import org.springframework.security.core.GrantedAuthority;
6019: import org.springframework.stereotype.Component;
6020: 
6021: import javax.crypto.SecretKey;
6022: import java.nio.charset.StandardCharsets;
6023: import java.util.Date;
6024: import java.util.HashMap;
6025: import java.util.Map;
6026: import java.util.stream.Collectors;
6027: 
6028: @Slf4j
6029: @Component
6030: public class JwtTokenProvider {
6031: 
6032:     private final SecretKey accessTokenKey;
6033:     private final SecretKey refreshTokenKey;
6034:     private final long accessTokenExpirationMs; // Changed to long
6035:     private final long refreshTokenExpirationMs; // Changed to long
6036: 
6037:     public JwtTokenProvider(
6038:             @Value("${jwt.secret}") String jwtSecret,
6039:             @Value("${jwt.refresh-secret:${jwt.secret}}") String refreshSecret,
6040:             @Value("${jwt.expiration}") long accessTokenExpirationMs, // Changed to long
6041:             @Value("${jwt.refresh-expiration:2592000000}") long refreshTokenExpirationMs) { // Changed to long
6042:         this.accessTokenKey = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
6043:         this.refreshTokenKey = Keys.hmacShaKeyFor(refreshSecret.getBytes(StandardCharsets.UTF_8));
6044:         this.accessTokenExpirationMs = accessTokenExpirationMs;
6045:         this.refreshTokenExpirationMs = refreshTokenExpirationMs;
6046:     }
6047: 
6048:     public String generateAccessToken(Authentication authentication) {
6049:         return generateAccessToken(authentication.getName(), createClaims(authentication));
6050:     }
6051: 
6052:     public String generateAccessToken(String username) {
6053:         return generateAccessToken(username, new HashMap<>());
6054:     }
6055: 
6056:     public String generateAccessToken(String username, Map<String, Object> claims) {
6057:         return generateToken(username, claims, accessTokenKey, accessTokenExpirationMs);
6058:     }
6059: 
6060:     public String generateRefreshToken(String username) {
6061:         return generateToken(username, new HashMap<>(), refreshTokenKey, refreshTokenExpirationMs);
6062:     }
6063: 
6064:     private String generateToken(String username, Map<String, Object> claims, SecretKey key, long expirationMs) {
6065:         Date now = new Date();
6066:         Date expiryDate = new Date(now.getTime() + expirationMs);
6067: 
6068:         return Jwts.builder()
6069:                 .setClaims(claims)
6070:                 .setSubject(username)
6071:                 .setIssuedAt(now)
6072:                 .setExpiration(expiryDate)
6073:                 .signWith(key, SignatureAlgorithm.HS512)
6074:                 .compact();
6075:     }
6076: 
6077:     private Map<String, Object> createClaims(Authentication authentication) {
6078:         Map<String, Object> claims = new HashMap<>();
6079: 
6080:         // Add user authorities/roles
6081:         String authorities = authentication.getAuthorities().stream()
6082:                 .map(GrantedAuthority::getAuthority)
6083:                 .collect(Collectors.joining(","));
6084:         claims.put("authorities", authorities);
6085: 
6086:         // Add token type
6087:         claims.put("type", "Bearer");
6088: 
6089:         return claims;
6090:     }
6091: 
6092:     public String getUsernameFromToken(String token, boolean isRefreshToken) {
6093:         return getClaimsFromToken(token, isRefreshToken).getSubject();
6094:     }
6095: 
6096:     public String getUsernameFromToken(String token) {
6097:         return getUsernameFromToken(token, false);
6098:     }
6099: 
6100:     public boolean validateToken(String token) {
6101:         return validateToken(token, false);
6102:     }
6103: 
6104:     public boolean validateToken(String token, boolean isRefreshToken) {
6105:         try {
6106:             SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
6107:             Jwts.parserBuilder()
6108:                     .setSigningKey(key)
6109:                     .build()
6110:                     .parseClaimsJws(token);
6111:             return true;
6112:         } catch (SignatureException e) {
6113:             log.error("Invalid JWT signature: {}", e.getMessage());
6114:         } catch (MalformedJwtException e) {
6115:             log.error("Invalid JWT token: {}", e.getMessage());
6116:         } catch (ExpiredJwtException e) {
6117:             log.error("JWT token is expired: {}", e.getMessage());
6118:         } catch (UnsupportedJwtException e) {
6119:             log.error("JWT token is unsupported: {}", e.getMessage());
6120:         } catch (IllegalArgumentException e) {
6121:             log.error("JWT claims string is empty: {}", e.getMessage());
6122:         }
6123:         return false;
6124:     }
6125: 
6126:     public Claims getClaimsFromToken(String token, boolean isRefreshToken) {
6127:         SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
6128:         return Jwts.parserBuilder()
6129:                 .setSigningKey(key)
6130:                 .build()
6131:                 .parseClaimsJws(token)
6132:                 .getBody();
6133:     }
6134: 
6135:     public boolean isTokenExpired(String token, boolean isRefreshToken) {
6136:         try {
6137:             Claims claims = getClaimsFromToken(token, isRefreshToken);
6138:             return claims.getExpiration().before(new Date());
6139:         } catch (ExpiredJwtException e) {
6140:             return true;
6141:         }
6142:     }
6143: 
6144:     public long getAccessTokenExpirationMs() {
6145:         return accessTokenExpirationMs;
6146:     }
6147: 
6148:     public long getRefreshTokenExpirationMs() {
6149:         return refreshTokenExpirationMs;
6150:     }
6151: }
6152: </file>
6153: 
6154: <file path="src/main/java/com/bht/ludonova/security/SecurityConfig.java">
6155: package com.bht.ludonova.security;
6156: 
6157: import lombok.RequiredArgsConstructor;
6158: import org.springframework.context.annotation.Bean;
6159: import org.springframework.context.annotation.Configuration;
6160: import org.springframework.security.authentication.AuthenticationManager;
6161: import org.springframework.security.authentication.AuthenticationProvider;
6162: import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
6163: import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
6164: import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
6165: import org.springframework.security.config.annotation.web.builders.HttpSecurity;
6166: import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
6167: import org.springframework.security.config.http.SessionCreationPolicy;
6168: import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
6169: import org.springframework.security.crypto.password.PasswordEncoder;
6170: import org.springframework.security.web.SecurityFilterChain;
6171: import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
6172: import org.springframework.web.cors.CorsConfigurationSource;
6173: 
6174: @Configuration
6175: @EnableWebSecurity
6176: @EnableMethodSecurity
6177: @RequiredArgsConstructor
6178: public class SecurityConfig {
6179: 
6180:     private final CustomUserDetailsService userDetailsService;
6181:     private final JwtAuthenticationFilter jwtAuthFilter;
6182:     private final CorsConfigurationSource corsConfigurationSource;
6183:     private final AuthenticationExceptionHandler authenticationExceptionHandler;
6184: 
6185:     @Bean
6186:     public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
6187:         return http
6188:                 .cors(cors -> cors.configurationSource(corsConfigurationSource))
6189:                 .csrf(csrf -> csrf.disable())
6190:                 .authorizeHttpRequests(auth -> auth
6191:                         // Public endpoints
6192:                         .requestMatchers(
6193:                                 "/api/auth/login",
6194:                                 "/api/auth/refresh",
6195:                                 "/api/auth/steam/login",
6196:                                 "/api/auth/steam/return"
6197:                         ).permitAll()
6198:                         .requestMatchers("/api/test/public").permitAll()
6199:                         // Protected endpoints
6200:                         .requestMatchers("/api/games/**").authenticated()
6201:                         .requestMatchers("/api/user/**").authenticated()
6202:                         .anyRequest().authenticated()
6203:                 )
6204:                 .sessionManagement(session -> session
6205:                         .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
6206:                 )
6207:                 .authenticationProvider(authenticationProvider())
6208:                 .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
6209:                 .exceptionHandling(exc -> exc
6210:                         .authenticationEntryPoint(authenticationExceptionHandler)
6211:                         .accessDeniedHandler(authenticationExceptionHandler)
6212:                 )
6213:                 .build();
6214:     }
6215: 
6216:     @Bean
6217:     public PasswordEncoder passwordEncoder() {
6218:         return new BCryptPasswordEncoder();
6219:     }
6220: 
6221:     @Bean
6222:     public AuthenticationProvider authenticationProvider() {
6223:         DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
6224:         authProvider.setUserDetailsService(userDetailsService);
6225:         authProvider.setPasswordEncoder(passwordEncoder());
6226:         return authProvider;
6227:     }
6228: 
6229:     @Bean
6230:     public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
6231:         return config.getAuthenticationManager();
6232:     }
6233: }
6234: </file>
6235: 
6236: <file path="src/main/java/com/bht/ludonova/service/auth/AuthenticationStrategy.java">
6237: package com.bht.ludonova.service.auth;
6238: 
6239: import com.bht.ludonova.dto.auth.AuthenticationResponse;
6240: 
6241: import java.util.Map;
6242: 
6243: public interface AuthenticationStrategy {
6244:     AuthenticationResponse authenticate(Map<String, String> credentials);
6245:     AuthenticationResponse refresh(String refreshToken);
6246: }
6247: </file>
6248: 
6249: <file path="src/main/java/com/bht/ludonova/service/auth/BasicAuthenticationStrategy.java">
6250: package com.bht.ludonova.service.auth;
6251: 
6252: import com.bht.ludonova.dto.auth.AuthenticationResponse;
6253: import com.bht.ludonova.dto.auth.TokenResponse;
6254: import com.bht.ludonova.dto.user.UserDTO;
6255: import com.bht.ludonova.exception.AuthenticationException;
6256: import com.bht.ludonova.security.JwtTokenProvider;
6257: import com.bht.ludonova.service.UserService;
6258: import lombok.extern.slf4j.Slf4j;
6259: import org.springframework.security.authentication.AuthenticationManager;
6260: import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
6261: import org.springframework.security.core.Authentication;
6262: import org.springframework.security.core.context.SecurityContextHolder;
6263: import org.springframework.stereotype.Service;
6264: 
6265: import java.util.Map;
6266: 
6267: @Service
6268: @Slf4j
6269: public class BasicAuthenticationStrategy implements AuthenticationStrategy {
6270:     private final AuthenticationManager authenticationManager;
6271:     private final JwtTokenProvider tokenProvider;
6272:     private final UserService userService;
6273: 
6274:     public BasicAuthenticationStrategy(
6275:             AuthenticationManager authenticationManager,
6276:             JwtTokenProvider tokenProvider,
6277:             UserService userService) {
6278:         this.authenticationManager = authenticationManager;
6279:         this.tokenProvider = tokenProvider;
6280:         this.userService = userService;
6281:     }
6282: 
6283:     @Override
6284:     public AuthenticationResponse authenticate(Map<String, String> credentials) {
6285:         try {
6286:             Authentication authentication = authenticationManager.authenticate(
6287:                     new UsernamePasswordAuthenticationToken(
6288:                             credentials.get("username"),
6289:                             credentials.get("password")
6290:                     )
6291:             );
6292:             SecurityContextHolder.getContext().setAuthentication(authentication);
6293: 
6294:             String accessToken = tokenProvider.generateAccessToken(authentication);
6295:             String refreshToken = tokenProvider.generateRefreshToken(authentication.getName());
6296:             UserDTO user = userService.getCurrentUserDTO();
6297: 
6298:             TokenResponse tokens = TokenResponse.of(
6299:                     accessToken,
6300:                     refreshToken,
6301:                     tokenProvider.getAccessTokenExpirationMs()
6302:             );
6303: 
6304:             return new AuthenticationResponse(tokens, user);
6305:         } catch (org.springframework.security.core.AuthenticationException e) {
6306:             log.error("Authentication failed", e);
6307:             throw new AuthenticationException("Invalid username or password");
6308:         }
6309:     }
6310: 
6311:     @Override
6312:     public AuthenticationResponse refresh(String refreshToken) {
6313:         try {
6314:             if (!tokenProvider.validateToken(refreshToken, true)) {
6315:                 throw new AuthenticationException("Invalid refresh token");
6316:             }
6317: 
6318:             String username = tokenProvider.getUsernameFromToken(refreshToken, true);
6319:             UserDTO user = userService.getUserDTOByUsername(username);
6320: 
6321:             String newAccessToken = tokenProvider.generateAccessToken(username);
6322:             String newRefreshToken = tokenProvider.generateRefreshToken(username);
6323: 
6324:             TokenResponse tokens = TokenResponse.of(
6325:                     newAccessToken,
6326:                     newRefreshToken,
6327:                     tokenProvider.getAccessTokenExpirationMs()
6328:             );
6329: 
6330:             return new AuthenticationResponse(tokens, user);
6331:         } catch (Exception e) {
6332:             log.error("Token refresh failed", e);
6333:             throw new AuthenticationException("Failed to refresh token");
6334:         }
6335:     }
6336: }
6337: </file>
6338: 
6339: <file path="src/main/java/com/bht/ludonova/service/auth/SteamAuthenticationStrategy.java">
6340: package com.bht.ludonova.service.auth;
6341: 
6342: import com.bht.ludonova.dto.auth.AuthenticationResponse;
6343: import com.bht.ludonova.dto.auth.TokenResponse;
6344: import com.bht.ludonova.dto.user.UserDTO;
6345: import com.bht.ludonova.exception.SteamAuthenticationException;
6346: import com.bht.ludonova.model.SteamUser;
6347: import com.bht.ludonova.model.User;
6348: import com.bht.ludonova.security.JwtTokenProvider;
6349: import com.bht.ludonova.service.SteamService;
6350: import com.bht.ludonova.service.UserService;
6351: import lombok.extern.slf4j.Slf4j;
6352: import org.springframework.stereotype.Service;
6353: 
6354: import java.util.Map;
6355: 
6356: @Service
6357: @Slf4j
6358: public class SteamAuthenticationStrategy implements AuthenticationStrategy {
6359:     private final SteamService steamService;
6360:     private final UserService userService;
6361:     private final JwtTokenProvider tokenProvider;
6362: 
6363:     public SteamAuthenticationStrategy(
6364:             SteamService steamService,
6365:             UserService userService,
6366:             JwtTokenProvider tokenProvider) {
6367:         this.steamService = steamService;
6368:         this.userService = userService;
6369:         this.tokenProvider = tokenProvider;
6370:     }
6371: 
6372:     @Override
6373:     public AuthenticationResponse authenticate(Map<String, String> openIdParams) {
6374:         try {
6375:             if (!steamService.validateSteamResponse(openIdParams)) {
6376:                 throw new SteamAuthenticationException("Invalid Steam response");
6377:             }
6378: 
6379:             String steamId = extractSteamId(openIdParams);
6380:             if (steamId == null) {
6381:                 throw new SteamAuthenticationException("Could not extract Steam ID");
6382:             }
6383: 
6384:             SteamUser steamUser = steamService.fetchUserDetails(steamId);
6385:             User user = userService.getOrCreateSteamUser(steamUser);
6386: 
6387:             String accessToken = tokenProvider.generateAccessToken(user.getUsername());
6388:             String refreshToken = tokenProvider.generateRefreshToken(user.getUsername());
6389:             UserDTO userDTO = userService.convertToDTO(user);
6390: 
6391:             TokenResponse tokens = TokenResponse.of(
6392:                     accessToken,
6393:                     refreshToken,
6394:                     tokenProvider.getAccessTokenExpirationMs()
6395:             );
6396: 
6397:             return new AuthenticationResponse(tokens, userDTO);
6398:         } catch (Exception e) {
6399:             log.error("Steam authentication failed", e);
6400:             throw new SteamAuthenticationException(e.getMessage());
6401:         }
6402:     }
6403: 
6404:     @Override
6405:     public AuthenticationResponse refresh(String refreshToken) {
6406:         return null; // Steam users use the same refresh mechanism as basic auth
6407:     }
6408: 
6409:     private String extractSteamId(Map<String, String> params) {
6410:         String identity = params.get("openid.claimed_id");
6411:         if (identity != null && identity.matches("https://steamcommunity.com/openid/id/\\d+")) {
6412:             return identity.substring(identity.lastIndexOf("/") + 1);
6413:         }
6414:         return null;
6415:     }
6416: }
6417: </file>
6418: 
6419: <file path="src/main/java/com/bht/ludonova/service/AuthenticationService.java">
6420: package com.bht.ludonova.service;
6421: 
6422: import com.bht.ludonova.dto.auth.AuthenticationResponse;
6423: import com.bht.ludonova.exception.AuthenticationException;
6424: import com.bht.ludonova.service.auth.AuthenticationStrategy;
6425: import com.bht.ludonova.service.auth.BasicAuthenticationStrategy;
6426: import com.bht.ludonova.service.auth.SteamAuthenticationStrategy;
6427: import lombok.extern.slf4j.Slf4j;
6428: import org.springframework.stereotype.Service;
6429: 
6430: import java.util.Map;
6431: 
6432: @Service
6433: @Slf4j
6434: public class AuthenticationService {
6435:     private final Map<String, AuthenticationStrategy> authenticationStrategies;
6436: 
6437:     public AuthenticationService(
6438:             BasicAuthenticationStrategy basicAuthStrategy,
6439:             SteamAuthenticationStrategy steamAuthStrategy) {
6440:         this.authenticationStrategies = Map.of(
6441:                 "basic", basicAuthStrategy,
6442:                 "steam", steamAuthStrategy
6443:         );
6444:     }
6445: 
6446:     public AuthenticationResponse authenticate(String strategy, Map<String, String> credentials) {
6447:         AuthenticationStrategy authStrategy = authenticationStrategies.get(strategy);
6448:         if (authStrategy == null) {
6449:             throw new AuthenticationException("Unsupported authentication strategy: " + strategy);
6450:         }
6451: 
6452:         return authStrategy.authenticate(credentials);
6453:     }
6454: 
6455:     public AuthenticationResponse refresh(String refreshToken) {
6456:         // We use the basic strategy for refresh tokens as the mechanism is the same
6457:         return authenticationStrategies.get("basic").refresh(refreshToken);
6458:     }
6459: }
6460: </file>
6461: 
6462: <file path="src/main/java/com/bht/ludonova/service/SteamService.java">
6463: package com.bht.ludonova.service;
6464: 
6465: import com.bht.ludonova.dto.steam.SteamApiResponseDTO;
6466: import org.springframework.beans.factory.annotation.Value;
6467: import org.springframework.stereotype.Service;
6468: import org.springframework.web.reactive.function.client.WebClient;
6469: import com.bht.ludonova.model.SteamUser;
6470: 
6471: import lombok.extern.slf4j.Slf4j;
6472: 
6473: import java.util.Map;
6474: 
6475: @Slf4j
6476: @Service
6477: public class SteamService {
6478:     @Value("${steam.api.key}")
6479:     private String steamApiKey;
6480: 
6481:     private final WebClient webClient;
6482: 
6483:     public SteamService() {
6484:         this.webClient = WebClient.builder()
6485:                 .baseUrl("https://api.steampowered.com")
6486:                 .build();
6487:     }
6488: 
6489:     public SteamUser fetchUserDetails(String steamId) {
6490:         String url = "/ISteamUser/GetPlayerSummaries/v2/";
6491: 
6492:         try {
6493:             SteamApiResponseDTO dto = webClient.get()
6494:                     .uri(uriBuilder -> uriBuilder
6495:                             .path(url)
6496:                             .queryParam("key", steamApiKey)
6497:                             .queryParam("steamids", steamId)
6498:                             .build())
6499:                     .retrieve()
6500:                     .bodyToMono(SteamApiResponseDTO.class)
6501:                     .block();
6502: 
6503:             if (dto != null && dto.getResponse() != null && !dto.getResponse().getPlayers().isEmpty()) {
6504:                 SteamApiResponseDTO.Player player = dto.getResponse().getPlayers().get(0);
6505:                 return mapToSteamUser(player);
6506:             }
6507: 
6508:             throw new SteamApiException("Failed to fetch Steam user details");
6509: 
6510:         } catch (Exception e) {
6511:             log.error("Error fetching Steam user details", e);
6512:             throw new SteamApiException("Failed to fetch Steam user details", e);
6513:         }
6514:     }
6515: 
6516:     private SteamUser mapToSteamUser(SteamApiResponseDTO.Player player) {
6517:         SteamUser steamUser = new SteamUser();
6518:         steamUser.setSteamId(player.getSteamId());
6519:         steamUser.setPersonaName(player.getPersonaName());
6520:         steamUser.setProfileUrl(player.getProfileUrl());
6521:         steamUser.setAvatarUrl(player.getAvatarUrl());
6522:         return steamUser;
6523:     }
6524: 
6525:     public boolean validateSteamResponse(Map<String, String> params) {
6526:         try {
6527:             log.info("Validating Steam response with params: {}", params);
6528:             String url = "https://steamcommunity.com/openid/login";
6529:             params.put("openid.mode", "check_authentication");
6530: 
6531:             WebClient.ResponseSpec response = webClient.post()
6532:                 .uri(url)
6533:                 .bodyValue(params)
6534:                 .retrieve();
6535: 
6536:             String responseBody = response.bodyToMono(String.class).block();
6537:             log.info("Steam validation response: {}", responseBody);
6538:             return responseBody != null && responseBody.contains("is_valid:true");
6539:         } catch (Exception e) {
6540:             log.error("Error validating Steam response", e);
6541:             return false;
6542:         }
6543:     }
6544: 
6545:     public static class SteamApiException extends RuntimeException {
6546:         public SteamApiException(String message) {
6547:             super(message);
6548:         }
6549:         
6550:         public SteamApiException(String message, Throwable cause) {
6551:             super(message, cause);
6552:         }
6553:     }
6554: }
6555: </file>
6556: 
6557: <file path="src/main/java/com/bht/ludonova/service/UserService.java">
6558: package com.bht.ludonova.service;
6559: 
6560: import com.bht.ludonova.dto.steam.SteamUserDTO;
6561: import com.bht.ludonova.dto.user.UserDTO;
6562: import com.bht.ludonova.exception.AuthenticationException;
6563: import org.springframework.security.core.context.SecurityContextHolder;
6564: import org.springframework.security.crypto.password.PasswordEncoder;
6565: import org.springframework.stereotype.Service;
6566: import org.springframework.transaction.annotation.Transactional;
6567: 
6568: import com.bht.ludonova.model.SteamUser;
6569: import com.bht.ludonova.model.User;
6570: import com.bht.ludonova.repository.UserRepository;
6571: 
6572: import java.util.UUID;
6573: 
6574: @Service
6575: @Transactional
6576: public class UserService {
6577:     private final UserRepository userRepository;
6578:     private final PasswordEncoder passwordEncoder;
6579: 
6580:     public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
6581:         this.userRepository = userRepository;
6582:         this.passwordEncoder = passwordEncoder;
6583:     }
6584: 
6585:     public User getOrCreateSteamUser(SteamUser steamUser) {
6586:         return userRepository.findBySteamUser_SteamId(steamUser.getSteamId())
6587:                 .orElseGet(() -> createSteamUser(steamUser));
6588:     }
6589: 
6590:     private User createSteamUser(SteamUser steamUser) {
6591:         User user = new User();
6592:         user.setUsername("steam_" + steamUser.getSteamId());
6593:         user.setPassword(passwordEncoder.encode(UUID.randomUUID().toString()));
6594:         user.setSteamUser(steamUser);
6595:         return userRepository.save(user);
6596:     }
6597: 
6598:     public UserDTO getCurrentUserDTO() {
6599:         String username = SecurityContextHolder.getContext().getAuthentication().getName();
6600:         return userRepository.findByUsername(username)
6601:                 .map(this::convertToDTO)
6602:                 .orElseThrow(() -> new AuthenticationException("User not found"));
6603:     }
6604: 
6605:     public UserDTO getUserDTOByUsername(String username) {
6606:         return userRepository.findByUsername(username)
6607:                 .map(this::convertToDTO)
6608:                 .orElseThrow(() -> new AuthenticationException("User not found: " + username));
6609:     }
6610: 
6611:     public UserDTO convertToDTO(User user) {
6612:         UserDTO dto = new UserDTO();
6613:         dto.setId(user.getId());
6614:         dto.setUsername(user.getUsername());
6615:         dto.setEmail(user.getEmail());
6616: 
6617:         if (user.getSteamUser() != null) {
6618:             SteamUserDTO steamUserDTO = new SteamUserDTO();
6619:             steamUserDTO.setSteamId(user.getSteamUser().getSteamId());
6620:             steamUserDTO.setPersonaName(user.getSteamUser().getPersonaName());
6621:             steamUserDTO.setProfileUrl(user.getSteamUser().getProfileUrl());
6622:             steamUserDTO.setAvatarUrl(user.getSteamUser().getAvatarUrl());
6623:             dto.setSteamUser(steamUserDTO);
6624:         }
6625: 
6626:         return dto;
6627:     }
6628: }
6629: </file>
6630: 
6631: <file path="src/main/java/com/bht/ludonova/LudoNovaApplication.java">
6632: package com.bht.ludonova;
6633: 
6634: import org.springframework.boot.SpringApplication;
6635: import org.springframework.boot.autoconfigure.SpringBootApplication;
6636: import org.springframework.boot.autoconfigure.domain.EntityScan;
6637: import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
6638: 
6639: @SpringBootApplication
6640: @EntityScan("com.bht.ludonova.model")
6641: @EnableJpaRepositories("com.bht.ludonova.repository")
6642: public class LudoNovaApplication {
6643:     public static void main(String[] args) {
6644:         SpringApplication.run(LudoNovaApplication.class, args);
6645:     }
6646: }
6647: </file>
6648: 
6649: <file path="src/main/resources/application.properties">
6650: # Server Configuration
6651: server.port=8080
6652: 
6653: # PostgreSQL Database Configuration
6654: spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
6655: spring.datasource.username=postgres
6656: spring.datasource.password=postgres
6657: 
6658: # JPA/Hibernate Configuration
6659: spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
6660: spring.jpa.hibernate.ddl-auto=create-drop
6661: spring.jpa.show-sql=true
6662: spring.jpa.properties.hibernate.format_sql=true
6663: 
6664: # Enable SQL initialization
6665: spring.sql.init.mode=always
6666: 
6667: # JWT Configuration
6668: jwt.secret=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
6669: jwt.refresh-secret=7338782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E
6670: 
6671: # Token expiration times (in milliseconds)
6672: # Access token: 1 hour = 3600000 ms
6673: jwt.expiration=3600000
6674: # Refresh token: 30 days = 2592000000 ms
6675: jwt.refresh-expiration=2592000000
6676: 
6677: # CORS Configuration
6678: #spring.web.cors.allowed-origins=http://localhost:3000
6679: #spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
6680: #spring.web.cors.allowed-headers=*
6681: #spring.web.cors.allow-credentials=true
6682: 
6683: # CORS Configuration
6684: cors.allowed-origins=http://localhost:3000
6685: 
6686: # Logging Configuration
6687: logging.level.com.bht.ludonova=DEBUG
6688: logging.level.org.hibernate.SQL=DEBUG
6689: logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
6690: 
6691: # Steam Configuration
6692: steam.api.key=${STEAM_API_KEY}
6693: steam.return.url=${STEAM_RETURN_URL:http://localhost:3000/auth/steam/callback}
6694: steam.realm.url=${STEAM_REALM_URL:http://localhost:3000}
6695: </file>
6696: 
6697: <file path=".env.example">
6698: # Steam Configuration
6699: STEAM_API_KEY=your_steam_api_key_here
6700: STEAM_RETURN_URL=http://localhost:3000/auth/steam/callback
6701: </file>
6702: 
6703: <file path=".gitignore">
6704: HELP.md
6705: target/
6706: !.mvn/wrapper/maven-wrapper.jar
6707: !**/src/main/**/target/
6708: !**/src/test/**/target/
6709: 
6710: ### STS ###
6711: .apt_generated
6712: .classpath
6713: .factorypath
6714: .project
6715: .settings
6716: .springBeans
6717: .sts4-cache
6718: 
6719: ### IntelliJ IDEA ###
6720: .idea
6721: *.iws
6722: *.iml
6723: *.ipr
6724: 
6725: ### NetBeans ###
6726: /nbproject/private/
6727: /nbbuild/
6728: /dist/
6729: /nbdist/
6730: /.nb-gradle/
6731: build/
6732: !**/src/main/**/build/
6733: !**/src/test/**/build/
6734: 
6735: ### VS Code ###
6736: .vscode/
6737: 
6738: ### Environment Files ###
6739: .env
6740: application-local.properties
6741: application-dev.properties
6742: application-prod.properties
6743: 
6744: ### Logs ###
6745: *.log
6746: logs/
6747: log/
6748: 
6749: ### Docker ###
6750: docker-compose.override.yml
6751: 
6752: ### OS generated files ###
6753: .DS_Store
6754: .DS_Store?
6755: ._*
6756: .Spotlight-V100
6757: .Trashes
6758: ehthumbs.db
6759: Thumbs.db
6760: 
6761: ### Java ###
6762: # Compiled class file
6763: *.class
6764: 
6765: # Package Files #
6766: *.jar
6767: *.war
6768: *.nar
6769: *.ear
6770: *.zip
6771: *.tar.gz
6772: *.rar
6773: 
6774: # virtual machine crash logs
6775: hs_err_pid*
6776: replay_pid*
6777: </file>
6778: 
6779: <file path="backend-overview.md">
6780: # LudoNova Backend Overview
6781: 
6782: The LudoNova backend is a robust and scalable **Spring Boot** application that powers the game backlog management system. It is designed with a focus on security, maintainability, and performance, ensuring a seamless experience for both developers and users.
6783: 
6784: ## Understanding Spring and Spring Boot
6785: 
6786: Before diving into the architecture and components of the LudoNova backend, it's essential to understand the foundational frameworks it leverages: **Spring** and **Spring Boot**.
6787: 
6788: ### What is Spring?
6789: 
6790: **Spring** is a comprehensive framework for building Java applications. It provides a wide range of features, including:
6791: 
6792: - **Dependency Injection (DI):** Allows for loose coupling of components by managing their dependencies.
6793: - **Aspect-Oriented Programming (AOP):** Enables separation of cross-cutting concerns like logging and security.
6794: - **Data Access:** Simplifies interactions with databases through modules like Spring JDBC and Spring Data.
6795: - **Transaction Management:** Provides declarative transaction management for consistent data operations.
6796: - **Model-View-Controller (MVC) Framework:** Facilitates the creation of web applications with clear separation between the model, view, and controller layers.
6797: 
6798: However, setting up a Spring application often involves extensive configuration, which can be time-consuming and error-prone.
6799: 
6800: ### What is Spring Boot?
6801: 
6802: **Spring Boot** builds upon the Spring framework to simplify the development process. It offers:
6803: 
6804: - **Auto-Configuration:** Automatically configures Spring components based on the dependencies present in the project.
6805: - **Starter POMs:** Pre-configured Maven or Gradle dependencies that simplify dependency management.
6806: - **Embedded Servers:** Allows running applications with embedded servers like Tomcat or Jetty without the need for external deployment.
6807: - **Production-Ready Features:** Includes metrics, health checks, and externalized configuration to prepare applications for production environments.
6808: 
6809: In essence, Spring Boot reduces the boilerplate configuration, enabling developers to focus more on business logic rather than setup.
6810: 
6811: ## Architecture
6812: 
6813: The backend follows a **layered architecture**, a common design pattern in Spring Boot applications that separates concerns to enhance modularity and ease of maintenance. This structure aligns with Spring's philosophy of separation of concerns and facilitates scalability and testability. The primary layers include:
6814: 
6815: - **Controller Layer:** Handles incoming HTTP requests and maps them to appropriate services.
6816:   
6817:   - **Why It's Separate:** Isolating controllers ensures that request handling logic is decoupled from business logic, making the system more modular and easier to manage.
6818: 
6819: - **Service Layer:** Contains the business logic and processes data between the controller and repository layers.
6820:   
6821:   - **Role in Spring Boot:** Services are annotated with `@Service`, a specialization of `@Component`, which allows Spring to detect and manage them as beans. This layer orchestrates operations, enforces business rules, and acts as an intermediary between controllers and repositories.
6822: 
6823: - **Repository Layer:** Manages data persistence and interacts with the PostgreSQL database using JPA/Hibernate.
6824:   
6825:   - **Integration with Spring Data:** Repositories are typically interfaces annotated with `@Repository`. Spring Data JPA provides implementations at runtime, abstracting the data access layer and enabling CRUD operations without boilerplate code.
6826: 
6827: ### How These Layers Work Together
6828: 
6829: 1. **Request Flow:**
6830:    - A client sends an HTTP request to the application.
6831:    - The **Controller** receives the request and delegates processing to the **Service** layer.
6832:    - The **Service** contains the business logic and interacts with the **Repository** to perform CRUD operations.
6833:    - The **Repository** communicates with the PostgreSQL database to fetch or persist data.
6834:    - The **Service** processes the data and returns the result to the **Controller**.
6835:    - The **Controller** sends the appropriate HTTP response back to the client.
6836: 
6837: 2. **Benefits of Layered Architecture:**
6838:    - **Modularity:** Each layer has a distinct responsibility, making the codebase easier to navigate and maintain.
6839:    - **Testability:** Layers can be tested independently, facilitating unit and integration testing.
6840:    - **Scalability:** Allows for individual layers to be scaled or modified without affecting others.
6841:    - **Maintainability:** Enhances code readability and simplifies the addition of new features.
6842: 
6843: ## Authentication and Security
6844: 
6845: Security is a paramount concern in the LudoNova backend. Leveraging Spring Boot's robust security features, the application employs a JWT (JSON Web Token) based authentication system to ensure secure and stateless user sessions.
6846: 
6847: ### Understanding Spring Security
6848: 
6849: **Spring Security** is a powerful and highly customizable authentication and access-control framework. It integrates seamlessly with Spring Boot applications, providing:
6850: 
6851: - **Authentication:** Verifies the identity of users.
6852: - **Authorization:** Controls access to resources based on user roles and permissions.
6853: - **Protection Against Common Vulnerabilities:** Guards against threats like CSRF, XSS, and session fixation.
6854: 
6855: ### Key Components:
6856: 
6857: - **JwtTokenProvider:** Generates, validates, and parses JWT tokens. It uses HMAC-SHA for token signing with a configurable secret key and expiration time.
6858:   
6859:   ```java
6860:   public String generateToken(String username) { /* ... */ }
6861:   public String getUsernameFromJWT(String token) { /* ... */ }
6862:   public boolean validateToken(String authToken) { /* ... */ }
6863:   ```
6864:   
6865:   - **Role in Spring Security:** Acts as a utility for managing JWT operations, ensuring tokens are securely created and validated.
6866: 
6867: - **JwtAuthenticationFilter:** Intercepts incoming requests to extract and validate JWT tokens. If valid, it sets the authentication in the Spring Security context.
6868:   
6869:   - **Integration with Spring Boot:** Extends `OncePerRequestFilter` to ensure that each request is processed once. It leverages the `JwtTokenProvider` to manage token validation and sets the security context accordingly.
6870: 
6871: - **SecurityConfig:** Configures Spring Security, defining public and protected endpoints, setting up the authentication provider, and applying security filters.
6872:   
6873:   - **Configuration Highlights:**
6874:     - **CORS:** Configures Cross-Origin Resource Sharing to allow or restrict requests from specific origins.
6875:     - **CSRF:** Disables Cross-Site Request Forgery protection for stateless APIs.
6876:     - **Session Management:** Configures the application to be stateless, relying solely on JWT tokens without maintaining server-side sessions.
6877:     - **Authentication Provider:** Sets up how authentication is handled, typically using a `DaoAuthenticationProvider` that retrieves user details from a data source.
6878: 
6879: ### Security Features:
6880: 
6881: - **Stateless Authentication:** No server-side sessions are maintained. All authentication is handled via JWT tokens sent with each request.
6882:   
6883:   - **Advantages:** Enhances scalability as the server doesn't need to store session information. It also simplifies horizontal scaling and load balancing.
6884: 
6885: - **Password Encryption:** User passwords are hashed using BCrypt to ensure they are not stored in plain text.
6886:   
6887:   - **Security Best Practice:** Hashing passwords protects user credentials even if the database is compromised.
6888: 
6889: - **CORS Configuration:** Restricts backend access to authorized frontend origins and specific HTTP methods.
6890:   
6891:   - **Purpose:** Prevents unauthorized domains from making requests to the backend, mitigating potential cross-origin attacks.
6892: 
6893: ## API Endpoints
6894: 
6895: The backend exposes a set of RESTful API endpoints to manage user authentication, games, and user profiles. Leveraging Spring Boot's **Spring MVC** framework, these endpoints are defined using annotations that map HTTP requests to handler methods.
6896: 
6897: ### Examples:
6898: 
6899: - **Authentication:**
6900:   - `POST /api/auth/login`: Authenticates a user and returns a JWT token.
6901:   - `POST /api/auth/register`: Registers a new user.
6902: 
6903: - **Games Management:**
6904:   - `GET /api/games`: Retrieves a list of games.
6905:   - `POST /api/games`: Adds a new game to the backlog.
6906:   - `PUT /api/games/{id}`: Updates game details.
6907:   - `DELETE /api/games/{id}`: Removes a game from the backlog.
6908: 
6909: - **User Profiles:**
6910:   - `GET /api/user`: Retrieves the authenticated user's profile information.
6911: 
6912: ### Leveraging Spring MVC:
6913: 
6914: - **Controllers:** Annotated with `@RestController`, these classes handle HTTP requests and return responses.
6915: - **Request Mappings:** Methods within controllers use annotations like `@GetMapping`, `@PostMapping`, etc., to map specific HTTP methods and URLs to handler functions.
6916: - **Response Entities:** Facilitates building HTTP responses with appropriate status codes and headers.
6917: 
6918: ## Database Management
6919: 
6920: The application uses **PostgreSQL** as its primary database, with the schema managed by **JPA/Hibernate**. Spring Boot's integration with Spring Data JPA simplifies database interactions, allowing developers to work with databases using Java objects rather than writing SQL queries.
6921: 
6922: ### Benefits of Using JPA/Hibernate:
6923: 
6924: - **Object-Relational Mapping (ORM):** Translates Java objects to database tables, enabling developers to interact with the database using familiar Java constructs.
6925: - **Schema Generation:** Automatically creates and updates the database schema based on entity classes, reducing manual configuration.
6926: - **Query Abstraction:** Provides a high-level API for querying the database, such as JPQL or the Criteria API, abstracting the underlying SQL.
6927: 
6928: ### Configuration:
6929: 
6930: ```properties
6931: # application.properties
6932: spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
6933: spring.datasource.username=yourusername
6934: spring.datasource.password=yourpassword
6935: spring.jpa.hibernate.ddl-auto=update
6936: ```
6937: 
6938: - **spring.datasource.url:** Specifies the JDBC URL for the PostgreSQL database.
6939: - **spring.jpa.hibernate.ddl-auto:** Determines how Hibernate handles schema generation. The `update` value ensures that the schema is automatically updated based on entity changes.
6940: 
6941: ## Testing and Deployment
6942: 
6943: ### Testing:
6944: 
6945: Comprehensive tests are implemented to ensure the reliability and correctness of the backend functionalities. Leveraging **Spring Boot's testing framework**, developers can write unit and integration tests with ease.
6946: 
6947: - **Running Tests:**
6948:   
6949:   ```bash
6950:   ./mvnw test
6951:   ```
6952:   
6953:   - **Spring Boot Test Annotations:** Annotations like `@SpringBootTest` facilitate loading the application context and testing components in an integrated environment.
6954:   
6955: - **Benefits:**
6956:   - **Continuous Integration:** Ensures that new changes do not break existing functionalities.
6957:   - **Quality Assurance:** Maintains high code quality and reliability.
6958: 
6959: ### Deployment:
6960: 
6961: The backend can be containerized using **Docker** and managed with **Docker Compose**. This facilitates consistent environments across development, testing, and production.
6962: 
6963: - **Containerization with Docker:**
6964:   
6965:   ```bash
6966:   docker-compose up -d
6967:   ```
6968:   
6969:   - **Advantages:**
6970:     - **Isolation:** Ensures that the application runs in a consistent environment, eliminating "it works on my machine" issues.
6971:     - **Scalability:** Simplifies scaling services horizontally.
6972:     - **Portability:** Enables easy deployment across different environments and cloud platforms.
6973: 
6974: ### Prerequisites:
6975: 
6976: - **Java 17+:** Required to run the Spring Boot application.
6977: - **Maven:** For building and managing dependencies.
6978: - **Docker and Docker Compose:** For containerization and deployment.
6979: 
6980: ## Integration with Frontend
6981: 
6982: The backend seamlessly integrates with the **React/Next.js** frontend of the LudoNova application. Authentication tokens are managed on the frontend and included in API requests to secure endpoints.
6983: 
6984: ### API Client:
6985: 
6986: A configured Axios instance is used on the frontend to handle API requests, automatically attaching JWT tokens and handling authentication errors.
6987: 
6988: ```javascript
6989: const api = axios.create({
6990:   baseURL: process.env.NEXT_PUBLIC_API_URL,
6991:   headers: {
6992:     'Content-Type': 'application/json',
6993:   },
6994: });
6995: ```
6996: 
6997: - **Interceptors:** Axios interceptors can be set up to inject JWT tokens into request headers and handle responses globally, such as redirecting to the login page on a `401 Unauthorized` response.
6998: 
6999: ## Conclusion
7000: 
7001: The LudoNova backend is meticulously crafted using **Spring Boot** to provide a secure, efficient, and scalable foundation for the game backlog management system. Its thoughtful layered architecture and robust security measures ensure a reliable service for users, while Spring Boot's auto-configuration and integration capabilities facilitate ease of development and maintenance. Understanding how Spring Boot orchestrates its components and leverages frameworks like Spring MVC and Spring Data JPA empowers developers to effectively manage and extend the backend functionalities.
7002: 
7003: ```
7004: </file>
7005: 
7006: <file path="docker-compose.yml">
7007: version: '3.8'
7008: 
7009: services:
7010:   postgres:
7011:     image: postgres:16
7012:     container_name: ludonova_db
7013:     environment:
7014:       POSTGRES_DB: ludonova
7015:       POSTGRES_USER: postgres
7016:       POSTGRES_PASSWORD: postgres
7017:     ports:
7018:       - "5432:5432"
7019:     volumes:
7020:       - postgres_data:/var/lib/postgresql/data
7021: 
7022: volumes:
7023:   postgres_data:
7024: </file>
7025: 
7026: <file path="pom.xml">
7027: <?xml version="1.0" encoding="UTF-8"?>
7028: <project xmlns="http://maven.apache.org/POM/4.0.0"
7029:          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
7030:          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
7031:     <modelVersion>4.0.0</modelVersion>
7032: 
7033:     <parent>
7034:         <groupId>org.springframework.boot</groupId>
7035:         <artifactId>spring-boot-starter-parent</artifactId>
7036:         <version>3.2.0</version>
7037:         <relativePath/>
7038:     </parent>
7039: 
7040:     <groupId>com.bht</groupId>
7041:     <artifactId>ludonova</artifactId>
7042:     <version>0.0.1-SNAPSHOT</version>
7043:     <name>ludonova</name>
7044:     <description>Backend for LudoNova game backlog manager</description>
7045: 
7046:     <properties>
7047:         <java.version>17</java.version>
7048:         <jjwt.version>0.11.5</jjwt.version>
7049:     </properties>
7050: 
7051:     <dependencies>
7052:         <!-- Spring Boot Starters -->
7053:         <dependency>
7054:             <groupId>org.springframework.boot</groupId>
7055:             <artifactId>spring-boot-starter-web</artifactId>
7056:         </dependency>
7057:         <dependency>
7058:             <groupId>org.springframework.boot</groupId>
7059:             <artifactId>spring-boot-starter-security</artifactId>
7060:         </dependency>
7061:         <dependency>
7062:             <groupId>org.springframework.boot</groupId>
7063:             <artifactId>spring-boot-starter-data-jpa</artifactId>
7064:         </dependency>
7065:         <dependency>
7066:             <groupId>org.springframework.boot</groupId>
7067:             <artifactId>spring-boot-starter-validation</artifactId>
7068:         </dependency>
7069:         <dependency>
7070:             <groupId>org.springframework.boot</groupId>
7071:             <artifactId>spring-boot-starter-webflux</artifactId>
7072:         </dependency>
7073: 
7074:         <!-- Database -->
7075:         <dependency>
7076:             <groupId>org.postgresql</groupId>
7077:             <artifactId>postgresql</artifactId>
7078:             <scope>runtime</scope>
7079:         </dependency>
7080: 
7081:         <!-- JWT Dependencies -->
7082:         <dependency>
7083:             <groupId>io.jsonwebtoken</groupId>
7084:             <artifactId>jjwt-api</artifactId>
7085:             <version>${jjwt.version}</version>
7086:         </dependency>
7087:         <dependency>
7088:             <groupId>io.jsonwebtoken</groupId>
7089:             <artifactId>jjwt-impl</artifactId>
7090:             <version>${jjwt.version}</version>
7091:             <scope>runtime</scope>
7092:         </dependency>
7093:         <dependency>
7094:             <groupId>io.jsonwebtoken</groupId>
7095:             <artifactId>jjwt-jackson</artifactId>
7096:             <version>${jjwt.version}</version>
7097:             <scope>runtime</scope>
7098:         </dependency>
7099: 
7100:         <!-- Development Tools -->
7101:         <dependency>
7102:             <groupId>org.springframework.boot</groupId>
7103:             <artifactId>spring-boot-devtools</artifactId>
7104:             <scope>runtime</scope>
7105:             <optional>true</optional>
7106:         </dependency>
7107:         <dependency>
7108:             <groupId>org.projectlombok</groupId>
7109:             <artifactId>lombok</artifactId>
7110:             <optional>true</optional>
7111:         </dependency>
7112: 
7113:         <!-- Testing -->
7114:         <dependency>
7115:             <groupId>org.springframework.boot</groupId>
7116:             <artifactId>spring-boot-starter-test</artifactId>
7117:             <scope>test</scope>
7118:         </dependency>
7119:         <dependency>
7120:             <groupId>org.springframework.security</groupId>
7121:             <artifactId>spring-security-test</artifactId>
7122:             <scope>test</scope>
7123:         </dependency>
7124: 
7125:         <!-- Environment Variables -->
7126:         <dependency>
7127:             <groupId>me.paulschwarz</groupId>
7128:             <artifactId>spring-dotenv</artifactId>
7129:             <version>4.0.0</version>
7130:         </dependency>
7131:     </dependencies>
7132: 
7133:     <build>
7134:         <plugins>
7135:             <plugin>
7136:                 <groupId>org.springframework.boot</groupId>
7137:                 <artifactId>spring-boot-maven-plugin</artifactId>
7138:                 <configuration>
7139:                     <excludes>
7140:                         <exclude>
7141:                             <groupId>org.projectlombok</groupId>
7142:                             <artifactId>lombok</artifactId>
7143:                         </exclude>
7144:                     </excludes>
7145:                 </configuration>
7146:             </plugin>
7147:         </plugins>
7148:     </build>
7149: </project>
7150: </file>
7151: 
7152: <file path="README.md">
7153: # LudoNova Backend
7154: 
7155: Spring Boot backend for the LudoNova game backlog manager.
7156: 
7157: ## Prerequisites
7158: 
7159: - Java 17+
7160: - Maven
7161: - Docker and Docker Compose
7162: 
7163: ## Getting Started
7164: 
7165: 1. Clone the repository:
7166:    ```bash
7167:    git clone https://github.com/yourusername/ludonova-backend.git
7168:    ```
7169: 
7170: 2. Start the PostgreSQL database:
7171:    ```bash
7172:    docker-compose up -d
7173:    ```
7174: 
7175: 3. To stop and remove the container (but keep the data volume):
7176:    ```bash
7177:    docker-compose down
7178:    ```
7179: 
7180: 4. To remove everything including the volume:
7181:    ```bash
7182:    docker-compose down -v
7183:    ```
7184:    Remember that after a full reset, your database will be empty and you'll need to run your application to reinitialize it with any seed data (like the test user) defined in DataInitializer.java.
7185: 
7186: 4. Alternatively, if you just want to restart the container without stopping and recreating it:
7187:    ```bash
7188:    docker restart ludonova_db
7189:    ```
7190: 
7191: 5. Run the application:
7192:    ```bash
7193:    ./mvnw spring-boot:run
7194:    ```
7195: 
7196: ## API Documentation
7197: 
7198: The API documentation is available at http://localhost:8080/swagger-ui.html when running in development mode.
7199: 
7200: ## Database
7201: 
7202: The application uses PostgreSQL. The database schema is managed by JPA/Hibernate and will be created automatically on startup.
7203: 
7204: ## Testing
7205: 
7206: Run tests with:
7207: ```bash
7208: ./mvnw test
7209: ```
7210: ```
7211: </file>
7212: 
7213: <file path="setup.sh">
7214: #!/bin/bash
7215: 
7216: # Navigate to the backend directory
7217: cd ludonova-backend
7218: 
7219: # Create main directory structure
7220: mkdir -p src/main/java/com/bht/ludonova
7221: mkdir -p src/main/resources
7222: mkdir -p src/test/java/com/bht/ludonova
7223: mkdir -p src/test/resources
7224: 
7225: # Create package directories
7226: cd src/main/java/com/bht/ludonova
7227: mkdir config
7228: mkdir controller
7229: mkdir model
7230: mkdir repository
7231: mkdir service
7232: mkdir security
7233: mkdir dto
7234: mkdir exception
7235: 
7236: # Create application.properties
7237: cd ../../resources
7238: echo "# Server Configuration
7239: server.port=8080
7240: 
7241: # Database Configuration
7242: spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
7243: spring.datasource.username=postgres
7244: spring.datasource.password=postgres
7245: spring.jpa.hibernate.ddl-auto=update
7246: spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
7247: 
7248: # JWT Configuration
7249: jwt.secret=your-secret-key-here
7250: jwt.expiration=86400000
7251: 
7252: # CORS Configuration
7253: spring.web.cors.allowed-origins=http://localhost:3000
7254: spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
7255: spring.web.cors.allowed-headers=*
7256: 
7257: # Logging Configuration
7258: logging.level.com.bht.ludonova=DEBUG" > application.properties
7259: 
7260: # Create main application class
7261: cd ../java/com/bht/ludonova
7262: echo "package com.bht.ludonova;
7263: 
7264: import org.springframework.boot.SpringApplication;
7265: import org.springframework.boot.autoconfigure.SpringBootApplication;
7266: 
7267: @SpringBootApplication
7268: public class LudoNovaApplication {
7269:     public static void main(String[] args) {
7270:         SpringApplication.run(LudoNovaApplication.class, args);
7271:     }
7272: }" > LudoNovaApplication.java
7273: </file>
7274: 
7275: </repository_files>
7276: </file>
7277: 
7278: <file path="pom.xml">
7279: <?xml version="1.0" encoding="UTF-8"?>
7280: <project xmlns="http://maven.apache.org/POM/4.0.0"
7281:          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
7282:          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
7283:     <modelVersion>4.0.0</modelVersion>
7284: 
7285:     <parent>
7286:         <groupId>org.springframework.boot</groupId>
7287:         <artifactId>spring-boot-starter-parent</artifactId>
7288:         <version>3.2.0</version>
7289:         <relativePath/>
7290:     </parent>
7291: 
7292:     <groupId>com.bht</groupId>
7293:     <artifactId>ludonova</artifactId>
7294:     <version>0.0.1-SNAPSHOT</version>
7295:     <name>ludonova</name>
7296:     <description>Backend for LudoNova game backlog manager</description>
7297: 
7298:     <properties>
7299:         <java.version>17</java.version>
7300:         <jjwt.version>0.11.5</jjwt.version>
7301:     </properties>
7302: 
7303:     <dependencies>
7304:         <!-- Spring Boot Starters -->
7305:         <dependency>
7306:             <groupId>org.springframework.boot</groupId>
7307:             <artifactId>spring-boot-starter-web</artifactId>
7308:         </dependency>
7309:         <dependency>
7310:             <groupId>org.springframework.boot</groupId>
7311:             <artifactId>spring-boot-starter-security</artifactId>
7312:         </dependency>
7313:         <dependency>
7314:             <groupId>org.springframework.boot</groupId>
7315:             <artifactId>spring-boot-starter-data-jpa</artifactId>
7316:         </dependency>
7317:         <dependency>
7318:             <groupId>org.springframework.boot</groupId>
7319:             <artifactId>spring-boot-starter-validation</artifactId>
7320:         </dependency>
7321:         <dependency>
7322:             <groupId>org.springframework.boot</groupId>
7323:             <artifactId>spring-boot-starter-webflux</artifactId>
7324:         </dependency>
7325: 
7326:         <!-- Database -->
7327:         <dependency>
7328:             <groupId>org.postgresql</groupId>
7329:             <artifactId>postgresql</artifactId>
7330:             <scope>runtime</scope>
7331:         </dependency>
7332: 
7333:         <!-- JWT Dependencies -->
7334:         <dependency>
7335:             <groupId>io.jsonwebtoken</groupId>
7336:             <artifactId>jjwt-api</artifactId>
7337:             <version>${jjwt.version}</version>
7338:         </dependency>
7339:         <dependency>
7340:             <groupId>io.jsonwebtoken</groupId>
7341:             <artifactId>jjwt-impl</artifactId>
7342:             <version>${jjwt.version}</version>
7343:             <scope>runtime</scope>
7344:         </dependency>
7345:         <dependency>
7346:             <groupId>io.jsonwebtoken</groupId>
7347:             <artifactId>jjwt-jackson</artifactId>
7348:             <version>${jjwt.version}</version>
7349:             <scope>runtime</scope>
7350:         </dependency>
7351: 
7352:         <!-- Development Tools -->
7353:         <dependency>
7354:             <groupId>org.springframework.boot</groupId>
7355:             <artifactId>spring-boot-devtools</artifactId>
7356:             <scope>runtime</scope>
7357:             <optional>true</optional>
7358:         </dependency>
7359:         <dependency>
7360:             <groupId>org.projectlombok</groupId>
7361:             <artifactId>lombok</artifactId>
7362:             <optional>true</optional>
7363:         </dependency>
7364: 
7365:         <!-- Testing -->
7366:         <dependency>
7367:             <groupId>org.springframework.boot</groupId>
7368:             <artifactId>spring-boot-starter-test</artifactId>
7369:             <scope>test</scope>
7370:         </dependency>
7371:         <dependency>
7372:             <groupId>org.springframework.security</groupId>
7373:             <artifactId>spring-security-test</artifactId>
7374:             <scope>test</scope>
7375:         </dependency>
7376: 
7377:         <!-- Environment Variables -->
7378:         <dependency>
7379:             <groupId>me.paulschwarz</groupId>
7380:             <artifactId>spring-dotenv</artifactId>
7381:             <version>4.0.0</version>
7382:         </dependency>
7383:     </dependencies>
7384: 
7385:     <build>
7386:         <plugins>
7387:             <plugin>
7388:                 <groupId>org.springframework.boot</groupId>
7389:                 <artifactId>spring-boot-maven-plugin</artifactId>
7390:                 <configuration>
7391:                     <excludes>
7392:                         <exclude>
7393:                             <groupId>org.projectlombok</groupId>
7394:                             <artifactId>lombok</artifactId>
7395:                         </exclude>
7396:                     </excludes>
7397:                 </configuration>
7398:             </plugin>
7399:         </plugins>
7400:     </build>
7401: </project>
7402: </file>
7403: 
7404: <file path="README.md">
7405: # LudoNova Backend
7406: 
7407: Spring Boot backend for the LudoNova game backlog manager.
7408: 
7409: ## Prerequisites
7410: 
7411: - Java 17+
7412: - Maven
7413: - Docker and Docker Compose
7414: 
7415: ## Getting Started
7416: 
7417: 1. Clone the repository:
7418:    ```bash
7419:    git clone https://github.com/yourusername/ludonova-backend.git
7420:    ```
7421: 
7422: 2. Start the PostgreSQL database:
7423:    ```bash
7424:    docker-compose up -d
7425:    ```
7426: 
7427: 3. To stop and remove the container (but keep the data volume):
7428:    ```bash
7429:    docker-compose down
7430:    ```
7431: 
7432: 4. To remove everything including the volume:
7433:    ```bash
7434:    docker-compose down -v
7435:    ```
7436:    Remember that after a full reset, your database will be empty and you'll need to run your application to reinitialize it with any seed data (like the test user) defined in DataInitializer.java.
7437: 
7438: 4. Alternatively, if you just want to restart the container without stopping and recreating it:
7439:    ```bash
7440:    docker restart ludonova_db
7441:    ```
7442: 
7443: 5. Run the application:
7444:    ```bash
7445:    ./mvnw spring-boot:run
7446:    ```
7447: 
7448: ## API Documentation
7449: 
7450: The API documentation is available at http://localhost:8080/swagger-ui.html when running in development mode.
7451: 
7452: ## Database
7453: 
7454: The application uses PostgreSQL. The database schema is managed by JPA/Hibernate and will be created automatically on startup.
7455: 
7456: ## Testing
7457: 
7458: Run tests with:
7459: ```bash
7460: ./mvnw test
7461: ```
7462: ```
7463: </file>
7464: 
7465: <file path="setup.sh">
7466: #!/bin/bash
7467: 
7468: # Navigate to the backend directory
7469: cd ludonova-backend
7470: 
7471: # Create main directory structure
7472: mkdir -p src/main/java/com/bht/ludonova
7473: mkdir -p src/main/resources
7474: mkdir -p src/test/java/com/bht/ludonova
7475: mkdir -p src/test/resources
7476: 
7477: # Create package directories
7478: cd src/main/java/com/bht/ludonova
7479: mkdir config
7480: mkdir controller
7481: mkdir model
7482: mkdir repository
7483: mkdir service
7484: mkdir security
7485: mkdir dto
7486: mkdir exception
7487: 
7488: # Create application.properties
7489: cd ../../resources
7490: echo "# Server Configuration
7491: server.port=8080
7492: 
7493: # Database Configuration
7494: spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
7495: spring.datasource.username=postgres
7496: spring.datasource.password=postgres
7497: spring.jpa.hibernate.ddl-auto=update
7498: spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
7499: 
7500: # JWT Configuration
7501: jwt.secret=your-secret-key-here
7502: jwt.expiration=86400000
7503: 
7504: # CORS Configuration
7505: spring.web.cors.allowed-origins=http://localhost:3000
7506: spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
7507: spring.web.cors.allowed-headers=*
7508: 
7509: # Logging Configuration
7510: logging.level.com.bht.ludonova=DEBUG" > application.properties
7511: 
7512: # Create main application class
7513: cd ../java/com/bht/ludonova
7514: echo "package com.bht.ludonova;
7515: 
7516: import org.springframework.boot.SpringApplication;
7517: import org.springframework.boot.autoconfigure.SpringBootApplication;
7518: 
7519: @SpringBootApplication
7520: public class LudoNovaApplication {
7521:     public static void main(String[] args) {
7522:         SpringApplication.run(LudoNovaApplication.class, args);
7523:     }
7524: }" > LudoNovaApplication.java
7525: </file>
7526: 
7527: </repository_files>
7528: ```
7529: 
7530: ## File: pom.xml
7531: ```xml
7532: <?xml version="1.0" encoding="UTF-8"?>
7533: <project xmlns="http://maven.apache.org/POM/4.0.0"
7534:          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
7535:          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
7536:     <modelVersion>4.0.0</modelVersion>
7537: 
7538:     <parent>
7539:         <groupId>org.springframework.boot</groupId>
7540:         <artifactId>spring-boot-starter-parent</artifactId>
7541:         <version>3.2.0</version>
7542:         <relativePath/>
7543:     </parent>
7544: 
7545:     <groupId>com.bht</groupId>
7546:     <artifactId>ludonova</artifactId>
7547:     <version>0.0.1-SNAPSHOT</version>
7548:     <name>ludonova</name>
7549:     <description>Backend for LudoNova game backlog manager</description>
7550: 
7551:     <properties>
7552:         <java.version>17</java.version>
7553:         <jjwt.version>0.11.5</jjwt.version>
7554:     </properties>
7555: 
7556:     <dependencies>
7557:         <!-- Spring Boot Starters -->
7558:         <dependency>
7559:             <groupId>org.springframework.boot</groupId>
7560:             <artifactId>spring-boot-starter-web</artifactId>
7561:         </dependency>
7562:         <dependency>
7563:             <groupId>org.springframework.boot</groupId>
7564:             <artifactId>spring-boot-starter-security</artifactId>
7565:         </dependency>
7566:         <dependency>
7567:             <groupId>org.springframework.boot</groupId>
7568:             <artifactId>spring-boot-starter-data-jpa</artifactId>
7569:         </dependency>
7570:         <dependency>
7571:             <groupId>org.springframework.boot</groupId>
7572:             <artifactId>spring-boot-starter-validation</artifactId>
7573:         </dependency>
7574:         <dependency>
7575:             <groupId>org.springframework.boot</groupId>
7576:             <artifactId>spring-boot-starter-webflux</artifactId>
7577:         </dependency>
7578: 
7579:         <!-- Database -->
7580:         <dependency>
7581:             <groupId>org.postgresql</groupId>
7582:             <artifactId>postgresql</artifactId>
7583:             <scope>runtime</scope>
7584:         </dependency>
7585: 
7586:         <!-- JWT Dependencies -->
7587:         <dependency>
7588:             <groupId>io.jsonwebtoken</groupId>
7589:             <artifactId>jjwt-api</artifactId>
7590:             <version>${jjwt.version}</version>
7591:         </dependency>
7592:         <dependency>
7593:             <groupId>io.jsonwebtoken</groupId>
7594:             <artifactId>jjwt-impl</artifactId>
7595:             <version>${jjwt.version}</version>
7596:             <scope>runtime</scope>
7597:         </dependency>
7598:         <dependency>
7599:             <groupId>io.jsonwebtoken</groupId>
7600:             <artifactId>jjwt-jackson</artifactId>
7601:             <version>${jjwt.version}</version>
7602:             <scope>runtime</scope>
7603:         </dependency>
7604: 
7605:         <!-- Development Tools -->
7606:         <dependency>
7607:             <groupId>org.springframework.boot</groupId>
7608:             <artifactId>spring-boot-devtools</artifactId>
7609:             <scope>runtime</scope>
7610:             <optional>true</optional>
7611:         </dependency>
7612:         <dependency>
7613:             <groupId>org.projectlombok</groupId>
7614:             <artifactId>lombok</artifactId>
7615:             <optional>true</optional>
7616:         </dependency>
7617: 
7618:         <!-- Testing -->
7619:         <dependency>
7620:             <groupId>org.springframework.boot</groupId>
7621:             <artifactId>spring-boot-starter-test</artifactId>
7622:             <scope>test</scope>
7623:         </dependency>
7624:         <dependency>
7625:             <groupId>org.springframework.security</groupId>
7626:             <artifactId>spring-security-test</artifactId>
7627:             <scope>test</scope>
7628:         </dependency>
7629: 
7630:         <!-- DataBase Migration with Flyway -->
7631:         <dependency>
7632:             <groupId>org.flywaydb</groupId>
7633:             <artifactId>flyway-core</artifactId>
7634:         </dependency>
7635: 
7636:         <!-- Environment Variables -->
7637:         <dependency>
7638:             <groupId>me.paulschwarz</groupId>
7639:             <artifactId>spring-dotenv</artifactId>
7640:             <version>4.0.0</version>
7641:         </dependency>
7642: 
7643:         <!-- Swagger/OpenAPI -->
7644:         <dependency>
7645:             <groupId>org.springdoc</groupId>
7646:             <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
7647:             <version>2.3.0</version>
7648:         </dependency>
7649:     </dependencies>
7650: 
7651:     <build>
7652:         <plugins>
7653:             <plugin>
7654:                 <groupId>org.springframework.boot</groupId>
7655:                 <artifactId>spring-boot-maven-plugin</artifactId>
7656:                 <configuration>
7657:                     <excludes>
7658:                         <exclude>
7659:                             <groupId>org.projectlombok</groupId>
7660:                             <artifactId>lombok</artifactId>
7661:                         </exclude>
7662:                     </excludes>
7663:                 </configuration>
7664:             </plugin>
7665:             <plugin>
7666:                 <groupId>org.flywaydb</groupId>
7667:                 <artifactId>flyway-maven-plugin</artifactId>
7668:                 <version>9.22.3</version>
7669:                 <configuration>
7670:                     <url>jdbc:postgresql://localhost:5432/ludonova</url>
7671:                     <user>postgres</user>
7672:                     <password>postgres</password>
7673:                 </configuration>
7674:             </plugin>
7675:         </plugins>
7676:     </build>
7677: </project>
7678: ```
7679: 
7680: ## File: README.md
7681: ```markdown
7682: # LudoNova Backend
7683: 
7684: Spring Boot backend for the LudoNova game backlog manager.
7685: 
7686: ## Prerequisites
7687: 
7688: - Java 17+
7689: - Maven
7690: - Docker and Docker Compose
7691: 
7692: ## Getting Started
7693: 
7694: 1. Clone the repository:
7695:    ```bash
7696:    git clone https://github.com/yourusername/ludonova-backend.git
7697:    ```
7698: 
7699: 2. Start the PostgreSQL database:
7700:    ```bash
7701:    docker-compose up -d
7702:    ```
7703: 
7704: 3. To stop and remove the container (but keep the data volume):
7705:    ```bash
7706:    docker-compose down
7707:    ```
7708: 
7709: 4. To remove everything including the volume:
7710:    ```bash
7711:    docker-compose down -v
7712:    ```
7713:    Remember that after a full reset, your database will be empty and you'll need to run your application to reinitialize it with any seed data (like the test user) defined in DataInitializer.java.
7714: 
7715: 4. Alternatively, if you just want to restart the container without stopping and recreating it:
7716:    ```bash
7717:    docker restart ludonova_db
7718:    ```
7719: 
7720: 5. Run the application:
7721:    ```bash
7722:    ./mvnw spring-boot:run
7723:    ```
7724: 
7725: ## API Documentation
7726: 
7727: The API documentation is available at http://localhost:8080/swagger-ui.html when running in development mode.
7728: 
7729: ## Database
7730: 
7731: The application uses PostgreSQL. The database schema is managed by JPA/Hibernate and will be created automatically on startup.
7732: 
7733: ## Testing
7734: 
7735: Run tests with:
7736: ```bash
7737: ./mvnw test
7738: ```
7739: ```
7740: ```
7741: 
7742: ## File: setup.sh
7743: ```bash
7744: #!/bin/bash
7745: 
7746: # Navigate to the backend directory
7747: cd ludonova-backend
7748: 
7749: # Create main directory structure
7750: mkdir -p src/main/java/com/bht/ludonova
7751: mkdir -p src/main/resources
7752: mkdir -p src/test/java/com/bht/ludonova
7753: mkdir -p src/test/resources
7754: 
7755: # Create package directories
7756: cd src/main/java/com/bht/ludonova
7757: mkdir config
7758: mkdir controller
7759: mkdir model
7760: mkdir repository
7761: mkdir service
7762: mkdir security
7763: mkdir dto
7764: mkdir exception
7765: 
7766: # Create application.properties
7767: cd ../../resources
7768: echo "# Server Configuration
7769: server.port=8080
7770: 
7771: # Database Configuration
7772: spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
7773: spring.datasource.username=postgres
7774: spring.datasource.password=postgres
7775: spring.jpa.hibernate.ddl-auto=update
7776: spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
7777: 
7778: # JWT Configuration
7779: jwt.secret=your-secret-key-here
7780: jwt.expiration=86400000
7781: 
7782: # CORS Configuration
7783: spring.web.cors.allowed-origins=http://localhost:3000
7784: spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
7785: spring.web.cors.allowed-headers=*
7786: 
7787: # Logging Configuration
7788: logging.level.com.bht.ludonova=DEBUG" > application.properties
7789: 
7790: # Create main application class
7791: cd ../java/com/bht/ludonova
7792: echo "package com.bht.ludonova;
7793: 
7794: import org.springframework.boot.SpringApplication;
7795: import org.springframework.boot.autoconfigure.SpringBootApplication;
7796: 
7797: @SpringBootApplication
7798: public class LudoNovaApplication {
7799:     public static void main(String[] args) {
7800:         SpringApplication.run(LudoNovaApplication.class, args);
7801:     }
7802: }" > LudoNovaApplication.java
7803: ```
</file>

<file path="pom.xml">
  1: <?xml version="1.0" encoding="UTF-8"?>
  2: <project xmlns="http://maven.apache.org/POM/4.0.0"
  3:          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  4:          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  5:     <modelVersion>4.0.0</modelVersion>
  6:     <parent>
  7:         <groupId>org.springframework.boot</groupId>
  8:         <artifactId>spring-boot-starter-parent</artifactId>
  9:         <version>3.2.0</version>
 10:         <relativePath/>
 11:     </parent>
 12:     <groupId>com.bht</groupId>
 13:     <artifactId>ludonova</artifactId>
 14:     <version>0.0.1-SNAPSHOT</version>
 15:     <name>ludonova</name>
 16:     <description>Backend for LudoNova game backlog manager</description>
 17:     <properties>
 18:         <java.version>17</java.version>
 19:         <jjwt.version>0.11.5</jjwt.version>
 20:     </properties>
 21:     <dependencies>
 22:         <dependency>
 23:             <groupId>org.springframework.boot</groupId>
 24:             <artifactId>spring-boot-starter-web</artifactId>
 25:         </dependency>
 26:         <dependency>
 27:             <groupId>org.springframework.boot</groupId>
 28:             <artifactId>spring-boot-starter-security</artifactId>
 29:         </dependency>
 30:         <dependency>
 31:             <groupId>org.springframework.boot</groupId>
 32:             <artifactId>spring-boot-starter-data-jpa</artifactId>
 33:         </dependency>
 34:         <dependency>
 35:             <groupId>org.springframework.boot</groupId>
 36:             <artifactId>spring-boot-starter-validation</artifactId>
 37:         </dependency>
 38:         <dependency>
 39:             <groupId>org.springframework.boot</groupId>
 40:             <artifactId>spring-boot-starter-webflux</artifactId>
 41:         </dependency>
 42:         <dependency>
 43:             <groupId>org.postgresql</groupId>
 44:             <artifactId>postgresql</artifactId>
 45:             <scope>runtime</scope>
 46:         </dependency>
 47:         <dependency>
 48:             <groupId>io.jsonwebtoken</groupId>
 49:             <artifactId>jjwt-api</artifactId>
 50:             <version>${jjwt.version}</version>
 51:         </dependency>
 52:         <dependency>
 53:             <groupId>io.jsonwebtoken</groupId>
 54:             <artifactId>jjwt-impl</artifactId>
 55:             <version>${jjwt.version}</version>
 56:             <scope>runtime</scope>
 57:         </dependency>
 58:         <dependency>
 59:             <groupId>io.jsonwebtoken</groupId>
 60:             <artifactId>jjwt-jackson</artifactId>
 61:             <version>${jjwt.version}</version>
 62:             <scope>runtime</scope>
 63:         </dependency>
 64:         <dependency>
 65:             <groupId>org.springframework.boot</groupId>
 66:             <artifactId>spring-boot-devtools</artifactId>
 67:             <scope>runtime</scope>
 68:             <optional>true</optional>
 69:         </dependency>
 70:         <dependency>
 71:             <groupId>org.projectlombok</groupId>
 72:             <artifactId>lombok</artifactId>
 73:             <optional>true</optional>
 74:         </dependency>
 75:         <dependency>
 76:             <groupId>org.springframework.boot</groupId>
 77:             <artifactId>spring-boot-starter-test</artifactId>
 78:             <scope>test</scope>
 79:         </dependency>
 80:         <dependency>
 81:             <groupId>org.springframework.security</groupId>
 82:             <artifactId>spring-security-test</artifactId>
 83:             <scope>test</scope>
 84:         </dependency>
 85:         <dependency>
 86:             <groupId>org.flywaydb</groupId>
 87:             <artifactId>flyway-core</artifactId>
 88:         </dependency>
 89:         <dependency>
 90:             <groupId>me.paulschwarz</groupId>
 91:             <artifactId>spring-dotenv</artifactId>
 92:             <version>4.0.0</version>
 93:         </dependency>
 94:         <dependency>
 95:             <groupId>org.springdoc</groupId>
 96:             <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
 97:             <version>2.3.0</version>
 98:         </dependency>
 99:         <dependency>
100:             <groupId>org.springframework.boot</groupId>
101:             <artifactId>spring-boot-starter-cache</artifactId>
102:         </dependency>
103:     </dependencies>
104:     <build>
105:         <plugins>
106:             <plugin>
107:                 <groupId>org.springframework.boot</groupId>
108:                 <artifactId>spring-boot-maven-plugin</artifactId>
109:                 <configuration>
110:                     <excludes>
111:                         <exclude>
112:                             <groupId>org.projectlombok</groupId>
113:                             <artifactId>lombok</artifactId>
114:                         </exclude>
115:                     </excludes>
116:                 </configuration>
117:             </plugin>
118:             <plugin>
119:                 <groupId>org.flywaydb</groupId>
120:                 <artifactId>flyway-maven-plugin</artifactId>
121:                 <version>9.22.3</version>
122:                 <configuration>
123:                     <url>jdbc:postgresql://localhost:5432/ludonova</url>
124:                     <user>postgres</user>
125:                     <password>postgres</password>
126:                 </configuration>
127:             </plugin>
128:         </plugins>
129:     </build>
130: </project>
</file>

<file path="README.md">
 1: # LudoNova Backend
 2: 
 3: Spring Boot backend for the LudoNova game backlog manager.
 4: 
 5: ## Prerequisites
 6: 
 7: - Java 17+
 8: - Maven
 9: - Docker and Docker Compose
10: 
11: ## Getting Started
12: 
13: 1. Clone the repository:
14:    ```bash
15:    git clone https://github.com/yourusername/ludonova-backend.git
16:    ```
17: 
18: 2. Start the PostgreSQL database:
19:    ```bash
20:    docker-compose up -d
21:    ```
22: 
23: 3. To stop and remove the container (but keep the data volume):
24:    ```bash
25:    docker-compose down
26:    ```
27: 
28: 4. To remove everything including the volume:
29:    ```bash
30:    docker-compose down -v
31:    ```
32:    Remember that after a full reset, your database will be empty and you'll need to run your application to reinitialize it with any seed data (like the test user) defined in DataInitializer.java.
33: 
34: 4. Alternatively, if you just want to restart the container without stopping and recreating it:
35:    ```bash
36:    docker restart ludonova_db
37:    ```
38: 
39: 5. Run the application:
40:    ```bash
41:    ./mvnw spring-boot:run
42:    ```
43: 
44: ## API Documentation
45: 
46: The API documentation is available at http://localhost:8080/swagger-ui.html when running in development mode.
47: 
48: ## Database
49: 
50: The application uses PostgreSQL. The database schema is managed by JPA/Hibernate and will be created automatically on startup.
51: 
52: ## Testing
53: 
54: Run tests with:
55: ```bash
56: ./mvnw test
57: ```
58: 
59: ## Development Setup
60: ### SSL Certificate
61: 1. Generate a self-signed certificate:
62: ```bash
63: keytool -genkeypair -alias ludonova -keyalg RSA -keysize 2048 -storetype PKCS12 -keystore ludonova.p12 -validity 365
64: ```
</file>

<file path="setup.sh">
 1: cd ludonova-backend
 2: mkdir -p src/main/java/com/bht/ludonova
 3: mkdir -p src/main/resources
 4: mkdir -p src/test/java/com/bht/ludonova
 5: mkdir -p src/test/resources
 6: cd src/main/java/com/bht/ludonova
 7: mkdir config
 8: mkdir controller
 9: mkdir model
10: mkdir repository
11: mkdir service
12: mkdir security
13: mkdir dto
14: mkdir exception
15: cd ../../resources
16: echo "# Server Configuration
17: server.port=8080
18: # Database Configuration
19: spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
20: spring.datasource.username=postgres
21: spring.datasource.password=postgres
22: spring.jpa.hibernate.ddl-auto=update
23: spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
24: # JWT Configuration
25: jwt.secret=your-secret-key-here
26: jwt.expiration=86400000
27: # CORS Configuration
28: spring.web.cors.allowed-origins=http://localhost:3000
29: spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
30: spring.web.cors.allowed-headers=*
31: # Logging Configuration
32: logging.level.com.bht.ludonova=DEBUG" > application.properties
33: cd ../java/com/bht/ludonova
34: echo "package com.bht.ludonova;
35: import org.springframework.boot.SpringApplication;
36: import org.springframework.boot.autoconfigure.SpringBootApplication;
37: @SpringBootApplication
38: public class LudoNovaApplication {
39:     public static void main(String[] args) {
40:         SpringApplication.run(LudoNovaApplication.class, args);
41:     }
42: }" > LudoNovaApplication.java
</file>

</files>
