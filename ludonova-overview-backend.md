This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-23T18:56:12.127Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Info

For more information about Repomix, visit: https://github.com/yamadashy/repomix

# Repository Structure
```
src/
  main/
    java/
      com/
        bht/
          ludonova/
            config/
              DataInitializer.java
              OpenAPIConfig.java
              WebConfig.java
            controller/
              AuthController.java
              GameController.java
              GameInstanceController.java
              SteamAuthController.java
              UserController.java
            dto/
              auth/
                AuthenticationResponse.java
                LoginRequest.java
                RefreshTokenRequest.java
                TokenResponse.java
              game/
                AdminGameUpdateDTO.java
                GameInstanceUpdateDTO.java
                GameUpdateDTO.java
              steam/
                SteamApiResponseDTO.java
                SteamAuthRequest.java
                SteamUserDTO.java
              user/
                CreateUserDTO.java
                UserDTO.java
                UserUpdateDTO.java
              ErrorResponse.java
            exception/
              AuthenticationException.java
              GlobalExceptionHandler.java
              LudoNovaException.java
              SteamAuthenticationException.java
              UnauthorizedException.java
            model/
              enums/
                GameSource.java
                GameStatus.java
                Platform.java
                Role.java
              Game.java
              GameInstance.java
              Review.java
              SteamUser.java
              User.java
            repository/
              GameInstanceRepository.java
              GameRepository.java
              ReviewRepository.java
              UserRepository.java
            security/
              AuthenticationExceptionHandler.java
              CustomUserDetailsService.java
              JwtAuthenticationFilter.java
              JwtTokenProvider.java
              SecurityConfig.java
            service/
              auth/
                AuthenticationStrategy.java
                BasicAuthenticationStrategy.java
                SteamAuthenticationStrategy.java
              AuthenticationService.java
              GameInstanceService.java
              GameService.java
              SteamService.java
              UserService.java
            LudoNovaApplication.java
    resources/
      db/
        migration/
          V1__create_base_schema.sql
      application.properties
.env.example
.gitignore
docker-compose.yml
ludonova-overview-backend.md
pom.xml
README.md
setup.sh
```

# Repository Files

## File: src/main/java/com/bht/ludonova/config/DataInitializer.java
```java
package com.bht.ludonova.config;

import com.bht.ludonova.model.Game;
import com.bht.ludonova.model.GameInstance;
import com.bht.ludonova.model.User;
import com.bht.ludonova.model.enums.GameSource;
import com.bht.ludonova.model.enums.GameStatus;
import com.bht.ludonova.model.enums.Platform;
import com.bht.ludonova.model.enums.Role;
import com.bht.ludonova.repository.GameInstanceRepository;
import com.bht.ludonova.repository.GameRepository;
import com.bht.ludonova.repository.UserRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;

@Configuration
public class DataInitializer {
    private static final Logger log = LoggerFactory.getLogger(DataInitializer.class);

    @Bean
    CommandLineRunner initDatabase(
            UserRepository userRepository,
            GameRepository gameRepository,
            GameInstanceRepository gameInstanceRepository,
            PasswordEncoder passwordEncoder
    ) {
        return args -> {
            // Create regular test user if doesn't exist
            User testUser;
            if (userRepository.findByUsername("test").isEmpty()) {
                testUser = User.builder()
                        .username("test")
                        .password(passwordEncoder.encode("test123"))
                        .email("test@example.com")
                        .role(Role.USER)
                        .build();
                testUser = userRepository.save(testUser);
                log.info("Test user created successfully");
            } else {
                testUser = userRepository.findByUsername("test").get();
            }

            // Create admin user if doesn't exist
            if (userRepository.findByUsername("admin").isEmpty()) {
                User adminUser = User.builder()
                        .username("admin")
                        .password(passwordEncoder.encode("admin123"))
                        .email("admin@example.com")
                        .role(Role.ADMIN)
                        .build();
                userRepository.save(adminUser);
                log.info("Admin user created successfully");
            }

            // Find or create test game
            Game testGame;
            List<Game> existingGames = gameRepository.findAllByApiIdAndSource("220", GameSource.STEAM);
            if (existingGames.isEmpty()) {
                testGame = Game.builder()
                        .title("Half-Life 2")
                        .platform(Platform.PC)
                        .apiId("220")
                        .source(GameSource.STEAM)
                        .releaseDate(LocalDate.of(2004, 11, 16))
                        .genres(Set.of("FPS", "Action", "Sci-Fi"))
                        .build();
                testGame = gameRepository.save(testGame);
                log.info("Test game created successfully");
            } else {
                testGame = existingGames.get(0);
                log.debug("Using existing test game");
            }

            // Create game instance for test user if it doesn't exist
            if (!gameInstanceRepository.existsByUserIdAndGameId(testUser.getId(), testGame.getId())) {
                GameInstance instance = GameInstance.builder()
                        .user(testUser)
                        .game(testGame)
                        .status(GameStatus.PLAYING)
                        .progressPercentage(0)
                        .playTime(0)
                        .lastPlayed(LocalDateTime.now())
                        .notes("Just started playing")
                        .build();
                gameInstanceRepository.save(instance);
                log.info("Test game instance created successfully");
            } else {
                log.debug("Test game instance already exists");
            }
        };
    }
}
```

## File: src/main/java/com/bht/ludonova/config/OpenAPIConfig.java
```java
package com.bht.ludonova.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenAPIConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("LudoNova API")
                        .version("1.0")
                        .description("API documentation for LudoNova game tracking application")
                        .license(new License().name("Private").url("https://ludonova.com")))
                .components(new Components()
                        .addSecuritySchemes("bearer-jwt", new SecurityScheme()
                                .type(SecurityScheme.Type.HTTP)
                                .scheme("bearer")
                                .bearerFormat("JWT")));
    }
}
```

## File: src/main/java/com/bht/ludonova/config/WebConfig.java
```java
package com.bht.ludonova.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
public class WebConfig {

    @Value("${cors.allowed-origins}")
    private List<String> allowedOrigins;

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(allowedOrigins);
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        configuration.setAllowedHeaders(List.of(
                "Authorization",
                "Content-Type",
                "X-Requested-With",
                "Accept",
                "Origin",
                "Access-Control-Request-Method",
                "Access-Control-Request-Headers"
        ));
        configuration.setExposedHeaders(List.of(
                "Access-Control-Allow-Origin",
                "Access-Control-Allow-Credentials"
        ));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", configuration);
        return source;
    }
}
```

## File: src/main/java/com/bht/ludonova/controller/AuthController.java
```java
package com.bht.ludonova.controller;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.RefreshTokenRequest;
import com.bht.ludonova.dto.auth.LoginRequest;
import com.bht.ludonova.exception.AuthenticationException;
import com.bht.ludonova.service.AuthenticationService;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/auth")
@Slf4j
public class AuthController {
    private final AuthenticationService authService;

    public AuthController(AuthenticationService authService) {
        this.authService = authService;
    }

    @PostMapping("/login")
    public ResponseEntity<AuthenticationResponse> login(@Valid @RequestBody LoginRequest loginRequest) {
        Map<String, String> credentials = Map.of(
                "username", loginRequest.getUsername(),
                "password", loginRequest.getPassword()
        );

        AuthenticationResponse response = authService.authenticate("basic", credentials);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/refresh")
    public ResponseEntity<AuthenticationResponse> refresh(@Valid @RequestBody RefreshTokenRequest request) {
        log.debug("Received refresh token request with token: {}", request.getRefreshToken());
        try {
            AuthenticationResponse response = authService.refresh(request.getRefreshToken());
            return ResponseEntity.ok(response);
        } catch (AuthenticationException e) {
            log.error("Failed to refresh token", e);
            throw new AuthenticationException("Invalid refresh token");
        }
    }
}
```

## File: src/main/java/com/bht/ludonova/controller/GameController.java
```java
package com.bht.ludonova.controller;

import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import com.bht.ludonova.model.Game;
import com.bht.ludonova.model.enums.Platform;
import com.bht.ludonova.service.GameService;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/games")
@RequiredArgsConstructor
@Tag(name = "Games", description = "API for managing games") // Tag for Swagger grouping
public class GameController {
    private final GameService gameService;

    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public List<Game> getAllGames() {
        return gameService.findAll();
    }

    @GetMapping("/{id}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Game> getGame(@PathVariable Long id) {
        return gameService.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/platform/{platform}")
    @PreAuthorize("isAuthenticated()")
    public List<Game> getGamesByPlatform(@PathVariable Platform platform) {
        return gameService.findByPlatform(platform);
    }

    @PostMapping
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public ResponseEntity<Game> createGame(@RequestBody Game game) {
        return ResponseEntity.ok(gameService.save(game));
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public ResponseEntity<Game> updateGame(@PathVariable Long id, @RequestBody Game game) {
        if (!id.equals(game.getId())) {
            return ResponseEntity.badRequest().build();
        }
        return ResponseEntity.ok(gameService.save(game));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public ResponseEntity<Void> deleteGame(@PathVariable Long id) {
        gameService.deleteById(id);
        return ResponseEntity.noContent().build();
    }
}
```

## File: src/main/java/com/bht/ludonova/controller/GameInstanceController.java
```java
package com.bht.ludonova.controller;

import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.bht.ludonova.model.GameInstance;
import com.bht.ludonova.model.enums.GameStatus;
import com.bht.ludonova.service.GameInstanceService;

import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/game-instances")
@RequiredArgsConstructor
public class GameInstanceController {
    private final GameInstanceService gameInstanceService;

    @GetMapping("/user/{userId}")
    public List<GameInstance> getUserGameInstances(@PathVariable Long userId) {
        return gameInstanceService.findByUserId(userId);
    }

    @GetMapping("/user/{userId}/status/{status}")
    public List<GameInstance> getUserGameInstancesByStatus(
            @PathVariable Long userId,
            @PathVariable GameStatus status) {
        return gameInstanceService.findByUserIdAndStatus(userId, status);
    }

    @PostMapping
    public ResponseEntity<GameInstance> createGameInstance(@RequestBody GameInstance gameInstance) {
        return ResponseEntity.ok(gameInstanceService.save(gameInstance));
    }

    @PutMapping("/{id}")
    public ResponseEntity<GameInstance> updateGameInstance(
            @PathVariable Long id,
            @RequestBody GameInstance gameInstance) {
        if (!id.equals(gameInstance.getId())) {
            return ResponseEntity.badRequest().build();
        }
        return ResponseEntity.ok(gameInstanceService.save(gameInstance));
    }

    @PatchMapping("/{id}/status")
    public ResponseEntity<Void> updateGameStatus(
            @PathVariable Long id,
            @RequestParam GameStatus status) {
        gameInstanceService.updateStatus(id, status);
        return ResponseEntity.ok().build();
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteGameInstance(@PathVariable Long id) {
        gameInstanceService.deleteById(id);
        return ResponseEntity.noContent().build();
    }
}
```

## File: src/main/java/com/bht/ludonova/controller/SteamAuthController.java
```java
package com.bht.ludonova.controller;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.exception.SteamAuthenticationException;
import com.bht.ludonova.service.AuthenticationService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Map;

@RestController
@RequestMapping("/api/auth/steam")
@Slf4j
public class SteamAuthController {
    private final AuthenticationService authService;

    @Value("${steam.return.url}")
    private String returnUrl;

    @Value("${steam.realm.url}")
    private String realmUrl;

    public SteamAuthController(AuthenticationService authService) {
        this.authService = authService;
    }

    @GetMapping("/login")
    public ResponseEntity<Map<String, String>> steamLogin() {
        try {
            String steamOpenIdUrl = buildSteamOpenIdUrl();
            return ResponseEntity.ok(Map.of("url", steamOpenIdUrl));
        } catch (Exception e) {
            log.error("Error generating Steam login URL", e);
            throw new SteamAuthenticationException("Failed to generate Steam login URL");
        }
    }

    @GetMapping("/return")
    public ResponseEntity<AuthenticationResponse> steamReturn(@RequestParam Map<String, String> params) {
        log.debug("Received Steam return params: {}", params);
        AuthenticationResponse response = authService.authenticate("steam", params);
        return ResponseEntity.ok(response);
    }

    private String buildSteamOpenIdUrl() {
        try {
            String encodedReturnUrl = URLEncoder.encode(returnUrl, StandardCharsets.UTF_8);
            String encodedRealm = URLEncoder.encode(realmUrl, StandardCharsets.UTF_8);

            return String.format(
                    "https://steamcommunity.com/openid/login" +
                            "?openid.ns=%s" +
                            "&openid.mode=checkid_setup" +
                            "&openid.return_to=%s" +
                            "&openid.realm=%s" +
                            "&openid.identity=%s" +
                            "&openid.claimed_id=%s",
                    URLEncoder.encode("http://specs.openid.net/auth/2.0", StandardCharsets.UTF_8),
                    encodedReturnUrl,
                    encodedRealm,
                    URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8),
                    URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8)
            );
        } catch (Exception e) {
            log.error("Error building Steam OpenID URL", e);
            throw new SteamAuthenticationException("Failed to build Steam authentication URL");
        }
    }
}
```

## File: src/main/java/com/bht/ludonova/controller/UserController.java
```java
package com.bht.ludonova.controller;

import com.bht.ludonova.dto.ErrorResponse;
import com.bht.ludonova.dto.user.CreateUserDTO;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.dto.user.UserUpdateDTO;
import com.bht.ludonova.model.User;
import com.bht.ludonova.model.enums.Role;
import com.bht.ludonova.repository.UserRepository;
import com.bht.ludonova.service.UserService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/user")
public class UserController {

    private final UserRepository userRepository;
    private final UserService userService;

    @Autowired
    public UserController(UserRepository userRepository, UserService userService) {
        this.userRepository = userRepository;
        this.userService = userService;
    }



    // Get current user's profile
    @GetMapping("/current")
    public ResponseEntity<User> getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
        return userRepository.findByUsername(userDetails.getUsername())
                .map(user -> {
                    user.setPassword(null);
                    return ResponseEntity.ok(user);
                })
                .orElse(ResponseEntity.notFound().build());
    }

    // Update current user's profile
    @PutMapping("/current")
    public ResponseEntity<User> updateCurrentUser(
            @AuthenticationPrincipal UserDetails userDetails,
            @RequestBody UserUpdateDTO updateDTO) {
        return userRepository.findByUsername(userDetails.getUsername())
                .map(user -> {
                    if (updateDTO.getEmail() != null) {
                        user.setEmail(updateDTO.getEmail());
                    }
                    // Don't allow role updates through this endpoint
                    User updatedUser = userRepository.save(user);
                    updatedUser.setPassword(null);
                    return ResponseEntity.ok(updatedUser);
                })
                .orElse(ResponseEntity.notFound().build());
    }

    // Admin endpoints below

    @PostMapping("/create")
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public ResponseEntity<?> createUser(@Valid @RequestBody CreateUserDTO createUserDTO) {
        try {
            UserDTO createdUser = userService.createUser(createUserDTO);
            return ResponseEntity.status(HttpStatus.CREATED).body(createdUser);
        } catch (IllegalArgumentException e) {
            return ResponseEntity
                    .badRequest()
                    .body(new ErrorResponse("USER_EXISTS", e.getMessage(), HttpStatus.BAD_REQUEST.value()));
        }
    }

    // Get all users (admin only)
    @GetMapping
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public ResponseEntity<List<User>> getAllUsers() {
        List<User> users = userRepository.findAll();
        users.forEach(user -> user.setPassword(null));
        return ResponseEntity.ok(users);
    }

    // Get specific user (admin only)
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        return userRepository.findById(id)
                .map(user -> {
                    user.setPassword(null);
                    return ResponseEntity.ok(user);
                })
                .orElse(ResponseEntity.notFound().build());
    }

    // Update any user (admin only)
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public ResponseEntity<User> updateUser(
            @PathVariable Long id,
            @RequestBody UserUpdateDTO updateDTO) {
        return userRepository.findById(id)
                .map(user -> {
                    if (updateDTO.getEmail() != null) {
                        user.setEmail(updateDTO.getEmail());
                    }
                    if (updateDTO.getRole() != null) {
                        user.setRole(updateDTO.getRole());
                    }
                    User updatedUser = userRepository.save(user);
                    updatedUser.setPassword(null);
                    return ResponseEntity.ok(updatedUser);
                })
                .orElse(ResponseEntity.notFound().build());
    }

    // Delete user (admin only)
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        if (userRepository.existsById(id)) {
            userRepository.deleteById(id);
            return ResponseEntity.ok().build();
        }
        return ResponseEntity.notFound().build();
    }
}
```

## File: src/main/java/com/bht/ludonova/dto/auth/AuthenticationResponse.java
```java
package com.bht.ludonova.dto.auth;

import com.bht.ludonova.dto.user.UserDTO;
import lombok.Data;

@Data
public class AuthenticationResponse {
    private final TokenResponse tokens;
    private final UserDTO user;
}
```

## File: src/main/java/com/bht/ludonova/dto/auth/LoginRequest.java
```java
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class LoginRequest {
    private String username;
    private String password;
}
```

## File: src/main/java/com/bht/ludonova/dto/auth/RefreshTokenRequest.java
```java
package com.bht.ludonova.dto.auth;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class RefreshTokenRequest {
    @NotBlank(message = "Refresh token is required")
    private String refreshToken;
}
```

## File: src/main/java/com/bht/ludonova/dto/auth/TokenResponse.java
```java
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class TokenResponse {
    private final String accessToken;
    private final String refreshToken;
    private final String tokenType;
    private final long expiresIn;

    public static TokenResponse of(String accessToken, String refreshToken, long expiresIn) {
        return new TokenResponse(accessToken, refreshToken, "Bearer", expiresIn);
    }
}
```

## File: src/main/java/com/bht/ludonova/dto/game/AdminGameUpdateDTO.java
```java
package com.bht.ludonova.dto.game;

import com.bht.ludonova.model.enums.GameSource;
import com.bht.ludonova.model.enums.Platform;
import lombok.Data;

import java.time.LocalDate;
import java.util.Set;

@Data
public class AdminGameUpdateDTO {
    private String title;
    private Platform platform;
    private LocalDate releaseDate;
    private Set<String> genres;
    private GameSource source;
    private String apiId;
}
```

## File: src/main/java/com/bht/ludonova/dto/game/GameInstanceUpdateDTO.java
```java
package com.bht.ludonova.dto.game;

import lombok.Data;

@Data
public class GameInstanceUpdateDTO {
    private String status;          // PLAYING, COMPLETED, BACKLOG, etc.
    private Integer progressPercentage;
    private Integer playTime;
    private String notes;
}
```

## File: src/main/java/com/bht/ludonova/dto/game/GameUpdateDTO.java
```java
package com.bht.ludonova.dto.game;

import com.bht.ludonova.model.enums.Platform;
import lombok.Data;

import java.util.Set;

@Data
public class GameUpdateDTO {
    private String title;
    private Platform platform;
    private Set<String> genres;
    // TODO evaluate, if these should be able to be updated by the user.
//    private LocalDate releaseDate;
//    private GameSource source;
}
```

## File: src/main/java/com/bht/ludonova/dto/steam/SteamApiResponseDTO.java
```java
package com.bht.ludonova.dto.steam;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.List;

@Data
public class SteamApiResponseDTO {
    private Response response;

    @Data
    public static class Response {
        private List<Player> players;
    }

    @Data
    public static class Player {
        @JsonProperty("steamid")
        private String steamId;

        @JsonProperty("personaname")
        private String personaName;

        @JsonProperty("profileurl")
        private String profileUrl;

        @JsonProperty("avatar")
        private String avatarUrl;
    }
}
```

## File: src/main/java/com/bht/ludonova/dto/steam/SteamAuthRequest.java
```java
package com.bht.ludonova.dto.steam;

import lombok.Data;

import java.util.Map;

@Data
public class SteamAuthRequest {
    private final Map<String, String> openIdParams;
}
```

## File: src/main/java/com/bht/ludonova/dto/steam/SteamUserDTO.java
```java
package com.bht.ludonova.dto.steam;

import lombok.Data;

@Data
public class SteamUserDTO {
    private String steamId;
    private String personaName;
    private String profileUrl;
    private String avatarUrl;
}
```

## File: src/main/java/com/bht/ludonova/dto/user/CreateUserDTO.java
```java
//package com.bht.ludonova.dto.user;
//
//import com.bht.ludonova.model.enums.Role;
//import jakarta.validation.constraints.*;
//import lombok.Data;
//
//@Data
//public class CreateUserDTO {
//    @NotBlank(message = "Username is required")
//    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
//    @Pattern(regexp = "^[a-zA-Z0-9_-]+$", message = "Username can only contain letters, numbers, underscores and hyphens")
//    private String username;
//
//    @NotBlank(message = "Password is required")
//    @Size(min = 8, max = 100, message = "Password must be between 8 and 100 characters")
//    @Pattern(
//            regexp = "^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=]).*$",
//            message = "Password must contain at least one digit, one lowercase, one uppercase letter and one special character"
//    )
//    private String password;
//
//    @Email(message = "Invalid email format")
//    @NotBlank(message = "Email is required")
//    private String email;
//
//    @NotNull(message = "Role is required")
//    private Role role = Role.USER;
//}

package com.bht.ludonova.dto.user;

import com.bht.ludonova.model.enums.Role;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class CreateUserDTO {
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;

    @NotBlank(message = "Password is required")
    @Size(min = 6, message = "Password must be at least 6 characters")
    private String password;

    @Email(message = "Invalid email format")
    private String email;

    @NotNull(message = "Role is required")
    private Role role = Role.USER;
}
```

## File: src/main/java/com/bht/ludonova/dto/user/UserDTO.java
```java
package com.bht.ludonova.dto.user;

import com.bht.ludonova.dto.steam.SteamUserDTO;
import com.bht.ludonova.model.enums.Role;

import lombok.Data;

@Data
public class UserDTO {
    private Long id;
    private String username;
    private String email;
    private Role role;
    private SteamUserDTO steamUser;
}
```

## File: src/main/java/com/bht/ludonova/dto/user/UserUpdateDTO.java
```java
package com.bht.ludonova.dto.user;

import com.bht.ludonova.model.enums.Role;
import lombok.Data;

@Data
public class UserUpdateDTO {
    private String email;
    private Role role;  // Only used in admin endpoints
}
```

## File: src/main/java/com/bht/ludonova/dto/ErrorResponse.java
```java
package com.bht.ludonova.dto;

import lombok.Data;

@Data
public class ErrorResponse {
    private final String errorCode;
    private final String message;
    private final int status;
}
```

## File: src/main/java/com/bht/ludonova/exception/AuthenticationException.java
```java
package com.bht.ludonova.exception;

public class AuthenticationException extends LudoNovaException {
    public AuthenticationException(String message) {
        super(message, "AUTH_ERROR");
    }
}
```

## File: src/main/java/com/bht/ludonova/exception/GlobalExceptionHandler.java
```java
package com.bht.ludonova.exception;

import com.bht.ludonova.dto.ErrorResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {
        ErrorResponse error = new ErrorResponse(
                ex.getErrorCode(),
                ex.getMessage(),
                HttpStatus.UNAUTHORIZED.value()
        );
        return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(SteamAuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleSteamAuthenticationException(SteamAuthenticationException ex) {
        ErrorResponse error = new ErrorResponse(
                ex.getErrorCode(),
                ex.getMessage(),
                HttpStatus.UNAUTHORIZED.value()
        );
        return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        ErrorResponse error = new ErrorResponse(
                "INTERNAL_ERROR",
                "An unexpected error occurred",
                HttpStatus.INTERNAL_SERVER_ERROR.value()
        );
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleIllegalArgumentException(IllegalArgumentException ex) {
        ErrorResponse error = new ErrorResponse(
                "VALIDATION_ERROR",
                ex.getMessage(),
                HttpStatus.BAD_REQUEST.value()
        );
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });

        ErrorResponse error = new ErrorResponse(
                "VALIDATION_ERROR",
                "Validation failed: " + errors,
                HttpStatus.BAD_REQUEST.value()
        );
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }
}
```

## File: src/main/java/com/bht/ludonova/exception/LudoNovaException.java
```java
package com.bht.ludonova.exception;

public class LudoNovaException extends RuntimeException {
    private final String errorCode;

    public LudoNovaException(String message, String errorCode) {
        super(message);
        this.errorCode = errorCode;
    }

    public String getErrorCode() {
        return errorCode;
    }
}
```

## File: src/main/java/com/bht/ludonova/exception/SteamAuthenticationException.java
```java
package com.bht.ludonova.exception;

public class SteamAuthenticationException extends AuthenticationException {
    public SteamAuthenticationException(String message) {
        super("Steam authentication failed: " + message);
    }
}
```

## File: src/main/java/com/bht/ludonova/exception/UnauthorizedException.java
```java
package com.bht.ludonova.exception;

public class UnauthorizedException extends RuntimeException {
    public UnauthorizedException(String message) {
        super(message);
    }
}
```

## File: src/main/java/com/bht/ludonova/model/enums/GameSource.java
```java
package com.bht.ludonova.model.enums;

import lombok.Getter;

@Getter
public enum GameSource {
    STEAM,
    RAWG,
    MANUAL
}
```

## File: src/main/java/com/bht/ludonova/model/enums/GameStatus.java
```java
package com.bht.ludonova.model.enums;

import lombok.Getter;

@Getter
public enum GameStatus {
    PLAYING,
    COMPLETED,
    PLAN_TO_PLAY,
    DROPPED
}
```

## File: src/main/java/com/bht/ludonova/model/enums/Platform.java
```java
package com.bht.ludonova.model.enums;

import lombok.Getter;


@Getter
public enum Platform {
    // Sony PlayStation
    PS1("PlayStation"),
    PS2("PlayStation 2"),
    PS3("PlayStation 3"),
    PS4("PlayStation 4"),
    PS5("PlayStation 5"),

    // Microsoft Xbox
    XBOX("Xbox"),
    XBOX_360("Xbox 360"),
    XBOX_ONE("Xbox One"),
    XBOX_SERIES_X("Xbox Series X"),
    XBOX_SERIES_S("Xbox Series S"),

    // Nintendo
    SWITCH("Nintendo Switch"),
    WII("Nintendo Wii"),
    WII_U("Nintendo Wii U"),
    NINTENDO_3DS("Nintendo 3DS"),
    NINTENDO_DS("Nintendo DS"),

    // PC Platforms
    PC("PC"),
    MAC("Mac"),
    LINUX("Linux");

    private final String displayName;

    Platform(String displayName) {
        this.displayName = displayName;
    }

}
```

## File: src/main/java/com/bht/ludonova/model/enums/Role.java
```java
package com.bht.ludonova.model.enums;

import lombok.Getter;

@Getter
public enum Role {
    USER("ROLE_USER"),
    ADMIN("ROLE_ADMIN");

    private final String springSecurityRole;

    Role(String springSecurityRole) {
        this.springSecurityRole = springSecurityRole;
    }

}
```

## File: src/main/java/com/bht/ludonova/model/Game.java
```java
package com.bht.ludonova.model;

import com.bht.ludonova.model.enums.GameSource;
import com.bht.ludonova.model.enums.Platform;
import jakarta.persistence.*;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "games")
public class Game {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Platform platform;

    @Column(name = "api_id")
    private String apiId;  // Steam AppId or RAWG ID

    @Column(name = "release_date")
    private LocalDate releaseDate;

    @ElementCollection
    @CollectionTable(name = "game_genres",
            joinColumns = @JoinColumn(name = "game_id"))
    @Column(name = "genre")
    @Builder.Default
    private Set<String> genres = new HashSet<>();

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private GameSource source;

    @OneToMany(mappedBy = "game")
    @Builder.Default
    private Set<GameInstance> instances = new HashSet<>();
}
```

## File: src/main/java/com/bht/ludonova/model/GameInstance.java
```java
package com.bht.ludonova.model;

import com.bht.ludonova.model.enums.GameStatus;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "game_instances")
public class GameInstance {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "game_id", nullable = false)
    private Game game;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private GameStatus status;

    @Column(name = "progress_percentage")
    private Integer progressPercentage;

    @Column(name = "play_time")
    private Integer playTime;

    @Column(name = "last_played")
    private LocalDateTime lastPlayed;

    private String notes;
}
```

## File: src/main/java/com/bht/ludonova/model/Review.java
```java
package com.bht.ludonova.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "reviews")
public class Review {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "game_id", nullable = false)
    private Game game;

    @Min(1)
    @Max(5)
    private Integer rating;

    @Column(name = "review_text")
    private String reviewText;

    @Column(name = "created_at")
    private LocalDateTime createdAt;
}
```

## File: src/main/java/com/bht/ludonova/model/SteamUser.java
```java
package com.bht.ludonova.model;

import lombok.Data;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;

@Data
@Entity
@Table(name = "steam_users")
public class SteamUser {
    @Id
    private String steamId;
    
    private String personaName;
    private String profileUrl;
    private String avatarUrl;
    
    @OneToOne(mappedBy = "steamUser")
    private User user;
}
```

## File: src/main/java/com/bht/ludonova/model/User.java
```java
package com.bht.ludonova.model;

import com.bht.ludonova.model.enums.Role;
import jakarta.persistence.*;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    @Column
    private String email;

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "steam_id")
    private SteamUser steamUser;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role = Role.USER;  // Default to USER role
}
```

## File: src/main/java/com/bht/ludonova/repository/GameInstanceRepository.java
```java
package com.bht.ludonova.repository;

import com.bht.ludonova.model.GameInstance;
import com.bht.ludonova.model.enums.GameStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface GameInstanceRepository extends JpaRepository<GameInstance, Long> {
    List<GameInstance> findByUserId(Long userId);
    Optional<GameInstance> findByUserIdAndGameId(Long userId, Long gameId);
    boolean existsByUserIdAndGameId(Long userId, Long gameId);

    @Query("SELECT gi FROM GameInstance gi WHERE gi.user.id = :userId AND gi.status = :status")
    List<GameInstance> findByUserIdAndStatus(Long userId, GameStatus status);
}
```

## File: src/main/java/com/bht/ludonova/repository/GameRepository.java
```java
package com.bht.ludonova.repository;

import com.bht.ludonova.model.Game;
import com.bht.ludonova.model.enums.GameSource;
import com.bht.ludonova.model.enums.Platform;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface GameRepository extends JpaRepository<Game, Long> {
    Optional<Game> findByApiIdAndSource(String apiId, GameSource source);
    List<Game> findByPlatform(Platform platform);
    List<Game> findAllByApiIdAndSource(String apiId, GameSource source);
}
```

## File: src/main/java/com/bht/ludonova/repository/ReviewRepository.java
```java
package com.bht.ludonova.repository;

import com.bht.ludonova.model.Review;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ReviewRepository extends JpaRepository<Review, Long> {
    List<Review> findByGameId(Long gameId);
    List<Review> findByUserId(Long userId);
    Optional<Review> findByUserIdAndGameId(Long userId, Long gameId);
}
```

## File: src/main/java/com/bht/ludonova/repository/UserRepository.java
```java
package com.bht.ludonova.repository;

import com.bht.ludonova.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findBySteamUser_SteamId(String steamId);
}
```

## File: src/main/java/com/bht/ludonova/security/AuthenticationExceptionHandler.java
```java
package com.bht.ludonova.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Component
public class AuthenticationExceptionHandler implements AuthenticationEntryPoint, AccessDeniedHandler {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        log.error("Unauthorized error: {}", authException.getMessage());

        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

        Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
        body.put("error", "Unauthorized");
        body.put("message", authException.getMessage());
        body.put("path", request.getServletPath());

        objectMapper.writeValue(response.getOutputStream(), body);
    }

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response,
                       AccessDeniedException accessDeniedException) throws IOException, ServletException {
        log.error("Access denied error: {}", accessDeniedException.getMessage());

        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);

        Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_FORBIDDEN);
        body.put("error", "Forbidden");
        body.put("message", accessDeniedException.getMessage());
        body.put("path", request.getServletPath());

        objectMapper.writeValue(response.getOutputStream(), body);
    }
}
```

## File: src/main/java/com/bht/ludonova/security/CustomUserDetailsService.java
```java
package com.bht.ludonova.security;

import com.bht.ludonova.model.User;
import com.bht.ludonova.model.enums.Role;
import com.bht.ludonova.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@Slf4j
@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

//    @Override
//    @Transactional(readOnly = true)
//    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
//        User user = userRepository.findByUsername(username)
//                .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));
//
//        log.debug("Loading user: {} with role: {}", username, user.getRole());
//
//        List<SimpleGrantedAuthority> authorities = new ArrayList<>();
//        // Add ROLE_USER by default
//        authorities.add(new SimpleGrantedAuthority("ROLE_USER"));
//
//        // Add ROLE_ADMIN if the user is an admin
//        if (user.getRole() == Role.ADMIN) {
//            authorities.add(new SimpleGrantedAuthority("ROLE_ADMIN"));
//            log.debug("Added ADMIN role for user: {}", username);
//        }
//
//        return org.springframework.security.core.userdetails.User.builder()
//                .username(user.getUsername())
//                .password(user.getPassword())
//                .authorities(Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")))
//                .accountExpired(false)
//                .accountLocked(false)
//                .credentialsExpired(false)
//                .disabled(false)
//                .build();
//    }

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));

        log.debug("Loading user: {} with role: {}", username, user.getRole());

        List<SimpleGrantedAuthority> authorities = new ArrayList<>();
        // Add base USER role
        authorities.add(new SimpleGrantedAuthority(Role.USER.getSpringSecurityRole()));

        // Add ADMIN role if applicable
        if (user.getRole() == Role.ADMIN) {
            authorities.add(new SimpleGrantedAuthority(Role.ADMIN.getSpringSecurityRole()));
            log.debug("Added ADMIN role for user: {}", username);
        }

        log.debug("Final authorities for user {}: {}", username, authorities);

        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getUsername())
                .password(user.getPassword())
                .authorities(authorities)
                .accountExpired(false)
                .accountLocked(false)
                .credentialsExpired(false)
                .disabled(false)
                .build();
    }
}
```

## File: src/main/java/com/bht/ludonova/security/JwtAuthenticationFilter.java
```java
package com.bht.ludonova.security;

import com.bht.ludonova.exception.AuthenticationException;
import io.jsonwebtoken.Claims;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider tokenProvider;
    private final CustomUserDetailsService customUserDetailsService;
    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    // List of paths that don't require authentication
    private final List<String> publicPaths = Arrays.asList(
            "/api/auth/**",
            "/api/test/public"
    );

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getServletPath();
        return publicPaths.stream()
                .anyMatch(pattern -> pathMatcher.match(pattern, path));
    }

//    @Override
//    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
//            throws ServletException, IOException {
//        try {
//            String jwt = getJwtFromRequest(request);
//
//            if (StringUtils.hasText(jwt)) {
//                if (!tokenProvider.validateToken(jwt)) {
//                    throw new AuthenticationException("Invalid or expired JWT token");
//                }
//
//                String username = tokenProvider.getUsernameFromToken(jwt);
//                UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);
//
//                log.debug("User authorities: {}", userDetails.getAuthorities());
//
//                UsernamePasswordAuthenticationToken authentication =
//                        new UsernamePasswordAuthenticationToken(
//                                userDetails,
//                                null,
//                                userDetails.getAuthorities()
//                        );
//                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
//
//                SecurityContextHolder.getContext().setAuthentication(authentication);
//            }
//        } catch (Exception ex) {
//            log.error("Could not set user authentication in security context", ex);
//            SecurityContextHolder.clearContext();
//
//            if (ex instanceof AuthenticationException) {
//                throw ex;
//            }
//        }
//
//        filterChain.doFilter(request, response);
//    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt)) {
                if (tokenProvider.validateToken(jwt)) {
                    Claims claims = tokenProvider.getClaimsFromToken(jwt, false);
                    String username = claims.getSubject();

                    // Extract authorities from claims
                    List<SimpleGrantedAuthority> authorities = new ArrayList<>();
                    if (claims.get("authorities") instanceof List) {
                        @SuppressWarnings("unchecked")
                        List<String> authoritiesList = (List<String>) claims.get("authorities");
                        authorities = authoritiesList.stream()
                                .map(SimpleGrantedAuthority::new)
                                .collect(Collectors.toList());
                    }

                    log.debug("Token claims authorities: {}", authorities);

                    UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);

                    UsernamePasswordAuthenticationToken authentication =
                            new UsernamePasswordAuthenticationToken(
                                    userDetails,
                                    null,
                                    authorities  // Use the authorities from token
                            );
                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                    SecurityContextHolder.getContext().setAuthentication(authentication);
                }
            }
        } catch (Exception ex) {
            log.error("Could not set user authentication in security context", ex);
            SecurityContextHolder.clearContext();
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }

    /**
     * Helper method to check if token is about to expire
     * Could be used to implement token refresh logic
     */
    private boolean shouldRefreshToken(String token) {
        return tokenProvider.isTokenExpired(token, false);
    }
}
```

## File: src/main/java/com/bht/ludonova/security/JwtTokenProvider.java
```java
package com.bht.ludonova.security;


import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

//@Slf4j
//@Component
//public class JwtTokenProvider {
//
//    private final SecretKey accessTokenKey;
//    private final SecretKey refreshTokenKey;
//    private final long accessTokenExpirationMs; // Changed to long
//    private final long refreshTokenExpirationMs; // Changed to long
//
//    public JwtTokenProvider(
//            @Value("${jwt.secret}") String jwtSecret,
//            @Value("${jwt.refresh-secret:${jwt.secret}}") String refreshSecret,
//            @Value("${jwt.expiration}") long accessTokenExpirationMs, // Changed to long
//            @Value("${jwt.refresh-expiration:2592000000}") long refreshTokenExpirationMs) { // Changed to long
//        this.accessTokenKey = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
//        this.refreshTokenKey = Keys.hmacShaKeyFor(refreshSecret.getBytes(StandardCharsets.UTF_8));
//        this.accessTokenExpirationMs = accessTokenExpirationMs;
//        this.refreshTokenExpirationMs = refreshTokenExpirationMs;
//    }
//
//    public String generateAccessToken(Authentication authentication) {
//        return generateAccessToken(authentication.getName(), createClaims(authentication));
//    }
//
//    public String generateAccessToken(String username) {
//        return generateAccessToken(username, new HashMap<>());
//    }
//
//    public String generateAccessToken(String username, Map<String, Object> claims) {
//        return generateToken(username, claims, accessTokenKey, accessTokenExpirationMs);
//    }
//
//    public String generateRefreshToken(String username) {
//        return generateToken(username, new HashMap<>(), refreshTokenKey, refreshTokenExpirationMs);
//    }
//
//    private String generateToken(String username, Map<String, Object> claims, SecretKey key, long expirationMs) {
//        Date now = new Date();
//        Date expiryDate = new Date(now.getTime() + expirationMs);
//
//        return Jwts.builder()
//                .setClaims(claims)
//                .setSubject(username)
//                .setIssuedAt(now)
//                .setExpiration(expiryDate)
//                .signWith(key, SignatureAlgorithm.HS512)
//                .compact();
//    }
//
//    private Map<String, Object> createClaims(Authentication authentication) {
//        Map<String, Object> claims = new HashMap<>();
//
//        // Convert authorities to a list
//        List<String> authorities = authentication.getAuthorities().stream()
//                .map(GrantedAuthority::getAuthority)
//                .collect(Collectors.toList());
//
//        claims.put("authorities", authorities);  // Store as a list instead of a string
//        log.debug("Creating token with authorities: {}", authorities);
//
//        // Add token type
//        claims.put("type", "Bearer");
//
//        return claims;
//    }
//
////    public String getUsernameFromToken(String token) {
////        return getUsernameFromToken(token, false);
////    }
//
//    public String getUsernameFromToken(String token) {
//        Claims claims = Jwts.parserBuilder()
//                .setSigningKey(key)
//                .build()
//                .parseClaimsJws(token)
//                .getBody();
//
//        log.debug("Token claims: {}", claims);
//        return claims.getSubject();
//    }
//
//    public boolean validateToken(String token) {
//        return validateToken(token, false);
//    }
//
//    public boolean validateToken(String token, boolean isRefreshToken) {
//        try {
//            SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
//            Jwts.parserBuilder()
//                    .setSigningKey(key)
//                    .build()
//                    .parseClaimsJws(token);
//            return true;
//        } catch (SignatureException e) {
//            log.error("Invalid JWT signature: {}", e.getMessage());
//        } catch (MalformedJwtException e) {
//            log.error("Invalid JWT token: {}", e.getMessage());
//        } catch (ExpiredJwtException e) {
//            log.error("JWT token is expired: {}", e.getMessage());
//        } catch (UnsupportedJwtException e) {
//            log.error("JWT token is unsupported: {}", e.getMessage());
//        } catch (IllegalArgumentException e) {
//            log.error("JWT claims string is empty: {}", e.getMessage());
//        }
//        return false;
//    }
//
//    public Claims getClaimsFromToken(String token, boolean isRefreshToken) {
//        SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
//        return Jwts.parserBuilder()
//                .setSigningKey(key)
//                .build()
//                .parseClaimsJws(token)
//                .getBody();
//    }
//
//    public boolean isTokenExpired(String token, boolean isRefreshToken) {
//        try {
//            Claims claims = getClaimsFromToken(token, isRefreshToken);
//            return claims.getExpiration().before(new Date());
//        } catch (ExpiredJwtException e) {
//            return true;
//        }
//    }
//
//    public long getAccessTokenExpirationMs() {
//        return accessTokenExpirationMs;
//    }
//
//    public long getRefreshTokenExpirationMs() {
//        return refreshTokenExpirationMs;
//    }
//}

@Slf4j
@Component
public class JwtTokenProvider {

    private final SecretKey accessTokenKey;
    private final SecretKey refreshTokenKey;
    private final long accessTokenExpirationMs;
    private final long refreshTokenExpirationMs;

    public JwtTokenProvider(
            @Value("${jwt.secret}") String jwtSecret,
            @Value("${jwt.refresh-secret:${jwt.secret}}") String refreshSecret,
            @Value("${jwt.expiration}") long accessTokenExpirationMs,
            @Value("${jwt.refresh-expiration:2592000000}") long refreshTokenExpirationMs) {
        this.accessTokenKey = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
        this.refreshTokenKey = Keys.hmacShaKeyFor(refreshSecret.getBytes(StandardCharsets.UTF_8));
        this.accessTokenExpirationMs = accessTokenExpirationMs;
        this.refreshTokenExpirationMs = refreshTokenExpirationMs;
    }

    public String generateAccessToken(Authentication authentication) {
        return generateAccessToken(authentication.getName(), createClaims(authentication));
    }

    public String generateAccessToken(String username) {
        return generateAccessToken(username, new HashMap<>());
    }

    public String generateAccessToken(String username, Map<String, Object> claims) {
        return generateToken(username, claims, accessTokenKey, accessTokenExpirationMs);
    }

    public String generateRefreshToken(String username) {
        return generateToken(username, new HashMap<>(), refreshTokenKey, refreshTokenExpirationMs);
    }

    private String generateToken(String username, Map<String, Object> claims, SecretKey key, long expirationMs) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expirationMs);

        return Jwts.builder()
                .setClaims(claims)
                .setSubject(username)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();
    }

    private Map<String, Object> createClaims(Authentication authentication) {
        Map<String, Object> claims = new HashMap<>();

        List<String> authorities = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toList());

        claims.put("authorities", authorities);
        log.debug("Creating token with authorities: {}", authorities);
        claims.put("type", "Bearer");

        return claims;
    }

    public String getUsernameFromToken(String token, boolean isRefreshToken) {
        SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
        Claims claims = Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
        log.debug("Token claims: {}", claims);
        return claims.getSubject();
    }

    public String getUsernameFromToken(String token) {
        return getUsernameFromToken(token, false);
    }

    public boolean validateToken(String token) {
        return validateToken(token, false);
    }

    public boolean validateToken(String token, boolean isRefreshToken) {
        try {
            SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
            Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(token);
            return true;
        } catch (SignatureException e) {
            log.error("Invalid JWT signature: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            log.error("Invalid JWT token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            log.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            log.error("JWT token is unsupported: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            log.error("JWT claims string is empty: {}", e.getMessage());
        }
        return false;
    }

    public Claims getClaimsFromToken(String token, boolean isRefreshToken) {
        SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
        return Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    public boolean isTokenExpired(String token, boolean isRefreshToken) {
        try {
            Claims claims = getClaimsFromToken(token, isRefreshToken);
            return claims.getExpiration().before(new Date());
        } catch (ExpiredJwtException e) {
            return true;
        }
    }

    public long getAccessTokenExpirationMs() {
        return accessTokenExpirationMs;
    }

    public long getRefreshTokenExpirationMs() {
        return refreshTokenExpirationMs;
    }
}
```

## File: src/main/java/com/bht/ludonova/security/SecurityConfig.java
```java
package com.bht.ludonova.security;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfigurationSource;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;
    private final JwtAuthenticationFilter jwtAuthFilter;
    private final CorsConfigurationSource corsConfigurationSource;
    private final AuthenticationExceptionHandler authenticationExceptionHandler;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        return http
                .cors(cors -> cors.configurationSource(corsConfigurationSource))
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        // Public endpoints
                        .requestMatchers(
                                "/api/auth/login",
                                "/api/auth/refresh",
                                "/api/auth/steam/login",
                                "/api/auth/steam/return",
                                // Swagger UI and OpenAPI endpoints
                                "/swagger-ui/**",
                                "/v3/api-docs/**",
                                "/swagger-ui.html"
                        ).permitAll()
                        // Protected endpoints
                        .requestMatchers("/api/games/**").authenticated()
                        .requestMatchers("/api/user/**").authenticated()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authenticationProvider(authenticationProvider())
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exc -> exc
                        .authenticationEntryPoint(authenticationExceptionHandler)
                        .accessDeniedHandler(authenticationExceptionHandler)
                )
                .build();
    }


    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}
```

## File: src/main/java/com/bht/ludonova/service/auth/AuthenticationStrategy.java
```java
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;

import java.util.Map;

public interface AuthenticationStrategy {
    AuthenticationResponse authenticate(Map<String, String> credentials);
    AuthenticationResponse refresh(String refreshToken);
}
```

## File: src/main/java/com/bht/ludonova/service/auth/BasicAuthenticationStrategy.java
```java
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.TokenResponse;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.exception.AuthenticationException;
import com.bht.ludonova.security.JwtTokenProvider;
import com.bht.ludonova.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class BasicAuthenticationStrategy implements AuthenticationStrategy {
    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider tokenProvider;
    private final UserService userService;

    public BasicAuthenticationStrategy(
            AuthenticationManager authenticationManager,
            JwtTokenProvider tokenProvider,
            UserService userService) {
        this.authenticationManager = authenticationManager;
        this.tokenProvider = tokenProvider;
        this.userService = userService;
    }

    @Override
    public AuthenticationResponse authenticate(Map<String, String> credentials) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            credentials.get("username"),
                            credentials.get("password")
                    )
            );
            SecurityContextHolder.getContext().setAuthentication(authentication);

            String accessToken = tokenProvider.generateAccessToken(authentication);
            String refreshToken = tokenProvider.generateRefreshToken(authentication.getName());
            UserDTO user = userService.getCurrentUserDTO();

            TokenResponse tokens = TokenResponse.of(
                    accessToken,
                    refreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, user);
        } catch (org.springframework.security.core.AuthenticationException e) {
            log.error("Authentication failed", e);
            throw new AuthenticationException("Invalid username or password");
        }
    }

    @Override
    public AuthenticationResponse refresh(String refreshToken) {
        log.debug("Attempting to refresh token: {}", refreshToken);
        try {
            if (!tokenProvider.validateToken(refreshToken, true)) {
                log.error("Invalid refresh token validation");
                throw new AuthenticationException("Invalid refresh token");
            }

            String username = tokenProvider.getUsernameFromToken(refreshToken, true);
            log.debug("Extracted username from refresh token: {}", username);
            UserDTO user = userService.getUserDTOByUsername(username);

            String newAccessToken = tokenProvider.generateAccessToken(username);
            String newRefreshToken = tokenProvider.generateRefreshToken(username);

            TokenResponse tokens = TokenResponse.of(
                    newAccessToken,
                    newRefreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, user);
        } catch (Exception e) {
            log.error("Token refresh failed", e);
            throw new AuthenticationException("Failed to refresh token");
        }
    }
}
```

## File: src/main/java/com/bht/ludonova/service/auth/SteamAuthenticationStrategy.java
```java
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.TokenResponse;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.exception.SteamAuthenticationException;
import com.bht.ludonova.model.SteamUser;
import com.bht.ludonova.model.User;
import com.bht.ludonova.security.JwtTokenProvider;
import com.bht.ludonova.service.SteamService;
import com.bht.ludonova.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class SteamAuthenticationStrategy implements AuthenticationStrategy {
    private final SteamService steamService;
    private final UserService userService;
    private final JwtTokenProvider tokenProvider;

    public SteamAuthenticationStrategy(
            SteamService steamService,
            UserService userService,
            JwtTokenProvider tokenProvider) {
        this.steamService = steamService;
        this.userService = userService;
        this.tokenProvider = tokenProvider;
    }

    @Override
    public AuthenticationResponse authenticate(Map<String, String> openIdParams) {
        try {
            log.debug("Starting Steam authentication with params: {}", openIdParams);

            if (!steamService.validateSteamResponse(openIdParams)) {
                log.error("Steam validation failed");
                throw new SteamAuthenticationException("Invalid Steam response");
            }

            log.debug("Steam response validated successfully");
            String steamId = extractSteamId(openIdParams);

            if (steamId == null) {
                log.error("Could not extract Steam ID from params");
                throw new SteamAuthenticationException("Could not extract Steam ID");
            }

            log.debug("Extracted Steam ID: {}", steamId);
            SteamUser steamUser = steamService.fetchUserDetails(steamId);
            log.debug("Fetched Steam user details: {}", steamUser);

            User user = userService.getOrCreateSteamUser(steamUser);
            log.debug("Got/Created user: {}", user);

            String accessToken = tokenProvider.generateAccessToken(user.getUsername());
            String refreshToken = tokenProvider.generateRefreshToken(user.getUsername());
            UserDTO userDTO = userService.convertToDTO(user);

            log.debug("Generated tokens and converted user to DTO");

            TokenResponse tokens = TokenResponse.of(
                    accessToken,
                    refreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, userDTO);
        } catch (Exception e) {
            log.error("Steam authentication failed", e);
            throw new SteamAuthenticationException(e.getMessage());
        }
    }

    @Override
    public AuthenticationResponse refresh(String refreshToken) {
        return null; // Steam users use the same refresh mechanism as basic auth
    }

    private String extractSteamId(Map<String, String> params) {
        String identity = params.get("openid.claimed_id");
        if (identity != null && identity.matches("https://steamcommunity.com/openid/id/\\d+")) {
            return identity.substring(identity.lastIndexOf("/") + 1);
        }
        return null;
    }
}
```

## File: src/main/java/com/bht/ludonova/service/AuthenticationService.java
```java
package com.bht.ludonova.service;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.exception.AuthenticationException;
import com.bht.ludonova.service.auth.AuthenticationStrategy;
import com.bht.ludonova.service.auth.BasicAuthenticationStrategy;
import com.bht.ludonova.service.auth.SteamAuthenticationStrategy;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class AuthenticationService {
    private final Map<String, AuthenticationStrategy> authenticationStrategies;

    public AuthenticationService(
            BasicAuthenticationStrategy basicAuthStrategy,
            SteamAuthenticationStrategy steamAuthStrategy) {
        this.authenticationStrategies = Map.of(
                "basic", basicAuthStrategy,
                "steam", steamAuthStrategy
        );
    }

//    public AuthenticationResponse authenticate(String strategy, Map<String, String> credentials) {
//        AuthenticationStrategy authStrategy = authenticationStrategies.get(strategy);
//        if (authStrategy == null) {
//            throw new AuthenticationException("Unsupported authentication strategy: " + strategy);
//        }
//
//        return authStrategy.authenticate(credentials);
//    }

    public AuthenticationResponse authenticate(String strategy, Map<String, String> credentials) {
        AuthenticationStrategy authStrategy = authenticationStrategies.get(strategy);
        if (authStrategy == null) {
            throw new AuthenticationException("Unsupported authentication strategy: " + strategy);
        }

        AuthenticationResponse response = authStrategy.authenticate(credentials);
        log.debug("Authenticated user with authorities: {}",
                SecurityContextHolder.getContext().getAuthentication().getAuthorities());

        return response;
    }

    public AuthenticationResponse refresh(String refreshToken) {
        // We use the basic strategy for refresh tokens as the mechanism is the same
        return authenticationStrategies.get("basic").refresh(refreshToken);
    }
}
```

## File: src/main/java/com/bht/ludonova/service/GameInstanceService.java
```java
package com.bht.ludonova.service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import lombok.RequiredArgsConstructor;

import com.bht.ludonova.model.GameInstance;
import com.bht.ludonova.model.enums.GameStatus;
import com.bht.ludonova.repository.GameInstanceRepository;

@Service
@Transactional
@RequiredArgsConstructor
public class GameInstanceService {
    private final GameInstanceRepository gameInstanceRepository;

    public GameInstance save(GameInstance gameInstance) {
        if (gameInstance.getStatus() == GameStatus.PLAYING) {
            gameInstance.setLastPlayed(LocalDateTime.now());
        }
        return gameInstanceRepository.save(gameInstance);
    }

    public Optional<GameInstance> findById(Long id) {
        return gameInstanceRepository.findById(id);
    }

    public List<GameInstance> findByUserId(Long userId) {
        return gameInstanceRepository.findByUserId(userId);
    }

    public List<GameInstance> findByUserIdAndStatus(Long userId, GameStatus status) {
        return gameInstanceRepository.findByUserIdAndStatus(userId, status);
    }

    public Optional<GameInstance> findByUserIdAndGameId(Long userId, Long gameId) {
        return gameInstanceRepository.findByUserIdAndGameId(userId, gameId);
    }

    public boolean existsByUserIdAndGameId(Long userId, Long gameId) {
        return gameInstanceRepository.existsByUserIdAndGameId(userId, gameId);
    }

    public void updateStatus(Long id, GameStatus newStatus) {
        findById(id).ifPresent(instance -> {
            instance.setStatus(newStatus);
            if (newStatus == GameStatus.PLAYING) {
                instance.setLastPlayed(LocalDateTime.now());
            }
            save(instance);
        });
    }

    public void deleteById(Long id) {
        gameInstanceRepository.deleteById(id);
    }
}
```

## File: src/main/java/com/bht/ludonova/service/GameService.java
```java
package com.bht.ludonova.service;

import java.util.List;
import java.util.Optional;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.bht.ludonova.model.Game;
import com.bht.ludonova.model.enums.GameSource;
import com.bht.ludonova.model.enums.Platform;
import com.bht.ludonova.repository.GameRepository;

import lombok.RequiredArgsConstructor;

@Service
@Transactional
@RequiredArgsConstructor
public class GameService {
    private final GameRepository gameRepository;

    public Game save(Game game) {
        return gameRepository.save(game);
    }

    public Optional<Game> findById(Long id) {
        return gameRepository.findById(id);
    }

    public List<Game> findAll() {
        return gameRepository.findAll();
    }

    public List<Game> findByPlatform(Platform platform) {
        return gameRepository.findByPlatform(platform);
    }

    public Optional<Game> findByApiIdAndSource(String apiId, GameSource source) {
        return gameRepository.findByApiIdAndSource(apiId, source);
    }

    public void deleteById(Long id) {
        gameRepository.deleteById(id);
    }
}
```

## File: src/main/java/com/bht/ludonova/service/SteamService.java
```java
package com.bht.ludonova.service;

import com.bht.ludonova.dto.steam.SteamApiResponseDTO;
import com.bht.ludonova.exception.SteamAuthenticationException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import com.bht.ludonova.model.SteamUser;
import lombok.extern.slf4j.Slf4j;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Service
public class SteamService {
    @Value("${steam.api.key}")
    private String steamApiKey;

    private final WebClient steamApiClient;
    private final WebClient openIdClient;

    public SteamService() {
        this.steamApiClient = WebClient.builder()
                .baseUrl("https://api.steampowered.com")
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
                .build();

        this.openIdClient = WebClient.builder()
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
                .build();
    }

    public boolean validateSteamResponse(Map<String, String> params) {
        try {
            log.info("Validating Steam response with params: {}", params);
            String url = "https://steamcommunity.com/openid/login";

            // Create a new map with check_authentication mode
            Map<String, String> validationParams = new HashMap<>(params);
            validationParams.put("openid.mode", "check_authentication");

            // Convert map to form data
            String formData = validationParams.entrySet().stream()
                    .map(entry -> entry.getKey() + "=" + encodeValue(entry.getValue()))
                    .collect(Collectors.joining("&"));

            String responseBody = openIdClient.post()
                    .uri(url)
                    .header("Content-Type", "application/x-www-form-urlencoded")
                    .bodyValue(formData)
                    .retrieve()
                    .bodyToMono(String.class)
                    .block();

            log.info("Steam validation response: {}", responseBody);
            return responseBody != null && responseBody.contains("is_valid:true");
        } catch (Exception e) {
            log.error("Error validating Steam response", e);
            return false;
        }
    }

    public SteamUser fetchUserDetails(String steamId) {
        String url = "/ISteamUser/GetPlayerSummaries/v2/";

        try {
            SteamApiResponseDTO dto = steamApiClient.get()
                    .uri(uriBuilder -> uriBuilder
                            .path(url)
                            .queryParam("key", steamApiKey)
                            .queryParam("steamids", steamId)
                            .build())
                    .retrieve()
                    .bodyToMono(SteamApiResponseDTO.class)
                    .block();

            if (dto != null && dto.getResponse() != null && !dto.getResponse().getPlayers().isEmpty()) {
                SteamApiResponseDTO.Player player = dto.getResponse().getPlayers().get(0);
                return mapToSteamUser(player);
            }

            throw new SteamApiException("Failed to fetch Steam user details");
        } catch (Exception e) {
            log.error("Error fetching Steam user details", e);
            throw new SteamApiException("Failed to fetch Steam user details", e);
        }
    }

    private String encodeValue(String value) {
        try {
            return URLEncoder.encode(value, StandardCharsets.UTF_8.toString());
        } catch (UnsupportedEncodingException e) {
            return value;
        }
    }

    private SteamUser mapToSteamUser(SteamApiResponseDTO.Player player) {
        SteamUser steamUser = new SteamUser();
        steamUser.setSteamId(player.getSteamId());
        steamUser.setPersonaName(player.getPersonaName());
        steamUser.setProfileUrl(player.getProfileUrl());
        steamUser.setAvatarUrl(player.getAvatarUrl());
        return steamUser;
    }

    public static class SteamApiException extends RuntimeException {
        public SteamApiException(String message) {
            super(message);
        }

        public SteamApiException(String message, Throwable cause) {
            super(message, cause);
        }
    }
}
```

## File: src/main/java/com/bht/ludonova/service/UserService.java
```java
package com.bht.ludonova.service;

import com.bht.ludonova.dto.steam.SteamUserDTO;
import com.bht.ludonova.dto.user.CreateUserDTO;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.dto.user.UserUpdateDTO;
import com.bht.ludonova.exception.AuthenticationException;
import com.bht.ludonova.exception.UnauthorizedException;
import com.bht.ludonova.model.enums.Role;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.bht.ludonova.model.SteamUser;
import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@Transactional
public class UserService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    public UserDTO createUser(CreateUserDTO createUserDTO) {
        // Check if username already exists
        if (userRepository.findByUsername(createUserDTO.getUsername()).isPresent()) {
            throw new IllegalArgumentException("Username already exists");
        }

        User user = User.builder()
                .username(createUserDTO.getUsername())
                .password(passwordEncoder.encode(createUserDTO.getPassword()))
                .email(createUserDTO.getEmail())
                .role(createUserDTO.getRole())
                .build();

        User savedUser = userRepository.save(user);
        return convertToDTO(savedUser);
    }

    public User getOrCreateSteamUser(SteamUser steamUser) {
        return userRepository.findBySteamUser_SteamId(steamUser.getSteamId())
                .orElseGet(() -> createSteamUser(steamUser));
    }

    private User createSteamUser(SteamUser steamUser) {
        User user = new User();
        user.setUsername("steam_" + steamUser.getSteamId());
        user.setPassword(passwordEncoder.encode(UUID.randomUUID().toString()));
        user.setRole(Role.USER);
        user.setSteamUser(steamUser);
        return userRepository.save(user);
    }

    public UserDTO getCurrentUserDTO() {
        String username = SecurityContextHolder.getContext().getAuthentication().getName();
        return userRepository.findByUsername(username)
                .map(this::convertToDTO)
                .orElseThrow(() -> new AuthenticationException("User not found"));
    }

    public UserDTO getUserDTOByUsername(String username) {
        return userRepository.findByUsername(username)
                .map(this::convertToDTO)
                .orElseThrow(() -> new AuthenticationException("User not found: " + username));
    }

    public UserDTO convertToDTO(User user) {
        UserDTO dto = new UserDTO();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());
        dto.setRole(user.getRole());

        if (user.getSteamUser() != null) {
            SteamUserDTO steamUserDTO = new SteamUserDTO();
            steamUserDTO.setSteamId(user.getSteamUser().getSteamId());
            steamUserDTO.setPersonaName(user.getSteamUser().getPersonaName());
            steamUserDTO.setProfileUrl(user.getSteamUser().getProfileUrl());
            steamUserDTO.setAvatarUrl(user.getSteamUser().getAvatarUrl());
            dto.setSteamUser(steamUserDTO);
        }

        return dto;
    }

    public List<UserDTO> getAllUsers() {
        checkAdminAccess();
        return userRepository.findAll().stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    public UserDTO getUserById(Long id) {
        checkAdminAccess();
        return userRepository.findById(id)
                .map(this::convertToDTO)
                .orElseThrow(() -> new AuthenticationException("User not found: " + id));
    }

    public UserDTO updateUser(Long id, UserUpdateDTO updateDTO) {
        User currentUser = getCurrentUser();
        User userToUpdate = userRepository.findById(id)
                .orElseThrow(() -> new AuthenticationException("User not found: " + id));

        if (!currentUser.getRole().equals(Role.ADMIN) && !currentUser.getId().equals(id)) {
            throw new UnauthorizedException("You can only update your own profile");
        }

        if (updateDTO.getRole() != null) {
            if (!currentUser.getRole().equals(Role.ADMIN)) {
                throw new UnauthorizedException("Only admins can update roles");
            }
            userToUpdate.setRole(updateDTO.getRole());
        }

        if (updateDTO.getEmail() != null) {
            userToUpdate.setEmail(updateDTO.getEmail());
        }

        return convertToDTO(userRepository.save(userToUpdate));
    }

    public void deleteUser(Long id) {
        checkAdminAccess();
        userRepository.deleteById(id);
    }

    private User getCurrentUser() {
        String username = SecurityContextHolder.getContext().getAuthentication().getName();
        return userRepository.findByUsername(username)
                .orElseThrow(() -> new AuthenticationException("User not found"));
    }

    private void checkAdminAccess() {
        User currentUser = getCurrentUser();
        if (!currentUser.getRole().equals(Role.ADMIN)) {
            throw new UnauthorizedException("Admin access required");
        }
    }
}
```

## File: src/main/java/com/bht/ludonova/LudoNovaApplication.java
```java
package com.bht.ludonova;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@SpringBootApplication
@EntityScan("com.bht.ludonova.model")
@EnableJpaRepositories("com.bht.ludonova.repository")
public class LudoNovaApplication {
    public static void main(String[] args) {
        SpringApplication.run(LudoNovaApplication.class, args);
    }
}
```

## File: src/main/resources/db/migration/V1__create_base_schema.sql
```sql
-- Steam Users table first (because it's referenced by users)
CREATE TABLE IF NOT EXISTS steam_users (
    steam_id VARCHAR(255) PRIMARY KEY,
    persona_name VARCHAR(255),
    profile_url VARCHAR(255),
    avatar_url VARCHAR(255)
);

-- Then Users table (with the foreign key)
CREATE TABLE IF NOT EXISTS users (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(255) NOT NULL UNIQUE,
    email VARCHAR(255),
    password VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL DEFAULT 'USER',
    steam_id VARCHAR(255) REFERENCES steam_users(steam_id),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Games and related tables
CREATE TABLE games (
                       id BIGSERIAL PRIMARY KEY,
                       title VARCHAR(255) NOT NULL,
                       platform VARCHAR(50) NOT NULL,
                       api_id VARCHAR(100),
                       release_date DATE,
                       source VARCHAR(20) NOT NULL,
                       created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE game_genres (
                             game_id BIGINT REFERENCES games(id) ON DELETE CASCADE,
                             genre VARCHAR(50),
                             PRIMARY KEY (game_id, genre)
);

CREATE TABLE game_instances (
                                id BIGSERIAL PRIMARY KEY,
                                user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
                                game_id BIGINT REFERENCES games(id) ON DELETE CASCADE,
                                status VARCHAR(20) NOT NULL,
                                progress_percentage INTEGER CHECK (progress_percentage BETWEEN 0 AND 100),
                                play_time INTEGER,
                                last_played TIMESTAMP,
                                notes TEXT,
                                created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                                updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                                UNIQUE(user_id, game_id)
);

-- Reviews table
CREATE TABLE reviews (
                         id BIGSERIAL PRIMARY KEY,
                         user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
                         game_id BIGINT REFERENCES games(id) ON DELETE CASCADE,
                         rating INTEGER CHECK (rating BETWEEN 1 AND 5),
                         review_text TEXT,
                         created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                         updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                         UNIQUE(user_id, game_id)
);
```

## File: src/main/resources/application.properties
```
# Server Configuration
server.port=8080

# PostgreSQL Database Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=postgres
spring.datasource.password=postgres

# JPA/Hibernate Configuration
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Flyway Configuration
spring.flyway.enabled=true
spring.flyway.baseline-on-migrate=true
spring.flyway.clean-disabled=false
spring.flyway.locations=classpath:db/migration

# Enable SQL initialization
spring.sql.init.mode=always

# JWT Configuration
jwt.secret=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
jwt.refresh-secret=7338782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E

# Token expiration times (in milliseconds)
# Access token: 1 hour = 3600000 ms
jwt.expiration=3600000
# Refresh token: 30 days = 2592000000 ms
jwt.refresh-expiration=2592000000

# CORS Configuration
#spring.web.cors.allowed-origins=http://localhost:3000
#spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
#spring.web.cors.allowed-headers=*
#spring.web.cors.allow-credentials=true

# CORS Configuration
cors.allowed-origins=http://localhost:3000

# Logging Configuration
logging.level.com.bht.ludonova=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
logging.level.org.springframework.security=DEBUG

# Steam Configuration
steam.api.key=${STEAM_API_KEY}
steam.return.url=${STEAM_RETURN_URL:http://localhost:3000/auth/steam/callback}
steam.realm.url=${STEAM_REALM_URL:http://localhost:3000}

# Swagger UI custom path
springdoc.swagger-ui.path=/swagger-ui.html
# Enable or disable Swagger UI
springdoc.swagger-ui.enabled=true
# Sort APIs alphabetically
springdoc.swagger-ui.operationsSorter=alpha
```

## File: .env.example
```
# Steam Configuration
STEAM_API_KEY=your_steam_api_key_here
STEAM_RETURN_URL=http://localhost:3000/auth/steam/callback
```

## File: .gitignore
```
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

### Environment Files ###
.env
application-local.properties
application-dev.properties
application-prod.properties

### Logs ###
*.log
logs/
log/

### Docker ###
docker-compose.override.yml

### OS generated files ###
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

### Java ###
# Compiled class file
*.class

# Package Files #
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar

# virtual machine crash logs
hs_err_pid*
replay_pid*
```

## File: docker-compose.yml
```yaml
version: '3.8'

services:
  postgres:
    image: postgres:16
    container_name: ludonova_db
    environment:
      POSTGRES_DB: ludonova
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

## File: ludonova-overview-backend.md
```markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-23T16:43:22.583Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Info

For more information about Repomix, visit: https://github.com/yamadashy/repomix

# Repository Structure
```
src/
  main/
    java/
      com/
        bht/
          ludonova/
            config/
              DataInitializer.java
              OpenAPIConfig.java
              WebConfig.java
            controller/
              AuthController.java
              GameController.java
              GameInstanceController.java
              SteamAuthController.java
              UserController.java
            dto/
              auth/
                AuthenticationResponse.java
                LoginRequest.java
                RefreshTokenRequest.java
                TokenResponse.java
              game/
                AdminGameUpdateDTO.java
                GameInstanceUpdateDTO.java
                GameUpdateDTO.java
              steam/
                SteamApiResponseDTO.java
                SteamAuthRequest.java
                SteamUserDTO.java
              user/
                UserDTO.java
                UserUpdateDTO.java
              ErrorResponse.java
            exception/
              AuthenticationException.java
              GlobalExceptionHandler.java
              LudoNovaException.java
              SteamAuthenticationException.java
              UnauthorizedException.java
            model/
              enums/
                GameSource.java
                GameStatus.java
                Platform.java
                Role.java
              Game.java
              GameInstance.java
              Review.java
              SteamUser.java
              User.java
            repository/
              GameInstanceRepository.java
              GameRepository.java
              ReviewRepository.java
              UserRepository.java
            security/
              AuthenticationExceptionHandler.java
              CustomUserDetailsService.java
              JwtAuthenticationFilter.java
              JwtTokenProvider.java
              SecurityConfig.java
            service/
              auth/
                AuthenticationStrategy.java
                BasicAuthenticationStrategy.java
                SteamAuthenticationStrategy.java
              AuthenticationService.java
              GameInstanceService.java
              GameService.java
              SteamService.java
              UserService.java
            LudoNovaApplication.java
    resources/
      db/
        migration/
          V1__create_base_schema.sql
      application.properties
.env.example
.gitignore
backend-overview.md
docker-compose.yml
ludonova-backend-overview.xml
pom.xml
README.md
setup.sh
```

# Repository Files

## File: src/main/java/com/bht/ludonova/config/DataInitializer.java
```java
package com.bht.ludonova.config;

import com.bht.ludonova.model.Game;
import com.bht.ludonova.model.GameInstance;
import com.bht.ludonova.model.User;
import com.bht.ludonova.model.enums.GameSource;
import com.bht.ludonova.model.enums.GameStatus;
import com.bht.ludonova.model.enums.Platform;
import com.bht.ludonova.model.enums.Role;
import com.bht.ludonova.repository.GameInstanceRepository;
import com.bht.ludonova.repository.GameRepository;
import com.bht.ludonova.repository.UserRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Set;

@Configuration
public class DataInitializer {
    private static final Logger log = LoggerFactory.getLogger(DataInitializer.class);

    @Bean
    CommandLineRunner initDatabase(
            UserRepository userRepository,
            GameRepository gameRepository,
            GameInstanceRepository gameInstanceRepository,
            PasswordEncoder passwordEncoder
    ) {
        return args -> {
            // Create regular test user if doesn't exist
            if (userRepository.findByUsername("test").isEmpty()) {
                User testUser = User.builder()
                        .username("test")
                        .password(passwordEncoder.encode("test123"))
                        .email("test@example.com")
                        .role(Role.USER)  // Set regular user role
                        .build();
                userRepository.save(testUser);
                log.info("Test user created successfully");
            }

            // Create admin user if doesn't exist
            if (userRepository.findByUsername("admin").isEmpty()) {
                User adminUser = User.builder()
                        .username("admin")
                        .password(passwordEncoder.encode("admin123"))
                        .email("admin@example.com")
                        .role(Role.ADMIN)  // Set admin role
                        .build();
                userRepository.save(adminUser);
                log.info("Admin user created successfully");
            }

            // Create test game
            Game testGame = Game.builder()
                    .title("Half-Life 2")
                    .platform(Platform.PC)
                    .apiId("220")
                    .source(GameSource.STEAM)
                    .releaseDate(LocalDate.of(2004, 11, 16))
                    .genres(Set.of("FPS", "Action", "Sci-Fi"))
                    .build();

            testGame = gameRepository.save(testGame);
            log.info("Test game created successfully");

            // Create game instance for test user
            User user = userRepository.findByUsername("test").get();
            if (!gameInstanceRepository.existsByUserIdAndGameId(user.getId(), testGame.getId())) {
                GameInstance instance = GameInstance.builder()
                        .user(user)
                        .game(testGame)
                        .status(GameStatus.PLAYING)
                        .progressPercentage(0)
                        .playTime(0)
                        .lastPlayed(LocalDateTime.now())
                        .notes("Just started playing")
                        .build();
                gameInstanceRepository.save(instance);
                log.info("Test game instance created successfully");
            }
        };
    }
}
```

## File: src/main/java/com/bht/ludonova/config/OpenAPIConfig.java
```java
package com.bht.ludonova.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenAPIConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("LudoNova API")
                        .version("1.0")
                        .description("API documentation for LudoNova game tracking application")
                        .license(new License().name("Private").url("https://ludonova.com")))
                .components(new Components()
                        .addSecuritySchemes("bearer-jwt", new SecurityScheme()
                                .type(SecurityScheme.Type.HTTP)
                                .scheme("bearer")
                                .bearerFormat("JWT")));
    }
}
```

## File: src/main/java/com/bht/ludonova/config/WebConfig.java
```java
package com.bht.ludonova.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
public class WebConfig {

    @Value("${cors.allowed-origins}")
    private List<String> allowedOrigins;

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(allowedOrigins);
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        configuration.setAllowedHeaders(List.of(
                "Authorization",
                "Content-Type",
                "X-Requested-With",
                "Accept",
                "Origin",
                "Access-Control-Request-Method",
                "Access-Control-Request-Headers"
        ));
        configuration.setExposedHeaders(List.of(
                "Access-Control-Allow-Origin",
                "Access-Control-Allow-Credentials"
        ));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", configuration);
        return source;
    }
}
```

## File: src/main/java/com/bht/ludonova/controller/AuthController.java
```java
package com.bht.ludonova.controller;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.RefreshTokenRequest;
import com.bht.ludonova.dto.auth.LoginRequest;
import com.bht.ludonova.service.AuthenticationService;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/auth")
@Slf4j
public class AuthController {
    private final AuthenticationService authService;

    public AuthController(AuthenticationService authService) {
        this.authService = authService;
    }

    @PostMapping("/login")
    public ResponseEntity<AuthenticationResponse> login(@Valid @RequestBody LoginRequest loginRequest) {
        Map<String, String> credentials = Map.of(
                "username", loginRequest.getUsername(),
                "password", loginRequest.getPassword()
        );

        AuthenticationResponse response = authService.authenticate("basic", credentials);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/refresh")
    public ResponseEntity<AuthenticationResponse> refresh(@Valid @RequestBody RefreshTokenRequest request) {
        AuthenticationResponse response = authService.refresh(request.getRefreshToken());
        return ResponseEntity.ok(response);
    }
}
```

## File: src/main/java/com/bht/ludonova/controller/GameController.java
```java
//package com.bht.ludonova.controller;
//
//import java.util.List;
//
//import org.springframework.http.ResponseEntity;
//import org.springframework.web.bind.annotation.DeleteMapping;
//import org.springframework.web.bind.annotation.GetMapping;
//import org.springframework.web.bind.annotation.PathVariable;
//import org.springframework.web.bind.annotation.PostMapping;
//import org.springframework.web.bind.annotation.PutMapping;
//import org.springframework.web.bind.annotation.RequestBody;
//import org.springframework.web.bind.annotation.RequestMapping;
//import org.springframework.web.bind.annotation.RestController;
//
//import com.bht.ludonova.model.Game;
//import com.bht.ludonova.model.enums.Platform;
//import com.bht.ludonova.service.GameService;
//
//import lombok.RequiredArgsConstructor;
//
//@RestController
//@RequestMapping("/api/games")
//@RequiredArgsConstructor
//public class GameController {
//    private final GameService gameService;
//
//    @GetMapping
//    public List<Game> getAllGames() {
//        return gameService.findAll();
//    }
//
//    @GetMapping("/{id}")
//    public ResponseEntity<Game> getGame(@PathVariable Long id) {
//        return gameService.findById(id)
//                .map(ResponseEntity::ok)
//                .orElse(ResponseEntity.notFound().build());
//    }
//
//    @GetMapping("/platform/{platform}")
//    public List<Game> getGamesByPlatform(@PathVariable Platform platform) {
//        return gameService.findByPlatform(platform);
//    }
//
//    @PostMapping
//    public ResponseEntity<Game> createGame(@RequestBody Game game) {
//        return ResponseEntity.ok(gameService.save(game));
//    }
//
//    @PutMapping("/{id}")
//    public ResponseEntity<Game> updateGame(@PathVariable Long id, @RequestBody Game game) {
//        if (!id.equals(game.getId())) {
//            return ResponseEntity.badRequest().build();
//        }
//        return ResponseEntity.ok(gameService.save(game));
//    }
//
//    @DeleteMapping("/{id}")
//    public ResponseEntity<Void> deleteGame(@PathVariable Long id) {
//        gameService.deleteById(id);
//        return ResponseEntity.noContent().build();
//    }
//}

package com.bht.ludonova.controller;

import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import com.bht.ludonova.model.Game;
import com.bht.ludonova.model.enums.Platform;
import com.bht.ludonova.service.GameService;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/games")
@RequiredArgsConstructor
@Tag(name = "Games", description = "API for managing games") // Tag for Swagger grouping
public class GameController {
    private final GameService gameService;

    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public List<Game> getAllGames() {
        return gameService.findAll();
    }

    @GetMapping("/{id}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Game> getGame(@PathVariable Long id) {
        return gameService.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/platform/{platform}")
    @PreAuthorize("isAuthenticated()")
    public List<Game> getGamesByPlatform(@PathVariable Platform platform) {
        return gameService.findByPlatform(platform);
    }

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Game> createGame(@RequestBody Game game) {
        return ResponseEntity.ok(gameService.save(game));
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Game> updateGame(@PathVariable Long id, @RequestBody Game game) {
        if (!id.equals(game.getId())) {
            return ResponseEntity.badRequest().build();
        }
        return ResponseEntity.ok(gameService.save(game));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> deleteGame(@PathVariable Long id) {
        gameService.deleteById(id);
        return ResponseEntity.noContent().build();
    }
}
```

## File: src/main/java/com/bht/ludonova/controller/GameInstanceController.java
```java
package com.bht.ludonova.controller;

import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.bht.ludonova.model.GameInstance;
import com.bht.ludonova.model.enums.GameStatus;
import com.bht.ludonova.service.GameInstanceService;

import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/game-instances")
@RequiredArgsConstructor
public class GameInstanceController {
    private final GameInstanceService gameInstanceService;

    @GetMapping("/user/{userId}")
    public List<GameInstance> getUserGameInstances(@PathVariable Long userId) {
        return gameInstanceService.findByUserId(userId);
    }

    @GetMapping("/user/{userId}/status/{status}")
    public List<GameInstance> getUserGameInstancesByStatus(
            @PathVariable Long userId,
            @PathVariable GameStatus status) {
        return gameInstanceService.findByUserIdAndStatus(userId, status);
    }

    @PostMapping
    public ResponseEntity<GameInstance> createGameInstance(@RequestBody GameInstance gameInstance) {
        return ResponseEntity.ok(gameInstanceService.save(gameInstance));
    }

    @PutMapping("/{id}")
    public ResponseEntity<GameInstance> updateGameInstance(
            @PathVariable Long id,
            @RequestBody GameInstance gameInstance) {
        if (!id.equals(gameInstance.getId())) {
            return ResponseEntity.badRequest().build();
        }
        return ResponseEntity.ok(gameInstanceService.save(gameInstance));
    }

    @PatchMapping("/{id}/status")
    public ResponseEntity<Void> updateGameStatus(
            @PathVariable Long id,
            @RequestParam GameStatus status) {
        gameInstanceService.updateStatus(id, status);
        return ResponseEntity.ok().build();
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteGameInstance(@PathVariable Long id) {
        gameInstanceService.deleteById(id);
        return ResponseEntity.noContent().build();
    }
}
```

## File: src/main/java/com/bht/ludonova/controller/SteamAuthController.java
```java
package com.bht.ludonova.controller;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.exception.SteamAuthenticationException;
import com.bht.ludonova.service.AuthenticationService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Map;

@RestController
@RequestMapping("/api/auth/steam")
@Slf4j
public class SteamAuthController {
    private final AuthenticationService authService;

    @Value("${steam.return.url}")
    private String returnUrl;

    @Value("${steam.realm.url}")
    private String realmUrl;

    public SteamAuthController(AuthenticationService authService) {
        this.authService = authService;
    }

    @GetMapping("/login")
    public ResponseEntity<Map<String, String>> steamLogin() {
        try {
            String steamOpenIdUrl = buildSteamOpenIdUrl();
            return ResponseEntity.ok(Map.of("url", steamOpenIdUrl));
        } catch (Exception e) {
            log.error("Error generating Steam login URL", e);
            throw new SteamAuthenticationException("Failed to generate Steam login URL");
        }
    }

    @GetMapping("/return")
    public ResponseEntity<AuthenticationResponse> steamReturn(@RequestParam Map<String, String> params) {
        log.debug("Received Steam return params: {}", params);
        AuthenticationResponse response = authService.authenticate("steam", params);
        return ResponseEntity.ok(response);
    }

    private String buildSteamOpenIdUrl() {
        try {
            String encodedReturnUrl = URLEncoder.encode(returnUrl, StandardCharsets.UTF_8);
            String encodedRealm = URLEncoder.encode(realmUrl, StandardCharsets.UTF_8);

            return String.format(
                    "https://steamcommunity.com/openid/login" +
                            "?openid.ns=%s" +
                            "&openid.mode=checkid_setup" +
                            "&openid.return_to=%s" +
                            "&openid.realm=%s" +
                            "&openid.identity=%s" +
                            "&openid.claimed_id=%s",
                    URLEncoder.encode("http://specs.openid.net/auth/2.0", StandardCharsets.UTF_8),
                    encodedReturnUrl,
                    encodedRealm,
                    URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8),
                    URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8)
            );
        } catch (Exception e) {
            log.error("Error building Steam OpenID URL", e);
            throw new SteamAuthenticationException("Failed to build Steam authentication URL");
        }
    }
}
```

## File: src/main/java/com/bht/ludonova/controller/UserController.java
```java
package com.bht.ludonova.controller;

import com.bht.ludonova.dto.user.UserUpdateDTO;
import com.bht.ludonova.model.User;
import com.bht.ludonova.model.enums.Role;
import com.bht.ludonova.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/user")
public class UserController {

    @Autowired
    private UserRepository userRepository;

    // Get current user's profile
    @GetMapping("/current")
    public ResponseEntity<User> getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
        return userRepository.findByUsername(userDetails.getUsername())
                .map(user -> {
                    user.setPassword(null);
                    return ResponseEntity.ok(user);
                })
                .orElse(ResponseEntity.notFound().build());
    }

    // Update current user's profile
    @PutMapping("/current")
    public ResponseEntity<User> updateCurrentUser(
            @AuthenticationPrincipal UserDetails userDetails,
            @RequestBody UserUpdateDTO updateDTO) {
        return userRepository.findByUsername(userDetails.getUsername())
                .map(user -> {
                    if (updateDTO.getEmail() != null) {
                        user.setEmail(updateDTO.getEmail());
                    }
                    // Don't allow role updates through this endpoint
                    User updatedUser = userRepository.save(user);
                    updatedUser.setPassword(null);
                    return ResponseEntity.ok(updatedUser);
                })
                .orElse(ResponseEntity.notFound().build());
    }

    // Admin endpoints below
    
    // Get all users (admin only)
    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<User>> getAllUsers() {
        List<User> users = userRepository.findAll();
        users.forEach(user -> user.setPassword(null));
        return ResponseEntity.ok(users);
    }

    // Get specific user (admin only)
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        return userRepository.findById(id)
                .map(user -> {
                    user.setPassword(null);
                    return ResponseEntity.ok(user);
                })
                .orElse(ResponseEntity.notFound().build());
    }

    // Update any user (admin only)
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<User> updateUser(
            @PathVariable Long id,
            @RequestBody UserUpdateDTO updateDTO) {
        return userRepository.findById(id)
                .map(user -> {
                    if (updateDTO.getEmail() != null) {
                        user.setEmail(updateDTO.getEmail());
                    }
                    if (updateDTO.getRole() != null) {
                        user.setRole(updateDTO.getRole());
                    }
                    User updatedUser = userRepository.save(user);
                    updatedUser.setPassword(null);
                    return ResponseEntity.ok(updatedUser);
                })
                .orElse(ResponseEntity.notFound().build());
    }

    // Delete user (admin only)
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        if (userRepository.existsById(id)) {
            userRepository.deleteById(id);
            return ResponseEntity.ok().build();
        }
        return ResponseEntity.notFound().build();
    }
}
```

## File: src/main/java/com/bht/ludonova/dto/auth/AuthenticationResponse.java
```java
package com.bht.ludonova.dto.auth;

import com.bht.ludonova.dto.user.UserDTO;
import lombok.Data;

@Data
public class AuthenticationResponse {
    private final TokenResponse tokens;
    private final UserDTO user;
}
```

## File: src/main/java/com/bht/ludonova/dto/auth/LoginRequest.java
```java
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class LoginRequest {
    private String username;
    private String password;
}
```

## File: src/main/java/com/bht/ludonova/dto/auth/RefreshTokenRequest.java
```java
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class RefreshTokenRequest {
    private String refreshToken;
}
```

## File: src/main/java/com/bht/ludonova/dto/auth/TokenResponse.java
```java
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class TokenResponse {
    private final String accessToken;
    private final String refreshToken;
    private final String tokenType;
    private final long expiresIn;

    public static TokenResponse of(String accessToken, String refreshToken, long expiresIn) {
        return new TokenResponse(accessToken, refreshToken, "Bearer", expiresIn);
    }
}
```

## File: src/main/java/com/bht/ludonova/dto/game/AdminGameUpdateDTO.java
```java
package com.bht.ludonova.dto.game;

import com.bht.ludonova.model.enums.GameSource;
import com.bht.ludonova.model.enums.Platform;
import lombok.Data;

import java.time.LocalDate;
import java.util.Set;

@Data
public class AdminGameUpdateDTO {
    private String title;
    private Platform platform;
    private LocalDate releaseDate;
    private Set<String> genres;
    private GameSource source;
    private String apiId;
}
```

## File: src/main/java/com/bht/ludonova/dto/game/GameInstanceUpdateDTO.java
```java
package com.bht.ludonova.dto.game;

import lombok.Data;

@Data
public class GameInstanceUpdateDTO {
    private String status;          // PLAYING, COMPLETED, BACKLOG, etc.
    private Integer progressPercentage;
    private Integer playTime;
    private String notes;
}
```

## File: src/main/java/com/bht/ludonova/dto/game/GameUpdateDTO.java
```java
package com.bht.ludonova.dto.game;

import com.bht.ludonova.model.enums.Platform;
import lombok.Data;

import java.util.Set;

@Data
public class GameUpdateDTO {
    private String title;
    private Platform platform;
    private Set<String> genres;
    // TODO evaluate, if these should be able to be updated by the user.
//    private LocalDate releaseDate;
//    private GameSource source;
}
```

## File: src/main/java/com/bht/ludonova/dto/steam/SteamApiResponseDTO.java
```java
package com.bht.ludonova.dto.steam;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.List;

@Data
public class SteamApiResponseDTO {
    private Response response;

    @Data
    public static class Response {
        private List<Player> players;
    }

    @Data
    public static class Player {
        @JsonProperty("steamid")
        private String steamId;

        @JsonProperty("personaname")
        private String personaName;

        @JsonProperty("profileurl")
        private String profileUrl;

        @JsonProperty("avatar")
        private String avatarUrl;
    }
}
```

## File: src/main/java/com/bht/ludonova/dto/steam/SteamAuthRequest.java
```java
package com.bht.ludonova.dto.steam;

import lombok.Data;

import java.util.Map;

@Data
public class SteamAuthRequest {
    private final Map<String, String> openIdParams;
}
```

## File: src/main/java/com/bht/ludonova/dto/steam/SteamUserDTO.java
```java
package com.bht.ludonova.dto.steam;

import lombok.Data;

@Data
public class SteamUserDTO {
    private String steamId;
    private String personaName;
    private String profileUrl;
    private String avatarUrl;
}
```

## File: src/main/java/com/bht/ludonova/dto/user/UserDTO.java
```java
package com.bht.ludonova.dto.user;

import com.bht.ludonova.dto.steam.SteamUserDTO;
import com.bht.ludonova.model.enums.Role;

import lombok.Data;

@Data
public class UserDTO {
    private Long id;
    private String username;
    private String email;
    private Role role;
    private SteamUserDTO steamUser;
}
```

## File: src/main/java/com/bht/ludonova/dto/user/UserUpdateDTO.java
```java
package com.bht.ludonova.dto.user;

import com.bht.ludonova.model.enums.Role;
import lombok.Data;

@Data
public class UserUpdateDTO {
    private String email;
    private Role role;  // Only used in admin endpoints
}
```

## File: src/main/java/com/bht/ludonova/dto/ErrorResponse.java
```java
package com.bht.ludonova.dto;

import lombok.Data;

@Data
public class ErrorResponse {
    private final String errorCode;
    private final String message;
    private final int status;
}
```

## File: src/main/java/com/bht/ludonova/exception/AuthenticationException.java
```java
package com.bht.ludonova.exception;

public class AuthenticationException extends LudoNovaException {
    public AuthenticationException(String message) {
        super(message, "AUTH_ERROR");
    }
}
```

## File: src/main/java/com/bht/ludonova/exception/GlobalExceptionHandler.java
```java
package com.bht.ludonova.exception;

import com.bht.ludonova.dto.ErrorResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {
        ErrorResponse error = new ErrorResponse(
                ex.getErrorCode(),
                ex.getMessage(),
                HttpStatus.UNAUTHORIZED.value()
        );
        return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(SteamAuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleSteamAuthenticationException(SteamAuthenticationException ex) {
        ErrorResponse error = new ErrorResponse(
                ex.getErrorCode(),
                ex.getMessage(),
                HttpStatus.UNAUTHORIZED.value()
        );
        return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        ErrorResponse error = new ErrorResponse(
                "INTERNAL_ERROR",
                "An unexpected error occurred",
                HttpStatus.INTERNAL_SERVER_ERROR.value()
        );
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

## File: src/main/java/com/bht/ludonova/exception/LudoNovaException.java
```java
package com.bht.ludonova.exception;

public class LudoNovaException extends RuntimeException {
    private final String errorCode;

    public LudoNovaException(String message, String errorCode) {
        super(message);
        this.errorCode = errorCode;
    }

    public String getErrorCode() {
        return errorCode;
    }
}
```

## File: src/main/java/com/bht/ludonova/exception/SteamAuthenticationException.java
```java
package com.bht.ludonova.exception;

public class SteamAuthenticationException extends AuthenticationException {
    public SteamAuthenticationException(String message) {
        super("Steam authentication failed: " + message);
    }
}
```

## File: src/main/java/com/bht/ludonova/exception/UnauthorizedException.java
```java
package com.bht.ludonova.exception;

public class UnauthorizedException extends RuntimeException {
    public UnauthorizedException(String message) {
        super(message);
    }
}
```

## File: src/main/java/com/bht/ludonova/model/enums/GameSource.java
```java
package com.bht.ludonova.model.enums;

import lombok.Getter;

@Getter
public enum GameSource {
    STEAM,
    RAWG,
    MANUAL
}
```

## File: src/main/java/com/bht/ludonova/model/enums/GameStatus.java
```java
package com.bht.ludonova.model.enums;

import lombok.Getter;

@Getter
public enum GameStatus {
    PLAYING,
    COMPLETED,
    PLAN_TO_PLAY,
    DROPPED
}
```

## File: src/main/java/com/bht/ludonova/model/enums/Platform.java
```java
package com.bht.ludonova.model.enums;

import lombok.Getter;


@Getter
public enum Platform {
    // Sony PlayStation
    PS1("PlayStation"),
    PS2("PlayStation 2"),
    PS3("PlayStation 3"),
    PS4("PlayStation 4"),
    PS5("PlayStation 5"),

    // Microsoft Xbox
    XBOX("Xbox"),
    XBOX_360("Xbox 360"),
    XBOX_ONE("Xbox One"),
    XBOX_SERIES_X("Xbox Series X"),
    XBOX_SERIES_S("Xbox Series S"),

    // Nintendo
    SWITCH("Nintendo Switch"),
    WII("Nintendo Wii"),
    WII_U("Nintendo Wii U"),
    NINTENDO_3DS("Nintendo 3DS"),
    NINTENDO_DS("Nintendo DS"),

    // PC Platforms
    PC("PC"),
    MAC("Mac"),
    LINUX("Linux");

    private final String displayName;

    Platform(String displayName) {
        this.displayName = displayName;
    }

}
```

## File: src/main/java/com/bht/ludonova/model/enums/Role.java
```java
package com.bht.ludonova.model.enums;

import lombok.Getter;

@Getter
public enum Role {
    USER,
    ADMIN
}
```

## File: src/main/java/com/bht/ludonova/model/Game.java
```java
package com.bht.ludonova.model;

import com.bht.ludonova.model.enums.GameSource;
import com.bht.ludonova.model.enums.Platform;
import jakarta.persistence.*;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "games")
public class Game {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Platform platform;

    @Column(name = "api_id")
    private String apiId;  // Steam AppId or RAWG ID

    @Column(name = "release_date")
    private LocalDate releaseDate;

    @ElementCollection
    @CollectionTable(name = "game_genres",
            joinColumns = @JoinColumn(name = "game_id"))
    @Column(name = "genre")
    @Builder.Default
    private Set<String> genres = new HashSet<>();

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private GameSource source;

    @OneToMany(mappedBy = "game")
    @Builder.Default
    private Set<GameInstance> instances = new HashSet<>();
}
```

## File: src/main/java/com/bht/ludonova/model/GameInstance.java
```java
package com.bht.ludonova.model;

import com.bht.ludonova.model.enums.GameStatus;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "game_instances")
public class GameInstance {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "game_id", nullable = false)
    private Game game;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private GameStatus status;

    @Column(name = "progress_percentage")
    private Integer progressPercentage;

    @Column(name = "play_time")
    private Integer playTime;

    @Column(name = "last_played")
    private LocalDateTime lastPlayed;

    private String notes;
}
```

## File: src/main/java/com/bht/ludonova/model/Review.java
```java
package com.bht.ludonova.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "reviews")
public class Review {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "game_id", nullable = false)
    private Game game;

    @Min(1)
    @Max(5)
    private Integer rating;

    @Column(name = "review_text")
    private String reviewText;

    @Column(name = "created_at")
    private LocalDateTime createdAt;
}
```

## File: src/main/java/com/bht/ludonova/model/SteamUser.java
```java
package com.bht.ludonova.model;

import lombok.Data;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;

@Data
@Entity
@Table(name = "steam_users")
public class SteamUser {
    @Id
    private String steamId;
    
    private String personaName;
    private String profileUrl;
    private String avatarUrl;
    
    @OneToOne(mappedBy = "steamUser")
    private User user;
}
```

## File: src/main/java/com/bht/ludonova/model/User.java
```java
package com.bht.ludonova.model;

import com.bht.ludonova.model.enums.Role;
import jakarta.persistence.*;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    @Column
    private String email;

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "steam_id")
    private SteamUser steamUser;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role = Role.USER;  // Default to USER role
}
```

## File: src/main/java/com/bht/ludonova/repository/GameInstanceRepository.java
```java
package com.bht.ludonova.repository;

import com.bht.ludonova.model.GameInstance;
import com.bht.ludonova.model.enums.GameStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface GameInstanceRepository extends JpaRepository<GameInstance, Long> {
    List<GameInstance> findByUserId(Long userId);
    Optional<GameInstance> findByUserIdAndGameId(Long userId, Long gameId);
    boolean existsByUserIdAndGameId(Long userId, Long gameId);

    @Query("SELECT gi FROM GameInstance gi WHERE gi.user.id = :userId AND gi.status = :status")
    List<GameInstance> findByUserIdAndStatus(Long userId, GameStatus status);
}
```

## File: src/main/java/com/bht/ludonova/repository/GameRepository.java
```java
package com.bht.ludonova.repository;

import com.bht.ludonova.model.Game;
import com.bht.ludonova.model.enums.GameSource;
import com.bht.ludonova.model.enums.Platform;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface GameRepository extends JpaRepository<Game, Long> {
    Optional<Game> findByApiIdAndSource(String apiId, GameSource source);
    List<Game> findByPlatform(Platform platform);
}
```

## File: src/main/java/com/bht/ludonova/repository/ReviewRepository.java
```java
package com.bht.ludonova.repository;

import com.bht.ludonova.model.Review;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ReviewRepository extends JpaRepository<Review, Long> {
    List<Review> findByGameId(Long gameId);
    List<Review> findByUserId(Long userId);
    Optional<Review> findByUserIdAndGameId(Long userId, Long gameId);
}
```

## File: src/main/java/com/bht/ludonova/repository/UserRepository.java
```java
package com.bht.ludonova.repository;

import com.bht.ludonova.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findBySteamUser_SteamId(String steamId);
}
```

## File: src/main/java/com/bht/ludonova/security/AuthenticationExceptionHandler.java
```java
package com.bht.ludonova.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Component
public class AuthenticationExceptionHandler implements AuthenticationEntryPoint, AccessDeniedHandler {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        log.error("Unauthorized error: {}", authException.getMessage());

        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

        Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
        body.put("error", "Unauthorized");
        body.put("message", authException.getMessage());
        body.put("path", request.getServletPath());

        objectMapper.writeValue(response.getOutputStream(), body);
    }

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response,
                       AccessDeniedException accessDeniedException) throws IOException, ServletException {
        log.error("Access denied error: {}", accessDeniedException.getMessage());

        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);

        Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_FORBIDDEN);
        body.put("error", "Forbidden");
        body.put("message", accessDeniedException.getMessage());
        body.put("path", request.getServletPath());

        objectMapper.writeValue(response.getOutputStream(), body);
    }
}
```

## File: src/main/java/com/bht/ludonova/security/CustomUserDetailsService.java
```java
package com.bht.ludonova.security;

import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;

@Slf4j
@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));

        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getUsername())
                .password(user.getPassword())
                .authorities(Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")))
                .accountExpired(false)
                .accountLocked(false)
                .credentialsExpired(false)
                .disabled(false)
                .build();
    }
}
```

## File: src/main/java/com/bht/ludonova/security/JwtAuthenticationFilter.java
```java
package com.bht.ludonova.security;

import com.bht.ludonova.exception.AuthenticationException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider tokenProvider;
    private final CustomUserDetailsService customUserDetailsService;
    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    // List of paths that don't require authentication
    private final List<String> publicPaths = Arrays.asList(
            "/api/auth/**",
            "/api/test/public"
    );

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getServletPath();
        return publicPaths.stream()
                .anyMatch(pattern -> pathMatcher.match(pattern, path));
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt)) {
                if (!tokenProvider.validateToken(jwt)) {
                    throw new AuthenticationException("Invalid or expired JWT token");
                }

                String username = tokenProvider.getUsernameFromToken(jwt);
                UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);

                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                        );
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            log.error("Could not set user authentication in security context", ex);
            SecurityContextHolder.clearContext();

            if (ex instanceof AuthenticationException) {
                throw ex;
            }
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }

    /**
     * Helper method to check if token is about to expire
     * Could be used to implement token refresh logic
     */
    private boolean shouldRefreshToken(String token) {
        return tokenProvider.isTokenExpired(token, false);
    }
}
```

## File: src/main/java/com/bht/ludonova/security/JwtTokenProvider.java
```java
package com.bht.ludonova.security;


import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Component
public class JwtTokenProvider {

    private final SecretKey accessTokenKey;
    private final SecretKey refreshTokenKey;
    private final long accessTokenExpirationMs; // Changed to long
    private final long refreshTokenExpirationMs; // Changed to long

    public JwtTokenProvider(
            @Value("${jwt.secret}") String jwtSecret,
            @Value("${jwt.refresh-secret:${jwt.secret}}") String refreshSecret,
            @Value("${jwt.expiration}") long accessTokenExpirationMs, // Changed to long
            @Value("${jwt.refresh-expiration:2592000000}") long refreshTokenExpirationMs) { // Changed to long
        this.accessTokenKey = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
        this.refreshTokenKey = Keys.hmacShaKeyFor(refreshSecret.getBytes(StandardCharsets.UTF_8));
        this.accessTokenExpirationMs = accessTokenExpirationMs;
        this.refreshTokenExpirationMs = refreshTokenExpirationMs;
    }

    public String generateAccessToken(Authentication authentication) {
        return generateAccessToken(authentication.getName(), createClaims(authentication));
    }

    public String generateAccessToken(String username) {
        return generateAccessToken(username, new HashMap<>());
    }

    public String generateAccessToken(String username, Map<String, Object> claims) {
        return generateToken(username, claims, accessTokenKey, accessTokenExpirationMs);
    }

    public String generateRefreshToken(String username) {
        return generateToken(username, new HashMap<>(), refreshTokenKey, refreshTokenExpirationMs);
    }

    private String generateToken(String username, Map<String, Object> claims, SecretKey key, long expirationMs) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expirationMs);

        return Jwts.builder()
                .setClaims(claims)
                .setSubject(username)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();
    }

    private Map<String, Object> createClaims(Authentication authentication) {
        Map<String, Object> claims = new HashMap<>();

        // Add user authorities/roles
        String authorities = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(","));
        claims.put("authorities", authorities);

        // Add token type
        claims.put("type", "Bearer");

        return claims;
    }

    public String getUsernameFromToken(String token, boolean isRefreshToken) {
        return getClaimsFromToken(token, isRefreshToken).getSubject();
    }

    public String getUsernameFromToken(String token) {
        return getUsernameFromToken(token, false);
    }

    public boolean validateToken(String token) {
        return validateToken(token, false);
    }

    public boolean validateToken(String token, boolean isRefreshToken) {
        try {
            SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
            Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(token);
            return true;
        } catch (SignatureException e) {
            log.error("Invalid JWT signature: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            log.error("Invalid JWT token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            log.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            log.error("JWT token is unsupported: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            log.error("JWT claims string is empty: {}", e.getMessage());
        }
        return false;
    }

    public Claims getClaimsFromToken(String token, boolean isRefreshToken) {
        SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
        return Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    public boolean isTokenExpired(String token, boolean isRefreshToken) {
        try {
            Claims claims = getClaimsFromToken(token, isRefreshToken);
            return claims.getExpiration().before(new Date());
        } catch (ExpiredJwtException e) {
            return true;
        }
    }

    public long getAccessTokenExpirationMs() {
        return accessTokenExpirationMs;
    }

    public long getRefreshTokenExpirationMs() {
        return refreshTokenExpirationMs;
    }
}
```

## File: src/main/java/com/bht/ludonova/security/SecurityConfig.java
```java
package com.bht.ludonova.security;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfigurationSource;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;
    private final JwtAuthenticationFilter jwtAuthFilter;
    private final CorsConfigurationSource corsConfigurationSource;
    private final AuthenticationExceptionHandler authenticationExceptionHandler;

//    @Bean
//    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
//        return http
//                .cors(cors -> cors.configurationSource(corsConfigurationSource))
//                .csrf(csrf -> csrf.disable())
//                .authorizeHttpRequests(auth -> auth
//                        // Public endpoints
//                        .requestMatchers(
//                                "/api/auth/login",
//                                "/api/auth/refresh",
//                                "/api/auth/steam/login",
//                                "/api/auth/steam/return"
//                        ).permitAll()
//                        .requestMatchers("/api/test/public").permitAll()
//                        // Protected endpoints
//                        .requestMatchers("/api/games/**").authenticated()
//                        .requestMatchers("/api/user/**").authenticated()
//                        .anyRequest().authenticated()
//                )
//                .sessionManagement(session -> session
//                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
//                )
//                .authenticationProvider(authenticationProvider())
//                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
//                .exceptionHandling(exc -> exc
//                        .authenticationEntryPoint(authenticationExceptionHandler)
//                        .accessDeniedHandler(authenticationExceptionHandler)
//                )
//                .build();
//    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        return http
                .cors(cors -> cors.configurationSource(corsConfigurationSource))
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        // Public endpoints
                        .requestMatchers(
                                "/api/auth/login",
                                "/api/auth/refresh",
                                "/api/auth/steam/login",
                                "/api/auth/steam/return",
                                // Swagger UI and OpenAPI endpoints
                                "/swagger-ui/**",
                                "/v3/api-docs/**",
                                "/swagger-ui.html"
                        ).permitAll()
                        // Protected endpoints
                        .requestMatchers("/api/games/**").authenticated()
                        .requestMatchers("/api/user/**").authenticated()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authenticationProvider(authenticationProvider())
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exc -> exc
                        .authenticationEntryPoint(authenticationExceptionHandler)
                        .accessDeniedHandler(authenticationExceptionHandler)
                )
                .build();
    }


    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}
```

## File: src/main/java/com/bht/ludonova/service/auth/AuthenticationStrategy.java
```java
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;

import java.util.Map;

public interface AuthenticationStrategy {
    AuthenticationResponse authenticate(Map<String, String> credentials);
    AuthenticationResponse refresh(String refreshToken);
}
```

## File: src/main/java/com/bht/ludonova/service/auth/BasicAuthenticationStrategy.java
```java
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.TokenResponse;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.exception.AuthenticationException;
import com.bht.ludonova.security.JwtTokenProvider;
import com.bht.ludonova.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class BasicAuthenticationStrategy implements AuthenticationStrategy {
    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider tokenProvider;
    private final UserService userService;

    public BasicAuthenticationStrategy(
            AuthenticationManager authenticationManager,
            JwtTokenProvider tokenProvider,
            UserService userService) {
        this.authenticationManager = authenticationManager;
        this.tokenProvider = tokenProvider;
        this.userService = userService;
    }

    @Override
    public AuthenticationResponse authenticate(Map<String, String> credentials) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            credentials.get("username"),
                            credentials.get("password")
                    )
            );
            SecurityContextHolder.getContext().setAuthentication(authentication);

            String accessToken = tokenProvider.generateAccessToken(authentication);
            String refreshToken = tokenProvider.generateRefreshToken(authentication.getName());
            UserDTO user = userService.getCurrentUserDTO();

            TokenResponse tokens = TokenResponse.of(
                    accessToken,
                    refreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, user);
        } catch (org.springframework.security.core.AuthenticationException e) {
            log.error("Authentication failed", e);
            throw new AuthenticationException("Invalid username or password");
        }
    }

    @Override
    public AuthenticationResponse refresh(String refreshToken) {
        try {
            if (!tokenProvider.validateToken(refreshToken, true)) {
                throw new AuthenticationException("Invalid refresh token");
            }

            String username = tokenProvider.getUsernameFromToken(refreshToken, true);
            UserDTO user = userService.getUserDTOByUsername(username);

            String newAccessToken = tokenProvider.generateAccessToken(username);
            String newRefreshToken = tokenProvider.generateRefreshToken(username);

            TokenResponse tokens = TokenResponse.of(
                    newAccessToken,
                    newRefreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, user);
        } catch (Exception e) {
            log.error("Token refresh failed", e);
            throw new AuthenticationException("Failed to refresh token");
        }
    }
}
```

## File: src/main/java/com/bht/ludonova/service/auth/SteamAuthenticationStrategy.java
```java
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.TokenResponse;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.exception.SteamAuthenticationException;
import com.bht.ludonova.model.SteamUser;
import com.bht.ludonova.model.User;
import com.bht.ludonova.security.JwtTokenProvider;
import com.bht.ludonova.service.SteamService;
import com.bht.ludonova.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class SteamAuthenticationStrategy implements AuthenticationStrategy {
    private final SteamService steamService;
    private final UserService userService;
    private final JwtTokenProvider tokenProvider;

    public SteamAuthenticationStrategy(
            SteamService steamService,
            UserService userService,
            JwtTokenProvider tokenProvider) {
        this.steamService = steamService;
        this.userService = userService;
        this.tokenProvider = tokenProvider;
    }

    @Override
    public AuthenticationResponse authenticate(Map<String, String> openIdParams) {
        try {
            log.debug("Starting Steam authentication with params: {}", openIdParams);

            if (!steamService.validateSteamResponse(openIdParams)) {
                log.error("Steam validation failed");
                throw new SteamAuthenticationException("Invalid Steam response");
            }

            log.debug("Steam response validated successfully");
            String steamId = extractSteamId(openIdParams);

            if (steamId == null) {
                log.error("Could not extract Steam ID from params");
                throw new SteamAuthenticationException("Could not extract Steam ID");
            }

            log.debug("Extracted Steam ID: {}", steamId);
            SteamUser steamUser = steamService.fetchUserDetails(steamId);
            log.debug("Fetched Steam user details: {}", steamUser);

            User user = userService.getOrCreateSteamUser(steamUser);
            log.debug("Got/Created user: {}", user);

            String accessToken = tokenProvider.generateAccessToken(user.getUsername());
            String refreshToken = tokenProvider.generateRefreshToken(user.getUsername());
            UserDTO userDTO = userService.convertToDTO(user);

            log.debug("Generated tokens and converted user to DTO");

            TokenResponse tokens = TokenResponse.of(
                    accessToken,
                    refreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, userDTO);
        } catch (Exception e) {
            log.error("Steam authentication failed", e);
            throw new SteamAuthenticationException(e.getMessage());
        }
    }

    @Override
    public AuthenticationResponse refresh(String refreshToken) {
        return null; // Steam users use the same refresh mechanism as basic auth
    }

    private String extractSteamId(Map<String, String> params) {
        String identity = params.get("openid.claimed_id");
        if (identity != null && identity.matches("https://steamcommunity.com/openid/id/\\d+")) {
            return identity.substring(identity.lastIndexOf("/") + 1);
        }
        return null;
    }
}
```

## File: src/main/java/com/bht/ludonova/service/AuthenticationService.java
```java
package com.bht.ludonova.service;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.exception.AuthenticationException;
import com.bht.ludonova.service.auth.AuthenticationStrategy;
import com.bht.ludonova.service.auth.BasicAuthenticationStrategy;
import com.bht.ludonova.service.auth.SteamAuthenticationStrategy;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class AuthenticationService {
    private final Map<String, AuthenticationStrategy> authenticationStrategies;

    public AuthenticationService(
            BasicAuthenticationStrategy basicAuthStrategy,
            SteamAuthenticationStrategy steamAuthStrategy) {
        this.authenticationStrategies = Map.of(
                "basic", basicAuthStrategy,
                "steam", steamAuthStrategy
        );
    }

    public AuthenticationResponse authenticate(String strategy, Map<String, String> credentials) {
        AuthenticationStrategy authStrategy = authenticationStrategies.get(strategy);
        if (authStrategy == null) {
            throw new AuthenticationException("Unsupported authentication strategy: " + strategy);
        }

        return authStrategy.authenticate(credentials);
    }

    public AuthenticationResponse refresh(String refreshToken) {
        // We use the basic strategy for refresh tokens as the mechanism is the same
        return authenticationStrategies.get("basic").refresh(refreshToken);
    }
}
```

## File: src/main/java/com/bht/ludonova/service/GameInstanceService.java
```java
package com.bht.ludonova.service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import lombok.RequiredArgsConstructor;

import com.bht.ludonova.model.GameInstance;
import com.bht.ludonova.model.enums.GameStatus;
import com.bht.ludonova.repository.GameInstanceRepository;

@Service
@Transactional
@RequiredArgsConstructor
public class GameInstanceService {
    private final GameInstanceRepository gameInstanceRepository;

    public GameInstance save(GameInstance gameInstance) {
        if (gameInstance.getStatus() == GameStatus.PLAYING) {
            gameInstance.setLastPlayed(LocalDateTime.now());
        }
        return gameInstanceRepository.save(gameInstance);
    }

    public Optional<GameInstance> findById(Long id) {
        return gameInstanceRepository.findById(id);
    }

    public List<GameInstance> findByUserId(Long userId) {
        return gameInstanceRepository.findByUserId(userId);
    }

    public List<GameInstance> findByUserIdAndStatus(Long userId, GameStatus status) {
        return gameInstanceRepository.findByUserIdAndStatus(userId, status);
    }

    public Optional<GameInstance> findByUserIdAndGameId(Long userId, Long gameId) {
        return gameInstanceRepository.findByUserIdAndGameId(userId, gameId);
    }

    public boolean existsByUserIdAndGameId(Long userId, Long gameId) {
        return gameInstanceRepository.existsByUserIdAndGameId(userId, gameId);
    }

    public void updateStatus(Long id, GameStatus newStatus) {
        findById(id).ifPresent(instance -> {
            instance.setStatus(newStatus);
            if (newStatus == GameStatus.PLAYING) {
                instance.setLastPlayed(LocalDateTime.now());
            }
            save(instance);
        });
    }

    public void deleteById(Long id) {
        gameInstanceRepository.deleteById(id);
    }
}
```

## File: src/main/java/com/bht/ludonova/service/GameService.java
```java
package com.bht.ludonova.service;

import java.util.List;
import java.util.Optional;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.bht.ludonova.model.Game;
import com.bht.ludonova.model.enums.GameSource;
import com.bht.ludonova.model.enums.Platform;
import com.bht.ludonova.repository.GameRepository;

import lombok.RequiredArgsConstructor;

@Service
@Transactional
@RequiredArgsConstructor
public class GameService {
    private final GameRepository gameRepository;

    public Game save(Game game) {
        return gameRepository.save(game);
    }

    public Optional<Game> findById(Long id) {
        return gameRepository.findById(id);
    }

    public List<Game> findAll() {
        return gameRepository.findAll();
    }

    public List<Game> findByPlatform(Platform platform) {
        return gameRepository.findByPlatform(platform);
    }

    public Optional<Game> findByApiIdAndSource(String apiId, GameSource source) {
        return gameRepository.findByApiIdAndSource(apiId, source);
    }

    public void deleteById(Long id) {
        gameRepository.deleteById(id);
    }
}
```

## File: src/main/java/com/bht/ludonova/service/SteamService.java
```java
package com.bht.ludonova.service;

import com.bht.ludonova.dto.steam.SteamApiResponseDTO;
import com.bht.ludonova.exception.SteamAuthenticationException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import com.bht.ludonova.model.SteamUser;
import lombok.extern.slf4j.Slf4j;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Service
public class SteamService {
    @Value("${steam.api.key}")
    private String steamApiKey;

    private final WebClient steamApiClient;
    private final WebClient openIdClient;

    public SteamService() {
        this.steamApiClient = WebClient.builder()
                .baseUrl("https://api.steampowered.com")
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
                .build();

        this.openIdClient = WebClient.builder()
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
                .build();
    }

    public boolean validateSteamResponse(Map<String, String> params) {
        try {
            log.info("Validating Steam response with params: {}", params);
            String url = "https://steamcommunity.com/openid/login";

            // Create a new map with check_authentication mode
            Map<String, String> validationParams = new HashMap<>(params);
            validationParams.put("openid.mode", "check_authentication");

            // Convert map to form data
            String formData = validationParams.entrySet().stream()
                    .map(entry -> entry.getKey() + "=" + encodeValue(entry.getValue()))
                    .collect(Collectors.joining("&"));

            String responseBody = openIdClient.post()
                    .uri(url)
                    .header("Content-Type", "application/x-www-form-urlencoded")
                    .bodyValue(formData)
                    .retrieve()
                    .bodyToMono(String.class)
                    .block();

            log.info("Steam validation response: {}", responseBody);
            return responseBody != null && responseBody.contains("is_valid:true");
        } catch (Exception e) {
            log.error("Error validating Steam response", e);
            return false;
        }
    }

    public SteamUser fetchUserDetails(String steamId) {
        String url = "/ISteamUser/GetPlayerSummaries/v2/";

        try {
            SteamApiResponseDTO dto = steamApiClient.get()
                    .uri(uriBuilder -> uriBuilder
                            .path(url)
                            .queryParam("key", steamApiKey)
                            .queryParam("steamids", steamId)
                            .build())
                    .retrieve()
                    .bodyToMono(SteamApiResponseDTO.class)
                    .block();

            if (dto != null && dto.getResponse() != null && !dto.getResponse().getPlayers().isEmpty()) {
                SteamApiResponseDTO.Player player = dto.getResponse().getPlayers().get(0);
                return mapToSteamUser(player);
            }

            throw new SteamApiException("Failed to fetch Steam user details");
        } catch (Exception e) {
            log.error("Error fetching Steam user details", e);
            throw new SteamApiException("Failed to fetch Steam user details", e);
        }
    }

    private String encodeValue(String value) {
        try {
            return URLEncoder.encode(value, StandardCharsets.UTF_8.toString());
        } catch (UnsupportedEncodingException e) {
            return value;
        }
    }

    private SteamUser mapToSteamUser(SteamApiResponseDTO.Player player) {
        SteamUser steamUser = new SteamUser();
        steamUser.setSteamId(player.getSteamId());
        steamUser.setPersonaName(player.getPersonaName());
        steamUser.setProfileUrl(player.getProfileUrl());
        steamUser.setAvatarUrl(player.getAvatarUrl());
        return steamUser;
    }

    public static class SteamApiException extends RuntimeException {
        public SteamApiException(String message) {
            super(message);
        }

        public SteamApiException(String message, Throwable cause) {
            super(message, cause);
        }
    }
}
```

## File: src/main/java/com/bht/ludonova/service/UserService.java
```java
package com.bht.ludonova.service;

import com.bht.ludonova.dto.steam.SteamUserDTO;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.dto.user.UserUpdateDTO;
import com.bht.ludonova.exception.AuthenticationException;
import com.bht.ludonova.exception.UnauthorizedException;
import com.bht.ludonova.model.enums.Role;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.bht.ludonova.model.SteamUser;
import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@Transactional
public class UserService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    public User getOrCreateSteamUser(SteamUser steamUser) {
        return userRepository.findBySteamUser_SteamId(steamUser.getSteamId())
                .orElseGet(() -> createSteamUser(steamUser));
    }

    private User createSteamUser(SteamUser steamUser) {
        User user = new User();
        user.setUsername("steam_" + steamUser.getSteamId());
        user.setPassword(passwordEncoder.encode(UUID.randomUUID().toString()));
        user.setRole(Role.USER);
        user.setSteamUser(steamUser);
        return userRepository.save(user);
    }

    public UserDTO getCurrentUserDTO() {
        String username = SecurityContextHolder.getContext().getAuthentication().getName();
        return userRepository.findByUsername(username)
                .map(this::convertToDTO)
                .orElseThrow(() -> new AuthenticationException("User not found"));
    }

    public UserDTO getUserDTOByUsername(String username) {
        return userRepository.findByUsername(username)
                .map(this::convertToDTO)
                .orElseThrow(() -> new AuthenticationException("User not found: " + username));
    }

    public UserDTO convertToDTO(User user) {
        UserDTO dto = new UserDTO();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());
        dto.setRole(user.getRole());

        if (user.getSteamUser() != null) {
            SteamUserDTO steamUserDTO = new SteamUserDTO();
            steamUserDTO.setSteamId(user.getSteamUser().getSteamId());
            steamUserDTO.setPersonaName(user.getSteamUser().getPersonaName());
            steamUserDTO.setProfileUrl(user.getSteamUser().getProfileUrl());
            steamUserDTO.setAvatarUrl(user.getSteamUser().getAvatarUrl());
            dto.setSteamUser(steamUserDTO);
        }

        return dto;
    }

    public List<UserDTO> getAllUsers() {
        checkAdminAccess();
        return userRepository.findAll().stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    public UserDTO getUserById(Long id) {
        checkAdminAccess();
        return userRepository.findById(id)
                .map(this::convertToDTO)
                .orElseThrow(() -> new AuthenticationException("User not found: " + id));
    }

    public UserDTO updateUser(Long id, UserUpdateDTO updateDTO) {
        User currentUser = getCurrentUser();
        User userToUpdate = userRepository.findById(id)
                .orElseThrow(() -> new AuthenticationException("User not found: " + id));

        if (!currentUser.getRole().equals(Role.ADMIN) && !currentUser.getId().equals(id)) {
            throw new UnauthorizedException("You can only update your own profile");
        }

        if (updateDTO.getRole() != null) {
            if (!currentUser.getRole().equals(Role.ADMIN)) {
                throw new UnauthorizedException("Only admins can update roles");
            }
            userToUpdate.setRole(updateDTO.getRole());
        }

        if (updateDTO.getEmail() != null) {
            userToUpdate.setEmail(updateDTO.getEmail());
        }

        return convertToDTO(userRepository.save(userToUpdate));
    }

    public void deleteUser(Long id) {
        checkAdminAccess();
        userRepository.deleteById(id);
    }

    private User getCurrentUser() {
        String username = SecurityContextHolder.getContext().getAuthentication().getName();
        return userRepository.findByUsername(username)
                .orElseThrow(() -> new AuthenticationException("User not found"));
    }

    private void checkAdminAccess() {
        User currentUser = getCurrentUser();
        if (!currentUser.getRole().equals(Role.ADMIN)) {
            throw new UnauthorizedException("Admin access required");
        }
    }
}
```

## File: src/main/java/com/bht/ludonova/LudoNovaApplication.java
```java
package com.bht.ludonova;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@SpringBootApplication
@EntityScan("com.bht.ludonova.model")
@EnableJpaRepositories("com.bht.ludonova.repository")
public class LudoNovaApplication {
    public static void main(String[] args) {
        SpringApplication.run(LudoNovaApplication.class, args);
    }
}
```

## File: src/main/resources/db/migration/V1__create_base_schema.sql
```sql
-- Steam Users table first (because it's referenced by users)
CREATE TABLE IF NOT EXISTS steam_users (
    steam_id VARCHAR(255) PRIMARY KEY,
    persona_name VARCHAR(255),
    profile_url VARCHAR(255),
    avatar_url VARCHAR(255)
);

-- Then Users table (with the foreign key)
CREATE TABLE IF NOT EXISTS users (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(255) NOT NULL UNIQUE,
    email VARCHAR(255),
    password VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL DEFAULT 'USER',
    steam_id VARCHAR(255) REFERENCES steam_users(steam_id),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Games and related tables
CREATE TABLE games (
                       id BIGSERIAL PRIMARY KEY,
                       title VARCHAR(255) NOT NULL,
                       platform VARCHAR(50) NOT NULL,
                       api_id VARCHAR(100),
                       release_date DATE,
                       source VARCHAR(20) NOT NULL,
                       created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE game_genres (
                             game_id BIGINT REFERENCES games(id) ON DELETE CASCADE,
                             genre VARCHAR(50),
                             PRIMARY KEY (game_id, genre)
);

CREATE TABLE game_instances (
                                id BIGSERIAL PRIMARY KEY,
                                user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
                                game_id BIGINT REFERENCES games(id) ON DELETE CASCADE,
                                status VARCHAR(20) NOT NULL,
                                progress_percentage INTEGER CHECK (progress_percentage BETWEEN 0 AND 100),
                                play_time INTEGER,
                                last_played TIMESTAMP,
                                notes TEXT,
                                created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                                updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                                UNIQUE(user_id, game_id)
);

-- Reviews table
CREATE TABLE reviews (
                         id BIGSERIAL PRIMARY KEY,
                         user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
                         game_id BIGINT REFERENCES games(id) ON DELETE CASCADE,
                         rating INTEGER CHECK (rating BETWEEN 1 AND 5),
                         review_text TEXT,
                         created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                         updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                         UNIQUE(user_id, game_id)
);
```

## File: src/main/resources/application.properties
```
# Server Configuration
server.port=8080

# PostgreSQL Database Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=postgres
spring.datasource.password=postgres

# JPA/Hibernate Configuration
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Flyway Configuration
spring.flyway.enabled=true
spring.flyway.baseline-on-migrate=true
spring.flyway.clean-disabled=false
spring.flyway.locations=classpath:db/migration

# Enable SQL initialization
spring.sql.init.mode=always

# JWT Configuration
jwt.secret=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
jwt.refresh-secret=7338782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E

# Token expiration times (in milliseconds)
# Access token: 1 hour = 3600000 ms
jwt.expiration=3600000
# Refresh token: 30 days = 2592000000 ms
jwt.refresh-expiration=2592000000

# CORS Configuration
#spring.web.cors.allowed-origins=http://localhost:3000
#spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
#spring.web.cors.allowed-headers=*
#spring.web.cors.allow-credentials=true

# CORS Configuration
cors.allowed-origins=http://localhost:3000

# Logging Configuration
logging.level.com.bht.ludonova=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# Steam Configuration
steam.api.key=${STEAM_API_KEY}
steam.return.url=${STEAM_RETURN_URL:http://localhost:3000/auth/steam/callback}
steam.realm.url=${STEAM_REALM_URL:http://localhost:3000}

# Swagger UI custom path
springdoc.swagger-ui.path=/swagger-ui.html
# Enable or disable Swagger UI
springdoc.swagger-ui.enabled=true
# Sort APIs alphabetically
springdoc.swagger-ui.operationsSorter=alpha
```

## File: .env.example
```
# Steam Configuration
STEAM_API_KEY=your_steam_api_key_here
STEAM_RETURN_URL=http://localhost:3000/auth/steam/callback
```

## File: .gitignore
```
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

### Environment Files ###
.env
application-local.properties
application-dev.properties
application-prod.properties

### Logs ###
*.log
logs/
log/

### Docker ###
docker-compose.override.yml

### OS generated files ###
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

### Java ###
# Compiled class file
*.class

# Package Files #
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar

# virtual machine crash logs
hs_err_pid*
replay_pid*
```

## File: backend-overview.md
```markdown
# LudoNova Backend Overview

The LudoNova backend is a robust and scalable **Spring Boot** application that powers the game backlog management system. It is designed with a focus on security, maintainability, and performance, ensuring a seamless experience for both developers and users.

## Understanding Spring and Spring Boot

Before diving into the architecture and components of the LudoNova backend, it's essential to understand the foundational frameworks it leverages: **Spring** and **Spring Boot**.

### What is Spring?

**Spring** is a comprehensive framework for building Java applications. It provides a wide range of features, including:

- **Dependency Injection (DI):** Allows for loose coupling of components by managing their dependencies.
- **Aspect-Oriented Programming (AOP):** Enables separation of cross-cutting concerns like logging and security.
- **Data Access:** Simplifies interactions with databases through modules like Spring JDBC and Spring Data.
- **Transaction Management:** Provides declarative transaction management for consistent data operations.
- **Model-View-Controller (MVC) Framework:** Facilitates the creation of web applications with clear separation between the model, view, and controller layers.

However, setting up a Spring application often involves extensive configuration, which can be time-consuming and error-prone.

### What is Spring Boot?

**Spring Boot** builds upon the Spring framework to simplify the development process. It offers:

- **Auto-Configuration:** Automatically configures Spring components based on the dependencies present in the project.
- **Starter POMs:** Pre-configured Maven or Gradle dependencies that simplify dependency management.
- **Embedded Servers:** Allows running applications with embedded servers like Tomcat or Jetty without the need for external deployment.
- **Production-Ready Features:** Includes metrics, health checks, and externalized configuration to prepare applications for production environments.

In essence, Spring Boot reduces the boilerplate configuration, enabling developers to focus more on business logic rather than setup.

## Architecture

The backend follows a **layered architecture**, a common design pattern in Spring Boot applications that separates concerns to enhance modularity and ease of maintenance. This structure aligns with Spring's philosophy of separation of concerns and facilitates scalability and testability. The primary layers include:

- **Controller Layer:** Handles incoming HTTP requests and maps them to appropriate services.
  
  - **Why It's Separate:** Isolating controllers ensures that request handling logic is decoupled from business logic, making the system more modular and easier to manage.

- **Service Layer:** Contains the business logic and processes data between the controller and repository layers.
  
  - **Role in Spring Boot:** Services are annotated with `@Service`, a specialization of `@Component`, which allows Spring to detect and manage them as beans. This layer orchestrates operations, enforces business rules, and acts as an intermediary between controllers and repositories.

- **Repository Layer:** Manages data persistence and interacts with the PostgreSQL database using JPA/Hibernate.
  
  - **Integration with Spring Data:** Repositories are typically interfaces annotated with `@Repository`. Spring Data JPA provides implementations at runtime, abstracting the data access layer and enabling CRUD operations without boilerplate code.

### How These Layers Work Together

1. **Request Flow:**
   - A client sends an HTTP request to the application.
   - The **Controller** receives the request and delegates processing to the **Service** layer.
   - The **Service** contains the business logic and interacts with the **Repository** to perform CRUD operations.
   - The **Repository** communicates with the PostgreSQL database to fetch or persist data.
   - The **Service** processes the data and returns the result to the **Controller**.
   - The **Controller** sends the appropriate HTTP response back to the client.

2. **Benefits of Layered Architecture:**
   - **Modularity:** Each layer has a distinct responsibility, making the codebase easier to navigate and maintain.
   - **Testability:** Layers can be tested independently, facilitating unit and integration testing.
   - **Scalability:** Allows for individual layers to be scaled or modified without affecting others.
   - **Maintainability:** Enhances code readability and simplifies the addition of new features.

## Authentication and Security

Security is a paramount concern in the LudoNova backend. Leveraging Spring Boot's robust security features, the application employs a JWT (JSON Web Token) based authentication system to ensure secure and stateless user sessions.

### Understanding Spring Security

**Spring Security** is a powerful and highly customizable authentication and access-control framework. It integrates seamlessly with Spring Boot applications, providing:

- **Authentication:** Verifies the identity of users.
- **Authorization:** Controls access to resources based on user roles and permissions.
- **Protection Against Common Vulnerabilities:** Guards against threats like CSRF, XSS, and session fixation.

### Key Components:

- **JwtTokenProvider:** Generates, validates, and parses JWT tokens. It uses HMAC-SHA for token signing with a configurable secret key and expiration time.
  
  ```java
  public String generateToken(String username) { /* ... */ }
  public String getUsernameFromJWT(String token) { /* ... */ }
  public boolean validateToken(String authToken) { /* ... */ }
  ```
  
  - **Role in Spring Security:** Acts as a utility for managing JWT operations, ensuring tokens are securely created and validated.

- **JwtAuthenticationFilter:** Intercepts incoming requests to extract and validate JWT tokens. If valid, it sets the authentication in the Spring Security context.
  
  - **Integration with Spring Boot:** Extends `OncePerRequestFilter` to ensure that each request is processed once. It leverages the `JwtTokenProvider` to manage token validation and sets the security context accordingly.

- **SecurityConfig:** Configures Spring Security, defining public and protected endpoints, setting up the authentication provider, and applying security filters.
  
  - **Configuration Highlights:**
    - **CORS:** Configures Cross-Origin Resource Sharing to allow or restrict requests from specific origins.
    - **CSRF:** Disables Cross-Site Request Forgery protection for stateless APIs.
    - **Session Management:** Configures the application to be stateless, relying solely on JWT tokens without maintaining server-side sessions.
    - **Authentication Provider:** Sets up how authentication is handled, typically using a `DaoAuthenticationProvider` that retrieves user details from a data source.

### Security Features:

- **Stateless Authentication:** No server-side sessions are maintained. All authentication is handled via JWT tokens sent with each request.
  
  - **Advantages:** Enhances scalability as the server doesn't need to store session information. It also simplifies horizontal scaling and load balancing.

- **Password Encryption:** User passwords are hashed using BCrypt to ensure they are not stored in plain text.
  
  - **Security Best Practice:** Hashing passwords protects user credentials even if the database is compromised.

- **CORS Configuration:** Restricts backend access to authorized frontend origins and specific HTTP methods.
  
  - **Purpose:** Prevents unauthorized domains from making requests to the backend, mitigating potential cross-origin attacks.

## API Endpoints

The backend exposes a set of RESTful API endpoints to manage user authentication, games, and user profiles. Leveraging Spring Boot's **Spring MVC** framework, these endpoints are defined using annotations that map HTTP requests to handler methods.

### Examples:

- **Authentication:**
  - `POST /api/auth/login`: Authenticates a user and returns a JWT token.
  - `POST /api/auth/register`: Registers a new user.

- **Games Management:**
  - `GET /api/games`: Retrieves a list of games.
  - `POST /api/games`: Adds a new game to the backlog.
  - `PUT /api/games/{id}`: Updates game details.
  - `DELETE /api/games/{id}`: Removes a game from the backlog.

- **User Profiles:**
  - `GET /api/user`: Retrieves the authenticated user's profile information.

### Leveraging Spring MVC:

- **Controllers:** Annotated with `@RestController`, these classes handle HTTP requests and return responses.
- **Request Mappings:** Methods within controllers use annotations like `@GetMapping`, `@PostMapping`, etc., to map specific HTTP methods and URLs to handler functions.
- **Response Entities:** Facilitates building HTTP responses with appropriate status codes and headers.

## Database Management

The application uses **PostgreSQL** as its primary database, with the schema managed by **JPA/Hibernate**. Spring Boot's integration with Spring Data JPA simplifies database interactions, allowing developers to work with databases using Java objects rather than writing SQL queries.

### Benefits of Using JPA/Hibernate:

- **Object-Relational Mapping (ORM):** Translates Java objects to database tables, enabling developers to interact with the database using familiar Java constructs.
- **Schema Generation:** Automatically creates and updates the database schema based on entity classes, reducing manual configuration.
- **Query Abstraction:** Provides a high-level API for querying the database, such as JPQL or the Criteria API, abstracting the underlying SQL.

### Configuration:

```properties
# application.properties
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=yourusername
spring.datasource.password=yourpassword
spring.jpa.hibernate.ddl-auto=update
```

- **spring.datasource.url:** Specifies the JDBC URL for the PostgreSQL database.
- **spring.jpa.hibernate.ddl-auto:** Determines how Hibernate handles schema generation. The `update` value ensures that the schema is automatically updated based on entity changes.

## Testing and Deployment

### Testing:

Comprehensive tests are implemented to ensure the reliability and correctness of the backend functionalities. Leveraging **Spring Boot's testing framework**, developers can write unit and integration tests with ease.

- **Running Tests:**
  
  ```bash
  ./mvnw test
  ```
  
  - **Spring Boot Test Annotations:** Annotations like `@SpringBootTest` facilitate loading the application context and testing components in an integrated environment.
  
- **Benefits:**
  - **Continuous Integration:** Ensures that new changes do not break existing functionalities.
  - **Quality Assurance:** Maintains high code quality and reliability.

### Deployment:

The backend can be containerized using **Docker** and managed with **Docker Compose**. This facilitates consistent environments across development, testing, and production.

- **Containerization with Docker:**
  
  ```bash
  docker-compose up -d
  ```
  
  - **Advantages:**
    - **Isolation:** Ensures that the application runs in a consistent environment, eliminating "it works on my machine" issues.
    - **Scalability:** Simplifies scaling services horizontally.
    - **Portability:** Enables easy deployment across different environments and cloud platforms.

### Prerequisites:

- **Java 17+:** Required to run the Spring Boot application.
- **Maven:** For building and managing dependencies.
- **Docker and Docker Compose:** For containerization and deployment.

## Integration with Frontend

The backend seamlessly integrates with the **React/Next.js** frontend of the LudoNova application. Authentication tokens are managed on the frontend and included in API requests to secure endpoints.

### API Client:

A configured Axios instance is used on the frontend to handle API requests, automatically attaching JWT tokens and handling authentication errors.

```javascript
const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});
```

- **Interceptors:** Axios interceptors can be set up to inject JWT tokens into request headers and handle responses globally, such as redirecting to the login page on a `401 Unauthorized` response.

## Conclusion

The LudoNova backend is meticulously crafted using **Spring Boot** to provide a secure, efficient, and scalable foundation for the game backlog management system. Its thoughtful layered architecture and robust security measures ensure a reliable service for users, while Spring Boot's auto-configuration and integration capabilities facilitate ease of development and maintenance. Understanding how Spring Boot orchestrates its components and leverages frameworks like Spring MVC and Spring Data JPA empowers developers to effectively manage and extend the backend functionalities.

```
```

## File: docker-compose.yml
```yaml
version: '3.8'

services:
  postgres:
    image: postgres:16
    container_name: ludonova_db
    environment:
      POSTGRES_DB: ludonova
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

## File: ludonova-backend-overview.xml
```xml
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-17T17:49:58.136Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
src/
  main/
    java/
      com/
        bht/
          ludonova/
            config/
              DataInitializer.java
              WebConfig.java
            controller/
              AuthController.java
              GameController.java
              SteamAuthController.java
              TestController.java
              UserController.java
            dto/
              auth/
                AuthenticationResponse.java
                LoginRequest.java
                RefreshTokenRequest.java
                TokenResponse.java
              steam/
                SteamApiResponseDTO.java
                SteamAuthRequest.java
                SteamUserDTO.java
              user/
                UserDTO.java
              ErrorResponse.java
            exception/
              AuthenticationException.java
              GlobalExceptionHandler.java
              LudoNovaException.java
              SteamAuthenticationException.java
            model/
              Game.java
              SteamUser.java
              User.java
            repository/
              GameRepository.java
              UserRepository.java
            security/
              AuthenticationExceptionHandler.java
              CustomUserDetailsService.java
              JwtAuthenticationFilter.java
              JwtTokenProvider.java
              SecurityConfig.java
            service/
              auth/
                AuthenticationStrategy.java
                BasicAuthenticationStrategy.java
                SteamAuthenticationStrategy.java
              AuthenticationService.java
              SteamService.java
              UserService.java
            LudoNovaApplication.java
    resources/
      application.properties
.env.example
.gitignore
backend-overview.md
docker-compose.yml
ludonova-backend-overview.xml
pom.xml
README.md
setup.sh
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="src/main/java/com/bht/ludonova/config/DataInitializer.java">
package com.bht.ludonova.config;

import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class DataInitializer {

    @Bean
    CommandLineRunner initDatabase(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        return args -> {
            // Create test user if it doesn't exist
            if (userRepository.findByUsername("test").isEmpty()) {
                User testUser = User.builder()
                        .username("test")
                        .password(passwordEncoder.encode("test123"))
                        .email("test@example.com")
                        .build();
                userRepository.save(testUser);
                System.out.println("Test user created successfully");
            }
        };
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/config/WebConfig.java">
package com.bht.ludonova.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
public class WebConfig {

    @Value("${cors.allowed-origins}")
    private List<String> allowedOrigins;

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(allowedOrigins);
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        configuration.setAllowedHeaders(List.of(
                "Authorization",
                "Content-Type",
                "X-Requested-With",
                "Accept",
                "Origin",
                "Access-Control-Request-Method",
                "Access-Control-Request-Headers"
        ));
        configuration.setExposedHeaders(List.of(
                "Access-Control-Allow-Origin",
                "Access-Control-Allow-Credentials"
        ));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", configuration);
        return source;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/AuthController.java">
package com.bht.ludonova.controller;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.RefreshTokenRequest;
import com.bht.ludonova.dto.auth.LoginRequest;
import com.bht.ludonova.service.AuthenticationService;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/auth")
@Slf4j
public class AuthController {
    private final AuthenticationService authService;

    public AuthController(AuthenticationService authService) {
        this.authService = authService;
    }

    @PostMapping("/login")
    public ResponseEntity<AuthenticationResponse> login(@Valid @RequestBody LoginRequest loginRequest) {
        Map<String, String> credentials = Map.of(
                "username", loginRequest.getUsername(),
                "password", loginRequest.getPassword()
        );

        AuthenticationResponse response = authService.authenticate("basic", credentials);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/refresh")
    public ResponseEntity<AuthenticationResponse> refresh(@Valid @RequestBody RefreshTokenRequest request) {
        AuthenticationResponse response = authService.refresh(request.getRefreshToken());
        return ResponseEntity.ok(response);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/GameController.java">
package com.bht.ludonova.controller;

import com.bht.ludonova.model.Game;
import com.bht.ludonova.repository.GameRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/games")
public class GameController {

    @Autowired
    private GameRepository gameRepository;

    @GetMapping
    public ResponseEntity<List<Game>> getGames(@AuthenticationPrincipal UserDetails userDetails) {
        // For now, return an empty list rather than null
        return ResponseEntity.ok(List.of());
    }

    @GetMapping("/{id}")
    public ResponseEntity<Game> getGame(@PathVariable Long id) {
        return gameRepository.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/SteamAuthController.java">
package com.bht.ludonova.controller;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.exception.SteamAuthenticationException;
import com.bht.ludonova.service.AuthenticationService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Map;

@RestController
@RequestMapping("/api/auth/steam")
@Slf4j
public class SteamAuthController {
    private final AuthenticationService authService;

    @Value("${steam.return.url}")
    private String returnUrl;

    @Value("${steam.realm.url}")
    private String realmUrl;

    public SteamAuthController(AuthenticationService authService) {
        this.authService = authService;
    }

    @GetMapping("/login")
    public ResponseEntity<Map<String, String>> steamLogin() {
        try {
            String steamOpenIdUrl = buildSteamOpenIdUrl();
            return ResponseEntity.ok(Map.of("url", steamOpenIdUrl));
        } catch (Exception e) {
            log.error("Error generating Steam login URL", e);
            throw new SteamAuthenticationException("Failed to generate Steam login URL");
        }
    }

    @GetMapping("/return")
    public ResponseEntity<AuthenticationResponse> steamReturn(@RequestParam Map<String, String> params) {
        log.debug("Received Steam return params: {}", params);
        AuthenticationResponse response = authService.authenticate("steam", params);
        return ResponseEntity.ok(response);
    }

    private String buildSteamOpenIdUrl() {
        try {
            String encodedReturnUrl = URLEncoder.encode(returnUrl, StandardCharsets.UTF_8);
            String encodedRealm = URLEncoder.encode(realmUrl, StandardCharsets.UTF_8);

            return String.format(
                    "https://steamcommunity.com/openid/login" +
                            "?openid.ns=%s" +
                            "&openid.mode=checkid_setup" +
                            "&openid.return_to=%s" +
                            "&openid.realm=%s" +
                            "&openid.identity=%s" +
                            "&openid.claimed_id=%s",
                    URLEncoder.encode("http://specs.openid.net/auth/2.0", StandardCharsets.UTF_8),
                    encodedReturnUrl,
                    encodedRealm,
                    URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8),
                    URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8)
            );
        } catch (Exception e) {
            log.error("Error building Steam OpenID URL", e);
            throw new SteamAuthenticationException("Failed to build Steam authentication URL");
        }
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/TestController.java">
package com.bht.ludonova.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/test")
public class TestController {

    @GetMapping("/public")
    public ResponseEntity<String> publicEndpoint() {
        return ResponseEntity.ok("Public endpoint is working!");
    }

    @GetMapping("/protected")
    public ResponseEntity<String> protectedEndpoint() {
        return ResponseEntity.ok("Protected endpoint is working! You are authenticated.");
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/UserController.java">
package com.bht.ludonova.controller;

import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/user")
public class UserController {

    @Autowired
    private UserRepository userRepository;

    @GetMapping
    public ResponseEntity<User> getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
        return userRepository.findByUsername(userDetails.getUsername())
                .map(user -> {
                    // Don't send the password in the response
                    user.setPassword(null);
                    return ResponseEntity.ok(user);
                })
                .orElse(ResponseEntity.notFound().build());
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/AuthenticationResponse.java">
package com.bht.ludonova.dto.auth;

import com.bht.ludonova.dto.user.UserDTO;
import lombok.Data;

@Data
public class AuthenticationResponse {
    private final TokenResponse tokens;
    private final UserDTO user;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/LoginRequest.java">
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class LoginRequest {
    private String username;
    private String password;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/RefreshTokenRequest.java">
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class RefreshTokenRequest {
    private String refreshToken;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/TokenResponse.java">
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class TokenResponse {
    private final String accessToken;
    private final String refreshToken;
    private final String tokenType;
    private final long expiresIn;

    public static TokenResponse of(String accessToken, String refreshToken, long expiresIn) {
        return new TokenResponse(accessToken, refreshToken, "Bearer", expiresIn);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/steam/SteamApiResponseDTO.java">
package com.bht.ludonova.dto.steam;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.List;

@Data
public class SteamApiResponseDTO {
    private Response response;

    @Data
    public static class Response {
        private List<Player> players;
    }

    @Data
    public static class Player {
        @JsonProperty("steamid")
        private String steamId;

        @JsonProperty("personaname")
        private String personaName;

        @JsonProperty("profileurl")
        private String profileUrl;

        @JsonProperty("avatar")
        private String avatarUrl;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/steam/SteamAuthRequest.java">
package com.bht.ludonova.dto.steam;

import lombok.Data;

import java.util.Map;

@Data
public class SteamAuthRequest {
    private final Map<String, String> openIdParams;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/steam/SteamUserDTO.java">
package com.bht.ludonova.dto.steam;

import lombok.Data;

@Data
public class SteamUserDTO {
    private String steamId;
    private String personaName;
    private String profileUrl;
    private String avatarUrl;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/user/UserDTO.java">
package com.bht.ludonova.dto.user;

import com.bht.ludonova.dto.steam.SteamUserDTO;
import lombok.Data;

@Data
public class UserDTO {
    private Long id;
    private String username;
    private String email;
    private SteamUserDTO steamUser;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/ErrorResponse.java">
package com.bht.ludonova.dto;

import lombok.Data;

@Data
public class ErrorResponse {
    private final String errorCode;
    private final String message;
    private final int status;
}
</file>

<file path="src/main/java/com/bht/ludonova/exception/AuthenticationException.java">
package com.bht.ludonova.exception;

public class AuthenticationException extends LudoNovaException {
    public AuthenticationException(String message) {
        super(message, "AUTH_ERROR");
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/exception/GlobalExceptionHandler.java">
package com.bht.ludonova.exception;

import com.bht.ludonova.dto.ErrorResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {
        ErrorResponse error = new ErrorResponse(
                ex.getErrorCode(),
                ex.getMessage(),
                HttpStatus.UNAUTHORIZED.value()
        );
        return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(SteamAuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleSteamAuthenticationException(SteamAuthenticationException ex) {
        ErrorResponse error = new ErrorResponse(
                ex.getErrorCode(),
                ex.getMessage(),
                HttpStatus.UNAUTHORIZED.value()
        );
        return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        ErrorResponse error = new ErrorResponse(
                "INTERNAL_ERROR",
                "An unexpected error occurred",
                HttpStatus.INTERNAL_SERVER_ERROR.value()
        );
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/exception/LudoNovaException.java">
package com.bht.ludonova.exception;

public class LudoNovaException extends RuntimeException {
    private final String errorCode;

    public LudoNovaException(String message, String errorCode) {
        super(message);
        this.errorCode = errorCode;
    }

    public String getErrorCode() {
        return errorCode;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/exception/SteamAuthenticationException.java">
package com.bht.ludonova.exception;

public class SteamAuthenticationException extends AuthenticationException {
    public SteamAuthenticationException(String message) {
        super("Steam authentication failed: " + message);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/model/Game.java">
package com.bht.ludonova.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "games")
public class Game {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    @Column(nullable = false)
    private String platform;

    @Column(nullable = false)
    private String status;

    private Double rating;

    private String notes;

    @Column(name = "last_played")
    private String lastPlayed;

    @Column(name = "play_time")
    private Integer playTime;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;
}
</file>

<file path="src/main/java/com/bht/ludonova/model/SteamUser.java">
package com.bht.ludonova.model;

import lombok.Data;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;

@Data
@Entity
@Table(name = "steam_users")
public class SteamUser {
    @Id
    private String steamId;
    
    private String personaName;
    private String profileUrl;
    private String avatarUrl;
    
    @OneToOne(mappedBy = "steamUser")
    private User user;
}
</file>

<file path="src/main/java/com/bht/ludonova/model/User.java">
package com.bht.ludonova.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    @Column
    private String email;

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "steam_id")
    private SteamUser steamUser;
}
</file>

<file path="src/main/java/com/bht/ludonova/repository/GameRepository.java">
package com.bht.ludonova.repository;

import com.bht.ludonova.model.Game;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface GameRepository extends JpaRepository<Game, Long> {
    List<Game> findByUserId(Long userId);
}
</file>

<file path="src/main/java/com/bht/ludonova/repository/UserRepository.java">
package com.bht.ludonova.repository;

import com.bht.ludonova.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findBySteamUser_SteamId(String steamId);
}
</file>

<file path="src/main/java/com/bht/ludonova/security/AuthenticationExceptionHandler.java">
package com.bht.ludonova.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Component
public class AuthenticationExceptionHandler implements AuthenticationEntryPoint, AccessDeniedHandler {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        log.error("Unauthorized error: {}", authException.getMessage());

        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

        Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
        body.put("error", "Unauthorized");
        body.put("message", authException.getMessage());
        body.put("path", request.getServletPath());

        objectMapper.writeValue(response.getOutputStream(), body);
    }

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response,
                       AccessDeniedException accessDeniedException) throws IOException, ServletException {
        log.error("Access denied error: {}", accessDeniedException.getMessage());

        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);

        Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_FORBIDDEN);
        body.put("error", "Forbidden");
        body.put("message", accessDeniedException.getMessage());
        body.put("path", request.getServletPath());

        objectMapper.writeValue(response.getOutputStream(), body);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/security/CustomUserDetailsService.java">
package com.bht.ludonova.security;

import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;

@Slf4j
@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));

        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getUsername())
                .password(user.getPassword())
                .authorities(Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")))
                .accountExpired(false)
                .accountLocked(false)
                .credentialsExpired(false)
                .disabled(false)
                .build();
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/security/JwtAuthenticationFilter.java">
package com.bht.ludonova.security;

import com.bht.ludonova.exception.AuthenticationException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider tokenProvider;
    private final CustomUserDetailsService customUserDetailsService;
    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    // List of paths that don't require authentication
    private final List<String> publicPaths = Arrays.asList(
            "/api/auth/**",
            "/api/test/public"
    );

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getServletPath();
        return publicPaths.stream()
                .anyMatch(pattern -> pathMatcher.match(pattern, path));
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt)) {
                if (!tokenProvider.validateToken(jwt)) {
                    throw new AuthenticationException("Invalid or expired JWT token");
                }

                String username = tokenProvider.getUsernameFromToken(jwt);
                UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);

                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                        );
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            log.error("Could not set user authentication in security context", ex);
            SecurityContextHolder.clearContext();

            if (ex instanceof AuthenticationException) {
                throw ex;
            }
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }

    /**
     * Helper method to check if token is about to expire
     * Could be used to implement token refresh logic
     */
    private boolean shouldRefreshToken(String token) {
        return tokenProvider.isTokenExpired(token, false);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/security/JwtTokenProvider.java">
package com.bht.ludonova.security;


import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Component
public class JwtTokenProvider {

    private final SecretKey accessTokenKey;
    private final SecretKey refreshTokenKey;
    private final long accessTokenExpirationMs; // Changed to long
    private final long refreshTokenExpirationMs; // Changed to long

    public JwtTokenProvider(
            @Value("${jwt.secret}") String jwtSecret,
            @Value("${jwt.refresh-secret:${jwt.secret}}") String refreshSecret,
            @Value("${jwt.expiration}") long accessTokenExpirationMs, // Changed to long
            @Value("${jwt.refresh-expiration:2592000000}") long refreshTokenExpirationMs) { // Changed to long
        this.accessTokenKey = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
        this.refreshTokenKey = Keys.hmacShaKeyFor(refreshSecret.getBytes(StandardCharsets.UTF_8));
        this.accessTokenExpirationMs = accessTokenExpirationMs;
        this.refreshTokenExpirationMs = refreshTokenExpirationMs;
    }

    public String generateAccessToken(Authentication authentication) {
        return generateAccessToken(authentication.getName(), createClaims(authentication));
    }

    public String generateAccessToken(String username) {
        return generateAccessToken(username, new HashMap<>());
    }

    public String generateAccessToken(String username, Map<String, Object> claims) {
        return generateToken(username, claims, accessTokenKey, accessTokenExpirationMs);
    }

    public String generateRefreshToken(String username) {
        return generateToken(username, new HashMap<>(), refreshTokenKey, refreshTokenExpirationMs);
    }

    private String generateToken(String username, Map<String, Object> claims, SecretKey key, long expirationMs) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expirationMs);

        return Jwts.builder()
                .setClaims(claims)
                .setSubject(username)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();
    }

    private Map<String, Object> createClaims(Authentication authentication) {
        Map<String, Object> claims = new HashMap<>();

        // Add user authorities/roles
        String authorities = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(","));
        claims.put("authorities", authorities);

        // Add token type
        claims.put("type", "Bearer");

        return claims;
    }

    public String getUsernameFromToken(String token, boolean isRefreshToken) {
        return getClaimsFromToken(token, isRefreshToken).getSubject();
    }

    public String getUsernameFromToken(String token) {
        return getUsernameFromToken(token, false);
    }

    public boolean validateToken(String token) {
        return validateToken(token, false);
    }

    public boolean validateToken(String token, boolean isRefreshToken) {
        try {
            SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
            Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(token);
            return true;
        } catch (SignatureException e) {
            log.error("Invalid JWT signature: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            log.error("Invalid JWT token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            log.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            log.error("JWT token is unsupported: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            log.error("JWT claims string is empty: {}", e.getMessage());
        }
        return false;
    }

    public Claims getClaimsFromToken(String token, boolean isRefreshToken) {
        SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
        return Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    public boolean isTokenExpired(String token, boolean isRefreshToken) {
        try {
            Claims claims = getClaimsFromToken(token, isRefreshToken);
            return claims.getExpiration().before(new Date());
        } catch (ExpiredJwtException e) {
            return true;
        }
    }

    public long getAccessTokenExpirationMs() {
        return accessTokenExpirationMs;
    }

    public long getRefreshTokenExpirationMs() {
        return refreshTokenExpirationMs;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/security/SecurityConfig.java">
package com.bht.ludonova.security;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfigurationSource;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;
    private final JwtAuthenticationFilter jwtAuthFilter;
    private final CorsConfigurationSource corsConfigurationSource;
    private final AuthenticationExceptionHandler authenticationExceptionHandler;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        return http
                .cors(cors -> cors.configurationSource(corsConfigurationSource))
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        // Public endpoints
                        .requestMatchers(
                                "/api/auth/login",
                                "/api/auth/refresh",
                                "/api/auth/steam/login",
                                "/api/auth/steam/return"
                        ).permitAll()
                        .requestMatchers("/api/test/public").permitAll()
                        // Protected endpoints
                        .requestMatchers("/api/games/**").authenticated()
                        .requestMatchers("/api/user/**").authenticated()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authenticationProvider(authenticationProvider())
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exc -> exc
                        .authenticationEntryPoint(authenticationExceptionHandler)
                        .accessDeniedHandler(authenticationExceptionHandler)
                )
                .build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/auth/AuthenticationStrategy.java">
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;

import java.util.Map;

public interface AuthenticationStrategy {
    AuthenticationResponse authenticate(Map<String, String> credentials);
    AuthenticationResponse refresh(String refreshToken);
}
</file>

<file path="src/main/java/com/bht/ludonova/service/auth/BasicAuthenticationStrategy.java">
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.TokenResponse;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.exception.AuthenticationException;
import com.bht.ludonova.security.JwtTokenProvider;
import com.bht.ludonova.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class BasicAuthenticationStrategy implements AuthenticationStrategy {
    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider tokenProvider;
    private final UserService userService;

    public BasicAuthenticationStrategy(
            AuthenticationManager authenticationManager,
            JwtTokenProvider tokenProvider,
            UserService userService) {
        this.authenticationManager = authenticationManager;
        this.tokenProvider = tokenProvider;
        this.userService = userService;
    }

    @Override
    public AuthenticationResponse authenticate(Map<String, String> credentials) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            credentials.get("username"),
                            credentials.get("password")
                    )
            );
            SecurityContextHolder.getContext().setAuthentication(authentication);

            String accessToken = tokenProvider.generateAccessToken(authentication);
            String refreshToken = tokenProvider.generateRefreshToken(authentication.getName());
            UserDTO user = userService.getCurrentUserDTO();

            TokenResponse tokens = TokenResponse.of(
                    accessToken,
                    refreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, user);
        } catch (org.springframework.security.core.AuthenticationException e) {
            log.error("Authentication failed", e);
            throw new AuthenticationException("Invalid username or password");
        }
    }

    @Override
    public AuthenticationResponse refresh(String refreshToken) {
        try {
            if (!tokenProvider.validateToken(refreshToken, true)) {
                throw new AuthenticationException("Invalid refresh token");
            }

            String username = tokenProvider.getUsernameFromToken(refreshToken, true);
            UserDTO user = userService.getUserDTOByUsername(username);

            String newAccessToken = tokenProvider.generateAccessToken(username);
            String newRefreshToken = tokenProvider.generateRefreshToken(username);

            TokenResponse tokens = TokenResponse.of(
                    newAccessToken,
                    newRefreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, user);
        } catch (Exception e) {
            log.error("Token refresh failed", e);
            throw new AuthenticationException("Failed to refresh token");
        }
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/auth/SteamAuthenticationStrategy.java">
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.TokenResponse;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.exception.SteamAuthenticationException;
import com.bht.ludonova.model.SteamUser;
import com.bht.ludonova.model.User;
import com.bht.ludonova.security.JwtTokenProvider;
import com.bht.ludonova.service.SteamService;
import com.bht.ludonova.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class SteamAuthenticationStrategy implements AuthenticationStrategy {
    private final SteamService steamService;
    private final UserService userService;
    private final JwtTokenProvider tokenProvider;

    public SteamAuthenticationStrategy(
            SteamService steamService,
            UserService userService,
            JwtTokenProvider tokenProvider) {
        this.steamService = steamService;
        this.userService = userService;
        this.tokenProvider = tokenProvider;
    }

    @Override
    public AuthenticationResponse authenticate(Map<String, String> openIdParams) {
        try {
            log.debug("Starting Steam authentication with params: {}", openIdParams);

            if (!steamService.validateSteamResponse(openIdParams)) {
                log.error("Steam validation failed");
                throw new SteamAuthenticationException("Invalid Steam response");
            }

            log.debug("Steam response validated successfully");
            String steamId = extractSteamId(openIdParams);

            if (steamId == null) {
                log.error("Could not extract Steam ID from params");
                throw new SteamAuthenticationException("Could not extract Steam ID");
            }

            log.debug("Extracted Steam ID: {}", steamId);
            SteamUser steamUser = steamService.fetchUserDetails(steamId);
            log.debug("Fetched Steam user details: {}", steamUser);

            User user = userService.getOrCreateSteamUser(steamUser);
            log.debug("Got/Created user: {}", user);

            String accessToken = tokenProvider.generateAccessToken(user.getUsername());
            String refreshToken = tokenProvider.generateRefreshToken(user.getUsername());
            UserDTO userDTO = userService.convertToDTO(user);

            log.debug("Generated tokens and converted user to DTO");

            TokenResponse tokens = TokenResponse.of(
                    accessToken,
                    refreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, userDTO);
        } catch (Exception e) {
            log.error("Steam authentication failed", e);
            throw new SteamAuthenticationException(e.getMessage());
        }
    }

    @Override
    public AuthenticationResponse refresh(String refreshToken) {
        return null; // Steam users use the same refresh mechanism as basic auth
    }

    private String extractSteamId(Map<String, String> params) {
        String identity = params.get("openid.claimed_id");
        if (identity != null && identity.matches("https://steamcommunity.com/openid/id/\\d+")) {
            return identity.substring(identity.lastIndexOf("/") + 1);
        }
        return null;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/AuthenticationService.java">
package com.bht.ludonova.service;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.exception.AuthenticationException;
import com.bht.ludonova.service.auth.AuthenticationStrategy;
import com.bht.ludonova.service.auth.BasicAuthenticationStrategy;
import com.bht.ludonova.service.auth.SteamAuthenticationStrategy;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class AuthenticationService {
    private final Map<String, AuthenticationStrategy> authenticationStrategies;

    public AuthenticationService(
            BasicAuthenticationStrategy basicAuthStrategy,
            SteamAuthenticationStrategy steamAuthStrategy) {
        this.authenticationStrategies = Map.of(
                "basic", basicAuthStrategy,
                "steam", steamAuthStrategy
        );
    }

    public AuthenticationResponse authenticate(String strategy, Map<String, String> credentials) {
        AuthenticationStrategy authStrategy = authenticationStrategies.get(strategy);
        if (authStrategy == null) {
            throw new AuthenticationException("Unsupported authentication strategy: " + strategy);
        }

        return authStrategy.authenticate(credentials);
    }

    public AuthenticationResponse refresh(String refreshToken) {
        // We use the basic strategy for refresh tokens as the mechanism is the same
        return authenticationStrategies.get("basic").refresh(refreshToken);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/SteamService.java">
package com.bht.ludonova.service;

import com.bht.ludonova.dto.steam.SteamApiResponseDTO;
import com.bht.ludonova.exception.SteamAuthenticationException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import com.bht.ludonova.model.SteamUser;
import lombok.extern.slf4j.Slf4j;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Service
public class SteamService {
    @Value("${steam.api.key}")
    private String steamApiKey;

    private final WebClient steamApiClient;
    private final WebClient openIdClient;

    public SteamService() {
        this.steamApiClient = WebClient.builder()
                .baseUrl("https://api.steampowered.com")
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
                .build();

        this.openIdClient = WebClient.builder()
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
                .build();
    }

    public boolean validateSteamResponse(Map<String, String> params) {
        try {
            log.info("Validating Steam response with params: {}", params);
            String url = "https://steamcommunity.com/openid/login";

            // Create a new map with check_authentication mode
            Map<String, String> validationParams = new HashMap<>(params);
            validationParams.put("openid.mode", "check_authentication");

            // Convert map to form data
            String formData = validationParams.entrySet().stream()
                    .map(entry -> entry.getKey() + "=" + encodeValue(entry.getValue()))
                    .collect(Collectors.joining("&"));

            String responseBody = openIdClient.post()
                    .uri(url)
                    .header("Content-Type", "application/x-www-form-urlencoded")
                    .bodyValue(formData)
                    .retrieve()
                    .bodyToMono(String.class)
                    .block();

            log.info("Steam validation response: {}", responseBody);
            return responseBody != null && responseBody.contains("is_valid:true");
        } catch (Exception e) {
            log.error("Error validating Steam response", e);
            return false;
        }
    }

    public SteamUser fetchUserDetails(String steamId) {
        String url = "/ISteamUser/GetPlayerSummaries/v2/";

        try {
            SteamApiResponseDTO dto = steamApiClient.get()
                    .uri(uriBuilder -> uriBuilder
                            .path(url)
                            .queryParam("key", steamApiKey)
                            .queryParam("steamids", steamId)
                            .build())
                    .retrieve()
                    .bodyToMono(SteamApiResponseDTO.class)
                    .block();

            if (dto != null && dto.getResponse() != null && !dto.getResponse().getPlayers().isEmpty()) {
                SteamApiResponseDTO.Player player = dto.getResponse().getPlayers().get(0);
                return mapToSteamUser(player);
            }

            throw new SteamApiException("Failed to fetch Steam user details");
        } catch (Exception e) {
            log.error("Error fetching Steam user details", e);
            throw new SteamApiException("Failed to fetch Steam user details", e);
        }
    }

    private String encodeValue(String value) {
        try {
            return URLEncoder.encode(value, StandardCharsets.UTF_8.toString());
        } catch (UnsupportedEncodingException e) {
            return value;
        }
    }

    private SteamUser mapToSteamUser(SteamApiResponseDTO.Player player) {
        SteamUser steamUser = new SteamUser();
        steamUser.setSteamId(player.getSteamId());
        steamUser.setPersonaName(player.getPersonaName());
        steamUser.setProfileUrl(player.getProfileUrl());
        steamUser.setAvatarUrl(player.getAvatarUrl());
        return steamUser;
    }

    public static class SteamApiException extends RuntimeException {
        public SteamApiException(String message) {
            super(message);
        }

        public SteamApiException(String message, Throwable cause) {
            super(message, cause);
        }
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/UserService.java">
package com.bht.ludonova.service;

import com.bht.ludonova.dto.steam.SteamUserDTO;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.exception.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.bht.ludonova.model.SteamUser;
import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;

import java.util.UUID;

@Service
@Transactional
public class UserService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    public User getOrCreateSteamUser(SteamUser steamUser) {
        return userRepository.findBySteamUser_SteamId(steamUser.getSteamId())
                .orElseGet(() -> createSteamUser(steamUser));
    }

    private User createSteamUser(SteamUser steamUser) {
        User user = new User();
        user.setUsername("steam_" + steamUser.getSteamId());
        user.setPassword(passwordEncoder.encode(UUID.randomUUID().toString()));
        user.setSteamUser(steamUser);
        return userRepository.save(user);
    }

    public UserDTO getCurrentUserDTO() {
        String username = SecurityContextHolder.getContext().getAuthentication().getName();
        return userRepository.findByUsername(username)
                .map(this::convertToDTO)
                .orElseThrow(() -> new AuthenticationException("User not found"));
    }

    public UserDTO getUserDTOByUsername(String username) {
        return userRepository.findByUsername(username)
                .map(this::convertToDTO)
                .orElseThrow(() -> new AuthenticationException("User not found: " + username));
    }

    public UserDTO convertToDTO(User user) {
        UserDTO dto = new UserDTO();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());

        if (user.getSteamUser() != null) {
            SteamUserDTO steamUserDTO = new SteamUserDTO();
            steamUserDTO.setSteamId(user.getSteamUser().getSteamId());
            steamUserDTO.setPersonaName(user.getSteamUser().getPersonaName());
            steamUserDTO.setProfileUrl(user.getSteamUser().getProfileUrl());
            steamUserDTO.setAvatarUrl(user.getSteamUser().getAvatarUrl());
            dto.setSteamUser(steamUserDTO);
        }

        return dto;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/LudoNovaApplication.java">
package com.bht.ludonova;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@SpringBootApplication
@EntityScan("com.bht.ludonova.model")
@EnableJpaRepositories("com.bht.ludonova.repository")
public class LudoNovaApplication {
    public static void main(String[] args) {
        SpringApplication.run(LudoNovaApplication.class, args);
    }
}
</file>

<file path="src/main/resources/application.properties">
# Server Configuration
server.port=8080

# PostgreSQL Database Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=postgres
spring.datasource.password=postgres

# JPA/Hibernate Configuration
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Enable SQL initialization
spring.sql.init.mode=always

# JWT Configuration
jwt.secret=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
jwt.refresh-secret=7338782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E

# Token expiration times (in milliseconds)
# Access token: 1 hour = 3600000 ms
jwt.expiration=3600000
# Refresh token: 30 days = 2592000000 ms
jwt.refresh-expiration=2592000000

# CORS Configuration
#spring.web.cors.allowed-origins=http://localhost:3000
#spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
#spring.web.cors.allowed-headers=*
#spring.web.cors.allow-credentials=true

# CORS Configuration
cors.allowed-origins=http://localhost:3000

# Logging Configuration
logging.level.com.bht.ludonova=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# Steam Configuration
steam.api.key=${STEAM_API_KEY}
steam.return.url=${STEAM_RETURN_URL:http://localhost:3000/auth/steam/callback}
steam.realm.url=${STEAM_REALM_URL:http://localhost:3000}
</file>

<file path=".env.example">
# Steam Configuration
STEAM_API_KEY=your_steam_api_key_here
STEAM_RETURN_URL=http://localhost:3000/auth/steam/callback
</file>

<file path=".gitignore">
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

### Environment Files ###
.env
application-local.properties
application-dev.properties
application-prod.properties

### Logs ###
*.log
logs/
log/

### Docker ###
docker-compose.override.yml

### OS generated files ###
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

### Java ###
# Compiled class file
*.class

# Package Files #
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar

# virtual machine crash logs
hs_err_pid*
replay_pid*
</file>

<file path="backend-overview.md">
# LudoNova Backend Overview

The LudoNova backend is a robust and scalable **Spring Boot** application that powers the game backlog management system. It is designed with a focus on security, maintainability, and performance, ensuring a seamless experience for both developers and users.

## Understanding Spring and Spring Boot

Before diving into the architecture and components of the LudoNova backend, it's essential to understand the foundational frameworks it leverages: **Spring** and **Spring Boot**.

### What is Spring?

**Spring** is a comprehensive framework for building Java applications. It provides a wide range of features, including:

- **Dependency Injection (DI):** Allows for loose coupling of components by managing their dependencies.
- **Aspect-Oriented Programming (AOP):** Enables separation of cross-cutting concerns like logging and security.
- **Data Access:** Simplifies interactions with databases through modules like Spring JDBC and Spring Data.
- **Transaction Management:** Provides declarative transaction management for consistent data operations.
- **Model-View-Controller (MVC) Framework:** Facilitates the creation of web applications with clear separation between the model, view, and controller layers.

However, setting up a Spring application often involves extensive configuration, which can be time-consuming and error-prone.

### What is Spring Boot?

**Spring Boot** builds upon the Spring framework to simplify the development process. It offers:

- **Auto-Configuration:** Automatically configures Spring components based on the dependencies present in the project.
- **Starter POMs:** Pre-configured Maven or Gradle dependencies that simplify dependency management.
- **Embedded Servers:** Allows running applications with embedded servers like Tomcat or Jetty without the need for external deployment.
- **Production-Ready Features:** Includes metrics, health checks, and externalized configuration to prepare applications for production environments.

In essence, Spring Boot reduces the boilerplate configuration, enabling developers to focus more on business logic rather than setup.

## Architecture

The backend follows a **layered architecture**, a common design pattern in Spring Boot applications that separates concerns to enhance modularity and ease of maintenance. This structure aligns with Spring's philosophy of separation of concerns and facilitates scalability and testability. The primary layers include:

- **Controller Layer:** Handles incoming HTTP requests and maps them to appropriate services.
  
  - **Why It's Separate:** Isolating controllers ensures that request handling logic is decoupled from business logic, making the system more modular and easier to manage.

- **Service Layer:** Contains the business logic and processes data between the controller and repository layers.
  
  - **Role in Spring Boot:** Services are annotated with `@Service`, a specialization of `@Component`, which allows Spring to detect and manage them as beans. This layer orchestrates operations, enforces business rules, and acts as an intermediary between controllers and repositories.

- **Repository Layer:** Manages data persistence and interacts with the PostgreSQL database using JPA/Hibernate.
  
  - **Integration with Spring Data:** Repositories are typically interfaces annotated with `@Repository`. Spring Data JPA provides implementations at runtime, abstracting the data access layer and enabling CRUD operations without boilerplate code.

### How These Layers Work Together

1. **Request Flow:**
   - A client sends an HTTP request to the application.
   - The **Controller** receives the request and delegates processing to the **Service** layer.
   - The **Service** contains the business logic and interacts with the **Repository** to perform CRUD operations.
   - The **Repository** communicates with the PostgreSQL database to fetch or persist data.
   - The **Service** processes the data and returns the result to the **Controller**.
   - The **Controller** sends the appropriate HTTP response back to the client.

2. **Benefits of Layered Architecture:**
   - **Modularity:** Each layer has a distinct responsibility, making the codebase easier to navigate and maintain.
   - **Testability:** Layers can be tested independently, facilitating unit and integration testing.
   - **Scalability:** Allows for individual layers to be scaled or modified without affecting others.
   - **Maintainability:** Enhances code readability and simplifies the addition of new features.

## Authentication and Security

Security is a paramount concern in the LudoNova backend. Leveraging Spring Boot's robust security features, the application employs a JWT (JSON Web Token) based authentication system to ensure secure and stateless user sessions.

### Understanding Spring Security

**Spring Security** is a powerful and highly customizable authentication and access-control framework. It integrates seamlessly with Spring Boot applications, providing:

- **Authentication:** Verifies the identity of users.
- **Authorization:** Controls access to resources based on user roles and permissions.
- **Protection Against Common Vulnerabilities:** Guards against threats like CSRF, XSS, and session fixation.

### Key Components:

- **JwtTokenProvider:** Generates, validates, and parses JWT tokens. It uses HMAC-SHA for token signing with a configurable secret key and expiration time.
  
  ```java
  public String generateToken(String username) { /* ... */ }
  public String getUsernameFromJWT(String token) { /* ... */ }
  public boolean validateToken(String authToken) { /* ... */ }
  ```
  
  - **Role in Spring Security:** Acts as a utility for managing JWT operations, ensuring tokens are securely created and validated.

- **JwtAuthenticationFilter:** Intercepts incoming requests to extract and validate JWT tokens. If valid, it sets the authentication in the Spring Security context.
  
  - **Integration with Spring Boot:** Extends `OncePerRequestFilter` to ensure that each request is processed once. It leverages the `JwtTokenProvider` to manage token validation and sets the security context accordingly.

- **SecurityConfig:** Configures Spring Security, defining public and protected endpoints, setting up the authentication provider, and applying security filters.
  
  - **Configuration Highlights:**
    - **CORS:** Configures Cross-Origin Resource Sharing to allow or restrict requests from specific origins.
    - **CSRF:** Disables Cross-Site Request Forgery protection for stateless APIs.
    - **Session Management:** Configures the application to be stateless, relying solely on JWT tokens without maintaining server-side sessions.
    - **Authentication Provider:** Sets up how authentication is handled, typically using a `DaoAuthenticationProvider` that retrieves user details from a data source.

### Security Features:

- **Stateless Authentication:** No server-side sessions are maintained. All authentication is handled via JWT tokens sent with each request.
  
  - **Advantages:** Enhances scalability as the server doesn't need to store session information. It also simplifies horizontal scaling and load balancing.

- **Password Encryption:** User passwords are hashed using BCrypt to ensure they are not stored in plain text.
  
  - **Security Best Practice:** Hashing passwords protects user credentials even if the database is compromised.

- **CORS Configuration:** Restricts backend access to authorized frontend origins and specific HTTP methods.
  
  - **Purpose:** Prevents unauthorized domains from making requests to the backend, mitigating potential cross-origin attacks.

## API Endpoints

The backend exposes a set of RESTful API endpoints to manage user authentication, games, and user profiles. Leveraging Spring Boot's **Spring MVC** framework, these endpoints are defined using annotations that map HTTP requests to handler methods.

### Examples:

- **Authentication:**
  - `POST /api/auth/login`: Authenticates a user and returns a JWT token.
  - `POST /api/auth/register`: Registers a new user.

- **Games Management:**
  - `GET /api/games`: Retrieves a list of games.
  - `POST /api/games`: Adds a new game to the backlog.
  - `PUT /api/games/{id}`: Updates game details.
  - `DELETE /api/games/{id}`: Removes a game from the backlog.

- **User Profiles:**
  - `GET /api/user`: Retrieves the authenticated user's profile information.

### Leveraging Spring MVC:

- **Controllers:** Annotated with `@RestController`, these classes handle HTTP requests and return responses.
- **Request Mappings:** Methods within controllers use annotations like `@GetMapping`, `@PostMapping`, etc., to map specific HTTP methods and URLs to handler functions.
- **Response Entities:** Facilitates building HTTP responses with appropriate status codes and headers.

## Database Management

The application uses **PostgreSQL** as its primary database, with the schema managed by **JPA/Hibernate**. Spring Boot's integration with Spring Data JPA simplifies database interactions, allowing developers to work with databases using Java objects rather than writing SQL queries.

### Benefits of Using JPA/Hibernate:

- **Object-Relational Mapping (ORM):** Translates Java objects to database tables, enabling developers to interact with the database using familiar Java constructs.
- **Schema Generation:** Automatically creates and updates the database schema based on entity classes, reducing manual configuration.
- **Query Abstraction:** Provides a high-level API for querying the database, such as JPQL or the Criteria API, abstracting the underlying SQL.

### Configuration:

```properties
# application.properties
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=yourusername
spring.datasource.password=yourpassword
spring.jpa.hibernate.ddl-auto=update
```

- **spring.datasource.url:** Specifies the JDBC URL for the PostgreSQL database.
- **spring.jpa.hibernate.ddl-auto:** Determines how Hibernate handles schema generation. The `update` value ensures that the schema is automatically updated based on entity changes.

## Testing and Deployment

### Testing:

Comprehensive tests are implemented to ensure the reliability and correctness of the backend functionalities. Leveraging **Spring Boot's testing framework**, developers can write unit and integration tests with ease.

- **Running Tests:**
  
  ```bash
  ./mvnw test
  ```
  
  - **Spring Boot Test Annotations:** Annotations like `@SpringBootTest` facilitate loading the application context and testing components in an integrated environment.
  
- **Benefits:**
  - **Continuous Integration:** Ensures that new changes do not break existing functionalities.
  - **Quality Assurance:** Maintains high code quality and reliability.

### Deployment:

The backend can be containerized using **Docker** and managed with **Docker Compose**. This facilitates consistent environments across development, testing, and production.

- **Containerization with Docker:**
  
  ```bash
  docker-compose up -d
  ```
  
  - **Advantages:**
    - **Isolation:** Ensures that the application runs in a consistent environment, eliminating "it works on my machine" issues.
    - **Scalability:** Simplifies scaling services horizontally.
    - **Portability:** Enables easy deployment across different environments and cloud platforms.

### Prerequisites:

- **Java 17+:** Required to run the Spring Boot application.
- **Maven:** For building and managing dependencies.
- **Docker and Docker Compose:** For containerization and deployment.

## Integration with Frontend

The backend seamlessly integrates with the **React/Next.js** frontend of the LudoNova application. Authentication tokens are managed on the frontend and included in API requests to secure endpoints.

### API Client:

A configured Axios instance is used on the frontend to handle API requests, automatically attaching JWT tokens and handling authentication errors.

```javascript
const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});
```

- **Interceptors:** Axios interceptors can be set up to inject JWT tokens into request headers and handle responses globally, such as redirecting to the login page on a `401 Unauthorized` response.

## Conclusion

The LudoNova backend is meticulously crafted using **Spring Boot** to provide a secure, efficient, and scalable foundation for the game backlog management system. Its thoughtful layered architecture and robust security measures ensure a reliable service for users, while Spring Boot's auto-configuration and integration capabilities facilitate ease of development and maintenance. Understanding how Spring Boot orchestrates its components and leverages frameworks like Spring MVC and Spring Data JPA empowers developers to effectively manage and extend the backend functionalities.

```
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  postgres:
    image: postgres:16
    container_name: ludonova_db
    environment:
      POSTGRES_DB: ludonova
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
</file>

<file path="ludonova-backend-overview.xml">
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-17T15:08:49.780Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
src/
  main/
    java/
      com/
        bht/
          ludonova/
            config/
              DataInitializer.java
              WebConfig.java
            controller/
              AuthController.java
              GameController.java
              SteamAuthController.java
              TestController.java
              UserController.java
            dto/
              auth/
                AuthenticationResponse.java
                LoginRequest.java
                RefreshTokenRequest.java
                TokenResponse.java
              steam/
                SteamApiResponseDTO.java
                SteamAuthRequest.java
                SteamUserDTO.java
              user/
                UserDTO.java
              ErrorResponse.java
            exception/
              AuthenticationException.java
              GlobalExceptionHandler.java
              LudoNovaException.java
              SteamAuthenticationException.java
            model/
              Game.java
              SteamUser.java
              User.java
            repository/
              GameRepository.java
              UserRepository.java
            security/
              AuthenticationExceptionHandler.java
              CustomUserDetailsService.java
              JwtAuthenticationFilter.java
              JwtTokenProvider.java
              SecurityConfig.java
            service/
              auth/
                AuthenticationStrategy.java
                BasicAuthenticationStrategy.java
                SteamAuthenticationStrategy.java
              AuthenticationService.java
              SteamService.java
              UserService.java
            LudoNovaApplication.java
    resources/
      application.properties
.env.example
.gitignore
backend-overview.md
docker-compose.yml
pom.xml
README.md
setup.sh
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="src/main/java/com/bht/ludonova/config/DataInitializer.java">
package com.bht.ludonova.config;

import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class DataInitializer {

    @Bean
    CommandLineRunner initDatabase(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        return args -> {
            // Create test user if it doesn't exist
            if (userRepository.findByUsername("test").isEmpty()) {
                User testUser = User.builder()
                        .username("test")
                        .password(passwordEncoder.encode("test123"))
                        .email("test@example.com")
                        .build();
                userRepository.save(testUser);
                System.out.println("Test user created successfully");
            }
        };
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/config/WebConfig.java">
package com.bht.ludonova.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
public class WebConfig {

    @Value("${cors.allowed-origins}")
    private List<String> allowedOrigins;

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(allowedOrigins);
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        configuration.setAllowedHeaders(List.of(
                "Authorization",
                "Content-Type",
                "X-Requested-With",
                "Accept",
                "Origin",
                "Access-Control-Request-Method",
                "Access-Control-Request-Headers"
        ));
        configuration.setExposedHeaders(List.of(
                "Access-Control-Allow-Origin",
                "Access-Control-Allow-Credentials"
        ));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", configuration);
        return source;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/AuthController.java">
package com.bht.ludonova.controller;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.RefreshTokenRequest;
import com.bht.ludonova.dto.auth.LoginRequest;
import com.bht.ludonova.service.AuthenticationService;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/auth")
@Slf4j
public class AuthController {
    private final AuthenticationService authService;

    public AuthController(AuthenticationService authService) {
        this.authService = authService;
    }

    @PostMapping("/login")
    public ResponseEntity<AuthenticationResponse> login(@Valid @RequestBody LoginRequest loginRequest) {
        Map<String, String> credentials = Map.of(
                "username", loginRequest.getUsername(),
                "password", loginRequest.getPassword()
        );

        AuthenticationResponse response = authService.authenticate("basic", credentials);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/refresh")
    public ResponseEntity<AuthenticationResponse> refresh(@Valid @RequestBody RefreshTokenRequest request) {
        AuthenticationResponse response = authService.refresh(request.getRefreshToken());
        return ResponseEntity.ok(response);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/GameController.java">
package com.bht.ludonova.controller;

import com.bht.ludonova.model.Game;
import com.bht.ludonova.repository.GameRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/games")
public class GameController {

    @Autowired
    private GameRepository gameRepository;

    @GetMapping
    public ResponseEntity<List<Game>> getGames(@AuthenticationPrincipal UserDetails userDetails) {
        // For now, return an empty list rather than null
        return ResponseEntity.ok(List.of());
    }

    @GetMapping("/{id}")
    public ResponseEntity<Game> getGame(@PathVariable Long id) {
        return gameRepository.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/SteamAuthController.java">
package com.bht.ludonova.controller;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.exception.SteamAuthenticationException;
import com.bht.ludonova.service.AuthenticationService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Map;

@RestController
@RequestMapping("/api/auth/steam")
@Slf4j
public class SteamAuthController {
    private final AuthenticationService authService;

    @Value("${steam.return.url}")
    private String returnUrl;

    @Value("${steam.realm.url}")
    private String realmUrl;

    public SteamAuthController(AuthenticationService authService) {
        this.authService = authService;
    }

    @GetMapping("/login")
    public ResponseEntity<Map<String, String>> steamLogin() {
        try {
            String steamOpenIdUrl = buildSteamOpenIdUrl();
            return ResponseEntity.ok(Map.of("url", steamOpenIdUrl));
        } catch (Exception e) {
            log.error("Error generating Steam login URL", e);
            throw new SteamAuthenticationException("Failed to generate Steam login URL");
        }
    }

    @GetMapping("/return")
    public ResponseEntity<AuthenticationResponse> steamReturn(@RequestParam Map<String, String> params) {
        log.debug("Received Steam return params: {}", params);
        AuthenticationResponse response = authService.authenticate("steam", params);
        return ResponseEntity.ok(response);
    }

    private String buildSteamOpenIdUrl() {
        try {
            String encodedReturnUrl = URLEncoder.encode(returnUrl, StandardCharsets.UTF_8);
            String encodedRealm = URLEncoder.encode(realmUrl, StandardCharsets.UTF_8);

            return String.format(
                    "https://steamcommunity.com/openid/login" +
                            "?openid.ns=%s" +
                            "&openid.mode=checkid_setup" +
                            "&openid.return_to=%s" +
                            "&openid.realm=%s" +
                            "&openid.identity=%s" +
                            "&openid.claimed_id=%s",
                    URLEncoder.encode("http://specs.openid.net/auth/2.0", StandardCharsets.UTF_8),
                    encodedReturnUrl,
                    encodedRealm,
                    URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8),
                    URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8)
            );
        } catch (Exception e) {
            log.error("Error building Steam OpenID URL", e);
            throw new SteamAuthenticationException("Failed to build Steam authentication URL");
        }
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/TestController.java">
package com.bht.ludonova.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/test")
public class TestController {

    @GetMapping("/public")
    public ResponseEntity<String> publicEndpoint() {
        return ResponseEntity.ok("Public endpoint is working!");
    }

    @GetMapping("/protected")
    public ResponseEntity<String> protectedEndpoint() {
        return ResponseEntity.ok("Protected endpoint is working! You are authenticated.");
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/UserController.java">
package com.bht.ludonova.controller;

import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/user")
public class UserController {

    @Autowired
    private UserRepository userRepository;

    @GetMapping
    public ResponseEntity<User> getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
        return userRepository.findByUsername(userDetails.getUsername())
                .map(user -> {
                    // Don't send the password in the response
                    user.setPassword(null);
                    return ResponseEntity.ok(user);
                })
                .orElse(ResponseEntity.notFound().build());
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/AuthenticationResponse.java">
package com.bht.ludonova.dto.auth;

import com.bht.ludonova.dto.user.UserDTO;
import lombok.Data;

@Data
public class AuthenticationResponse {
    private final TokenResponse tokens;
    private final UserDTO user;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/LoginRequest.java">
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class LoginRequest {
    private String username;
    private String password;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/RefreshTokenRequest.java">
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class RefreshTokenRequest {
    private String refreshToken;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/TokenResponse.java">
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class TokenResponse {
    private final String accessToken;
    private final String refreshToken;
    private final String tokenType;
    private final long expiresIn;

    public static TokenResponse of(String accessToken, String refreshToken, long expiresIn) {
        return new TokenResponse(accessToken, refreshToken, "Bearer", expiresIn);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/steam/SteamApiResponseDTO.java">
package com.bht.ludonova.dto.steam;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.List;

@Data
public class SteamApiResponseDTO {
    private Response response;

    @Data
    public static class Response {
        private List<Player> players;
    }

    @Data
    public static class Player {
        @JsonProperty("steamid")
        private String steamId;

        @JsonProperty("personaname")
        private String personaName;

        @JsonProperty("profileurl")
        private String profileUrl;

        @JsonProperty("avatar")
        private String avatarUrl;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/steam/SteamAuthRequest.java">
package com.bht.ludonova.dto.steam;

import lombok.Data;

import java.util.Map;

@Data
public class SteamAuthRequest {
    private final Map<String, String> openIdParams;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/steam/SteamUserDTO.java">
package com.bht.ludonova.dto.steam;

import lombok.Data;

@Data
public class SteamUserDTO {
    private String steamId;
    private String personaName;
    private String profileUrl;
    private String avatarUrl;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/user/UserDTO.java">
package com.bht.ludonova.dto.user;

import com.bht.ludonova.dto.steam.SteamUserDTO;
import lombok.Data;

@Data
public class UserDTO {
    private Long id;
    private String username;
    private String email;
    private SteamUserDTO steamUser;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/ErrorResponse.java">
package com.bht.ludonova.dto;

import lombok.Data;

@Data
public class ErrorResponse {
    private final String errorCode;
    private final String message;
    private final int status;
}
</file>

<file path="src/main/java/com/bht/ludonova/exception/AuthenticationException.java">
package com.bht.ludonova.exception;

public class AuthenticationException extends LudoNovaException {
    public AuthenticationException(String message) {
        super(message, "AUTH_ERROR");
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/exception/GlobalExceptionHandler.java">
package com.bht.ludonova.exception;

import com.bht.ludonova.dto.ErrorResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {
        ErrorResponse error = new ErrorResponse(
                ex.getErrorCode(),
                ex.getMessage(),
                HttpStatus.UNAUTHORIZED.value()
        );
        return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(SteamAuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleSteamAuthenticationException(SteamAuthenticationException ex) {
        ErrorResponse error = new ErrorResponse(
                ex.getErrorCode(),
                ex.getMessage(),
                HttpStatus.UNAUTHORIZED.value()
        );
        return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        ErrorResponse error = new ErrorResponse(
                "INTERNAL_ERROR",
                "An unexpected error occurred",
                HttpStatus.INTERNAL_SERVER_ERROR.value()
        );
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/exception/LudoNovaException.java">
package com.bht.ludonova.exception;

public class LudoNovaException extends RuntimeException {
    private final String errorCode;

    public LudoNovaException(String message, String errorCode) {
        super(message);
        this.errorCode = errorCode;
    }

    public String getErrorCode() {
        return errorCode;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/exception/SteamAuthenticationException.java">
package com.bht.ludonova.exception;

public class SteamAuthenticationException extends AuthenticationException {
    public SteamAuthenticationException(String message) {
        super("Steam authentication failed: " + message);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/model/Game.java">
package com.bht.ludonova.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "games")
public class Game {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    @Column(nullable = false)
    private String platform;

    @Column(nullable = false)
    private String status;

    private Double rating;

    private String notes;

    @Column(name = "last_played")
    private String lastPlayed;

    @Column(name = "play_time")
    private Integer playTime;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;
}
</file>

<file path="src/main/java/com/bht/ludonova/model/SteamUser.java">
package com.bht.ludonova.model;

import lombok.Data;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;

@Data
@Entity
@Table(name = "steam_users")
public class SteamUser {
    @Id
    private String steamId;
    
    private String personaName;
    private String profileUrl;
    private String avatarUrl;
    
    @OneToOne(mappedBy = "steamUser")
    private User user;
}
</file>

<file path="src/main/java/com/bht/ludonova/model/User.java">
package com.bht.ludonova.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    @Column
    private String email;

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "steam_id")
    private SteamUser steamUser;
}
</file>

<file path="src/main/java/com/bht/ludonova/repository/GameRepository.java">
package com.bht.ludonova.repository;

import com.bht.ludonova.model.Game;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface GameRepository extends JpaRepository<Game, Long> {
    List<Game> findByUserId(Long userId);
}
</file>

<file path="src/main/java/com/bht/ludonova/repository/UserRepository.java">
package com.bht.ludonova.repository;

import com.bht.ludonova.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findBySteamUser_SteamId(String steamId);
}
</file>

<file path="src/main/java/com/bht/ludonova/security/AuthenticationExceptionHandler.java">
package com.bht.ludonova.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Component
public class AuthenticationExceptionHandler implements AuthenticationEntryPoint, AccessDeniedHandler {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        log.error("Unauthorized error: {}", authException.getMessage());

        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

        Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
        body.put("error", "Unauthorized");
        body.put("message", authException.getMessage());
        body.put("path", request.getServletPath());

        objectMapper.writeValue(response.getOutputStream(), body);
    }

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response,
                       AccessDeniedException accessDeniedException) throws IOException, ServletException {
        log.error("Access denied error: {}", accessDeniedException.getMessage());

        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);

        Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_FORBIDDEN);
        body.put("error", "Forbidden");
        body.put("message", accessDeniedException.getMessage());
        body.put("path", request.getServletPath());

        objectMapper.writeValue(response.getOutputStream(), body);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/security/CustomUserDetailsService.java">
package com.bht.ludonova.security;

import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;

@Slf4j
@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));

        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getUsername())
                .password(user.getPassword())
                .authorities(Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")))
                .accountExpired(false)
                .accountLocked(false)
                .credentialsExpired(false)
                .disabled(false)
                .build();
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/security/JwtAuthenticationFilter.java">
package com.bht.ludonova.security;

import com.bht.ludonova.exception.AuthenticationException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider tokenProvider;
    private final CustomUserDetailsService customUserDetailsService;
    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    // List of paths that don't require authentication
    private final List<String> publicPaths = Arrays.asList(
            "/api/auth/**",
            "/api/test/public"
    );

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getServletPath();
        return publicPaths.stream()
                .anyMatch(pattern -> pathMatcher.match(pattern, path));
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt)) {
                if (!tokenProvider.validateToken(jwt)) {
                    throw new AuthenticationException("Invalid or expired JWT token");
                }

                String username = tokenProvider.getUsernameFromToken(jwt);
                UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);

                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                        );
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            log.error("Could not set user authentication in security context", ex);
            SecurityContextHolder.clearContext();

            if (ex instanceof AuthenticationException) {
                throw ex;
            }
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }

    /**
     * Helper method to check if token is about to expire
     * Could be used to implement token refresh logic
     */
    private boolean shouldRefreshToken(String token) {
        return tokenProvider.isTokenExpired(token, false);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/security/JwtTokenProvider.java">
package com.bht.ludonova.security;


import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Component
public class JwtTokenProvider {

    private final SecretKey accessTokenKey;
    private final SecretKey refreshTokenKey;
    private final long accessTokenExpirationMs; // Changed to long
    private final long refreshTokenExpirationMs; // Changed to long

    public JwtTokenProvider(
            @Value("${jwt.secret}") String jwtSecret,
            @Value("${jwt.refresh-secret:${jwt.secret}}") String refreshSecret,
            @Value("${jwt.expiration}") long accessTokenExpirationMs, // Changed to long
            @Value("${jwt.refresh-expiration:2592000000}") long refreshTokenExpirationMs) { // Changed to long
        this.accessTokenKey = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
        this.refreshTokenKey = Keys.hmacShaKeyFor(refreshSecret.getBytes(StandardCharsets.UTF_8));
        this.accessTokenExpirationMs = accessTokenExpirationMs;
        this.refreshTokenExpirationMs = refreshTokenExpirationMs;
    }

    public String generateAccessToken(Authentication authentication) {
        return generateAccessToken(authentication.getName(), createClaims(authentication));
    }

    public String generateAccessToken(String username) {
        return generateAccessToken(username, new HashMap<>());
    }

    public String generateAccessToken(String username, Map<String, Object> claims) {
        return generateToken(username, claims, accessTokenKey, accessTokenExpirationMs);
    }

    public String generateRefreshToken(String username) {
        return generateToken(username, new HashMap<>(), refreshTokenKey, refreshTokenExpirationMs);
    }

    private String generateToken(String username, Map<String, Object> claims, SecretKey key, long expirationMs) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expirationMs);

        return Jwts.builder()
                .setClaims(claims)
                .setSubject(username)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();
    }

    private Map<String, Object> createClaims(Authentication authentication) {
        Map<String, Object> claims = new HashMap<>();

        // Add user authorities/roles
        String authorities = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(","));
        claims.put("authorities", authorities);

        // Add token type
        claims.put("type", "Bearer");

        return claims;
    }

    public String getUsernameFromToken(String token, boolean isRefreshToken) {
        return getClaimsFromToken(token, isRefreshToken).getSubject();
    }

    public String getUsernameFromToken(String token) {
        return getUsernameFromToken(token, false);
    }

    public boolean validateToken(String token) {
        return validateToken(token, false);
    }

    public boolean validateToken(String token, boolean isRefreshToken) {
        try {
            SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
            Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(token);
            return true;
        } catch (SignatureException e) {
            log.error("Invalid JWT signature: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            log.error("Invalid JWT token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            log.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            log.error("JWT token is unsupported: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            log.error("JWT claims string is empty: {}", e.getMessage());
        }
        return false;
    }

    public Claims getClaimsFromToken(String token, boolean isRefreshToken) {
        SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
        return Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    public boolean isTokenExpired(String token, boolean isRefreshToken) {
        try {
            Claims claims = getClaimsFromToken(token, isRefreshToken);
            return claims.getExpiration().before(new Date());
        } catch (ExpiredJwtException e) {
            return true;
        }
    }

    public long getAccessTokenExpirationMs() {
        return accessTokenExpirationMs;
    }

    public long getRefreshTokenExpirationMs() {
        return refreshTokenExpirationMs;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/security/SecurityConfig.java">
package com.bht.ludonova.security;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfigurationSource;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;
    private final JwtAuthenticationFilter jwtAuthFilter;
    private final CorsConfigurationSource corsConfigurationSource;
    private final AuthenticationExceptionHandler authenticationExceptionHandler;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        return http
                .cors(cors -> cors.configurationSource(corsConfigurationSource))
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        // Public endpoints
                        .requestMatchers(
                                "/api/auth/login",
                                "/api/auth/refresh",
                                "/api/auth/steam/login",
                                "/api/auth/steam/return"
                        ).permitAll()
                        .requestMatchers("/api/test/public").permitAll()
                        // Protected endpoints
                        .requestMatchers("/api/games/**").authenticated()
                        .requestMatchers("/api/user/**").authenticated()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authenticationProvider(authenticationProvider())
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exc -> exc
                        .authenticationEntryPoint(authenticationExceptionHandler)
                        .accessDeniedHandler(authenticationExceptionHandler)
                )
                .build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/auth/AuthenticationStrategy.java">
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;

import java.util.Map;

public interface AuthenticationStrategy {
    AuthenticationResponse authenticate(Map<String, String> credentials);
    AuthenticationResponse refresh(String refreshToken);
}
</file>

<file path="src/main/java/com/bht/ludonova/service/auth/BasicAuthenticationStrategy.java">
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.TokenResponse;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.exception.AuthenticationException;
import com.bht.ludonova.security.JwtTokenProvider;
import com.bht.ludonova.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class BasicAuthenticationStrategy implements AuthenticationStrategy {
    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider tokenProvider;
    private final UserService userService;

    public BasicAuthenticationStrategy(
            AuthenticationManager authenticationManager,
            JwtTokenProvider tokenProvider,
            UserService userService) {
        this.authenticationManager = authenticationManager;
        this.tokenProvider = tokenProvider;
        this.userService = userService;
    }

    @Override
    public AuthenticationResponse authenticate(Map<String, String> credentials) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            credentials.get("username"),
                            credentials.get("password")
                    )
            );
            SecurityContextHolder.getContext().setAuthentication(authentication);

            String accessToken = tokenProvider.generateAccessToken(authentication);
            String refreshToken = tokenProvider.generateRefreshToken(authentication.getName());
            UserDTO user = userService.getCurrentUserDTO();

            TokenResponse tokens = TokenResponse.of(
                    accessToken,
                    refreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, user);
        } catch (org.springframework.security.core.AuthenticationException e) {
            log.error("Authentication failed", e);
            throw new AuthenticationException("Invalid username or password");
        }
    }

    @Override
    public AuthenticationResponse refresh(String refreshToken) {
        try {
            if (!tokenProvider.validateToken(refreshToken, true)) {
                throw new AuthenticationException("Invalid refresh token");
            }

            String username = tokenProvider.getUsernameFromToken(refreshToken, true);
            UserDTO user = userService.getUserDTOByUsername(username);

            String newAccessToken = tokenProvider.generateAccessToken(username);
            String newRefreshToken = tokenProvider.generateRefreshToken(username);

            TokenResponse tokens = TokenResponse.of(
                    newAccessToken,
                    newRefreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, user);
        } catch (Exception e) {
            log.error("Token refresh failed", e);
            throw new AuthenticationException("Failed to refresh token");
        }
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/auth/SteamAuthenticationStrategy.java">
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.TokenResponse;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.exception.SteamAuthenticationException;
import com.bht.ludonova.model.SteamUser;
import com.bht.ludonova.model.User;
import com.bht.ludonova.security.JwtTokenProvider;
import com.bht.ludonova.service.SteamService;
import com.bht.ludonova.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class SteamAuthenticationStrategy implements AuthenticationStrategy {
    private final SteamService steamService;
    private final UserService userService;
    private final JwtTokenProvider tokenProvider;

    public SteamAuthenticationStrategy(
            SteamService steamService,
            UserService userService,
            JwtTokenProvider tokenProvider) {
        this.steamService = steamService;
        this.userService = userService;
        this.tokenProvider = tokenProvider;
    }

    @Override
    public AuthenticationResponse authenticate(Map<String, String> openIdParams) {
        try {
            if (!steamService.validateSteamResponse(openIdParams)) {
                throw new SteamAuthenticationException("Invalid Steam response");
            }

            String steamId = extractSteamId(openIdParams);
            if (steamId == null) {
                throw new SteamAuthenticationException("Could not extract Steam ID");
            }

            SteamUser steamUser = steamService.fetchUserDetails(steamId);
            User user = userService.getOrCreateSteamUser(steamUser);

            String accessToken = tokenProvider.generateAccessToken(user.getUsername());
            String refreshToken = tokenProvider.generateRefreshToken(user.getUsername());
            UserDTO userDTO = userService.convertToDTO(user);

            TokenResponse tokens = TokenResponse.of(
                    accessToken,
                    refreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, userDTO);
        } catch (Exception e) {
            log.error("Steam authentication failed", e);
            throw new SteamAuthenticationException(e.getMessage());
        }
    }

    @Override
    public AuthenticationResponse refresh(String refreshToken) {
        return null; // Steam users use the same refresh mechanism as basic auth
    }

    private String extractSteamId(Map<String, String> params) {
        String identity = params.get("openid.claimed_id");
        if (identity != null && identity.matches("https://steamcommunity.com/openid/id/\\d+")) {
            return identity.substring(identity.lastIndexOf("/") + 1);
        }
        return null;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/AuthenticationService.java">
package com.bht.ludonova.service;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.exception.AuthenticationException;
import com.bht.ludonova.service.auth.AuthenticationStrategy;
import com.bht.ludonova.service.auth.BasicAuthenticationStrategy;
import com.bht.ludonova.service.auth.SteamAuthenticationStrategy;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class AuthenticationService {
    private final Map<String, AuthenticationStrategy> authenticationStrategies;

    public AuthenticationService(
            BasicAuthenticationStrategy basicAuthStrategy,
            SteamAuthenticationStrategy steamAuthStrategy) {
        this.authenticationStrategies = Map.of(
                "basic", basicAuthStrategy,
                "steam", steamAuthStrategy
        );
    }

    public AuthenticationResponse authenticate(String strategy, Map<String, String> credentials) {
        AuthenticationStrategy authStrategy = authenticationStrategies.get(strategy);
        if (authStrategy == null) {
            throw new AuthenticationException("Unsupported authentication strategy: " + strategy);
        }

        return authStrategy.authenticate(credentials);
    }

    public AuthenticationResponse refresh(String refreshToken) {
        // We use the basic strategy for refresh tokens as the mechanism is the same
        return authenticationStrategies.get("basic").refresh(refreshToken);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/SteamService.java">
package com.bht.ludonova.service;

import com.bht.ludonova.dto.steam.SteamApiResponseDTO;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import com.bht.ludonova.model.SteamUser;

import lombok.extern.slf4j.Slf4j;

import java.util.Map;

@Slf4j
@Service
public class SteamService {
    @Value("${steam.api.key}")
    private String steamApiKey;

    private final WebClient webClient;

    public SteamService() {
        this.webClient = WebClient.builder()
                .baseUrl("https://api.steampowered.com")
                .build();
    }

    public SteamUser fetchUserDetails(String steamId) {
        String url = "/ISteamUser/GetPlayerSummaries/v2/";

        try {
            SteamApiResponseDTO dto = webClient.get()
                    .uri(uriBuilder -> uriBuilder
                            .path(url)
                            .queryParam("key", steamApiKey)
                            .queryParam("steamids", steamId)
                            .build())
                    .retrieve()
                    .bodyToMono(SteamApiResponseDTO.class)
                    .block();

            if (dto != null && dto.getResponse() != null && !dto.getResponse().getPlayers().isEmpty()) {
                SteamApiResponseDTO.Player player = dto.getResponse().getPlayers().get(0);
                return mapToSteamUser(player);
            }

            throw new SteamApiException("Failed to fetch Steam user details");

        } catch (Exception e) {
            log.error("Error fetching Steam user details", e);
            throw new SteamApiException("Failed to fetch Steam user details", e);
        }
    }

    private SteamUser mapToSteamUser(SteamApiResponseDTO.Player player) {
        SteamUser steamUser = new SteamUser();
        steamUser.setSteamId(player.getSteamId());
        steamUser.setPersonaName(player.getPersonaName());
        steamUser.setProfileUrl(player.getProfileUrl());
        steamUser.setAvatarUrl(player.getAvatarUrl());
        return steamUser;
    }

    public boolean validateSteamResponse(Map<String, String> params) {
        try {
            log.info("Validating Steam response with params: {}", params);
            String url = "https://steamcommunity.com/openid/login";
            params.put("openid.mode", "check_authentication");

            WebClient.ResponseSpec response = webClient.post()
                .uri(url)
                .bodyValue(params)
                .retrieve();

            String responseBody = response.bodyToMono(String.class).block();
            log.info("Steam validation response: {}", responseBody);
            return responseBody != null && responseBody.contains("is_valid:true");
        } catch (Exception e) {
            log.error("Error validating Steam response", e);
            return false;
        }
    }

    public static class SteamApiException extends RuntimeException {
        public SteamApiException(String message) {
            super(message);
        }
        
        public SteamApiException(String message, Throwable cause) {
            super(message, cause);
        }
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/UserService.java">
package com.bht.ludonova.service;

import com.bht.ludonova.dto.steam.SteamUserDTO;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.exception.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.bht.ludonova.model.SteamUser;
import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;

import java.util.UUID;

@Service
@Transactional
public class UserService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    public User getOrCreateSteamUser(SteamUser steamUser) {
        return userRepository.findBySteamUser_SteamId(steamUser.getSteamId())
                .orElseGet(() -> createSteamUser(steamUser));
    }

    private User createSteamUser(SteamUser steamUser) {
        User user = new User();
        user.setUsername("steam_" + steamUser.getSteamId());
        user.setPassword(passwordEncoder.encode(UUID.randomUUID().toString()));
        user.setSteamUser(steamUser);
        return userRepository.save(user);
    }

    public UserDTO getCurrentUserDTO() {
        String username = SecurityContextHolder.getContext().getAuthentication().getName();
        return userRepository.findByUsername(username)
                .map(this::convertToDTO)
                .orElseThrow(() -> new AuthenticationException("User not found"));
    }

    public UserDTO getUserDTOByUsername(String username) {
        return userRepository.findByUsername(username)
                .map(this::convertToDTO)
                .orElseThrow(() -> new AuthenticationException("User not found: " + username));
    }

    public UserDTO convertToDTO(User user) {
        UserDTO dto = new UserDTO();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());

        if (user.getSteamUser() != null) {
            SteamUserDTO steamUserDTO = new SteamUserDTO();
            steamUserDTO.setSteamId(user.getSteamUser().getSteamId());
            steamUserDTO.setPersonaName(user.getSteamUser().getPersonaName());
            steamUserDTO.setProfileUrl(user.getSteamUser().getProfileUrl());
            steamUserDTO.setAvatarUrl(user.getSteamUser().getAvatarUrl());
            dto.setSteamUser(steamUserDTO);
        }

        return dto;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/LudoNovaApplication.java">
package com.bht.ludonova;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@SpringBootApplication
@EntityScan("com.bht.ludonova.model")
@EnableJpaRepositories("com.bht.ludonova.repository")
public class LudoNovaApplication {
    public static void main(String[] args) {
        SpringApplication.run(LudoNovaApplication.class, args);
    }
}
</file>

<file path="src/main/resources/application.properties">
# Server Configuration
server.port=8080

# PostgreSQL Database Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=postgres
spring.datasource.password=postgres

# JPA/Hibernate Configuration
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Enable SQL initialization
spring.sql.init.mode=always

# JWT Configuration
jwt.secret=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
jwt.refresh-secret=7338782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E

# Token expiration times (in milliseconds)
# Access token: 1 hour = 3600000 ms
jwt.expiration=3600000
# Refresh token: 30 days = 2592000000 ms
jwt.refresh-expiration=2592000000

# CORS Configuration
#spring.web.cors.allowed-origins=http://localhost:3000
#spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
#spring.web.cors.allowed-headers=*
#spring.web.cors.allow-credentials=true

# CORS Configuration
cors.allowed-origins=http://localhost:3000

# Logging Configuration
logging.level.com.bht.ludonova=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# Steam Configuration
steam.api.key=${STEAM_API_KEY}
steam.return.url=${STEAM_RETURN_URL:http://localhost:3000/auth/steam/callback}
steam.realm.url=${STEAM_REALM_URL:http://localhost:3000}
</file>

<file path=".env.example">
# Steam Configuration
STEAM_API_KEY=your_steam_api_key_here
STEAM_RETURN_URL=http://localhost:3000/auth/steam/callback
</file>

<file path=".gitignore">
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

### Environment Files ###
.env
application-local.properties
application-dev.properties
application-prod.properties

### Logs ###
*.log
logs/
log/

### Docker ###
docker-compose.override.yml

### OS generated files ###
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

### Java ###
# Compiled class file
*.class

# Package Files #
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar

# virtual machine crash logs
hs_err_pid*
replay_pid*
</file>

<file path="backend-overview.md">
# LudoNova Backend Overview

The LudoNova backend is a robust and scalable **Spring Boot** application that powers the game backlog management system. It is designed with a focus on security, maintainability, and performance, ensuring a seamless experience for both developers and users.

## Understanding Spring and Spring Boot

Before diving into the architecture and components of the LudoNova backend, it's essential to understand the foundational frameworks it leverages: **Spring** and **Spring Boot**.

### What is Spring?

**Spring** is a comprehensive framework for building Java applications. It provides a wide range of features, including:

- **Dependency Injection (DI):** Allows for loose coupling of components by managing their dependencies.
- **Aspect-Oriented Programming (AOP):** Enables separation of cross-cutting concerns like logging and security.
- **Data Access:** Simplifies interactions with databases through modules like Spring JDBC and Spring Data.
- **Transaction Management:** Provides declarative transaction management for consistent data operations.
- **Model-View-Controller (MVC) Framework:** Facilitates the creation of web applications with clear separation between the model, view, and controller layers.

However, setting up a Spring application often involves extensive configuration, which can be time-consuming and error-prone.

### What is Spring Boot?

**Spring Boot** builds upon the Spring framework to simplify the development process. It offers:

- **Auto-Configuration:** Automatically configures Spring components based on the dependencies present in the project.
- **Starter POMs:** Pre-configured Maven or Gradle dependencies that simplify dependency management.
- **Embedded Servers:** Allows running applications with embedded servers like Tomcat or Jetty without the need for external deployment.
- **Production-Ready Features:** Includes metrics, health checks, and externalized configuration to prepare applications for production environments.

In essence, Spring Boot reduces the boilerplate configuration, enabling developers to focus more on business logic rather than setup.

## Architecture

The backend follows a **layered architecture**, a common design pattern in Spring Boot applications that separates concerns to enhance modularity and ease of maintenance. This structure aligns with Spring's philosophy of separation of concerns and facilitates scalability and testability. The primary layers include:

- **Controller Layer:** Handles incoming HTTP requests and maps them to appropriate services.
  
  - **Why It's Separate:** Isolating controllers ensures that request handling logic is decoupled from business logic, making the system more modular and easier to manage.

- **Service Layer:** Contains the business logic and processes data between the controller and repository layers.
  
  - **Role in Spring Boot:** Services are annotated with `@Service`, a specialization of `@Component`, which allows Spring to detect and manage them as beans. This layer orchestrates operations, enforces business rules, and acts as an intermediary between controllers and repositories.

- **Repository Layer:** Manages data persistence and interacts with the PostgreSQL database using JPA/Hibernate.
  
  - **Integration with Spring Data:** Repositories are typically interfaces annotated with `@Repository`. Spring Data JPA provides implementations at runtime, abstracting the data access layer and enabling CRUD operations without boilerplate code.

### How These Layers Work Together

1. **Request Flow:**
   - A client sends an HTTP request to the application.
   - The **Controller** receives the request and delegates processing to the **Service** layer.
   - The **Service** contains the business logic and interacts with the **Repository** to perform CRUD operations.
   - The **Repository** communicates with the PostgreSQL database to fetch or persist data.
   - The **Service** processes the data and returns the result to the **Controller**.
   - The **Controller** sends the appropriate HTTP response back to the client.

2. **Benefits of Layered Architecture:**
   - **Modularity:** Each layer has a distinct responsibility, making the codebase easier to navigate and maintain.
   - **Testability:** Layers can be tested independently, facilitating unit and integration testing.
   - **Scalability:** Allows for individual layers to be scaled or modified without affecting others.
   - **Maintainability:** Enhances code readability and simplifies the addition of new features.

## Authentication and Security

Security is a paramount concern in the LudoNova backend. Leveraging Spring Boot's robust security features, the application employs a JWT (JSON Web Token) based authentication system to ensure secure and stateless user sessions.

### Understanding Spring Security

**Spring Security** is a powerful and highly customizable authentication and access-control framework. It integrates seamlessly with Spring Boot applications, providing:

- **Authentication:** Verifies the identity of users.
- **Authorization:** Controls access to resources based on user roles and permissions.
- **Protection Against Common Vulnerabilities:** Guards against threats like CSRF, XSS, and session fixation.

### Key Components:

- **JwtTokenProvider:** Generates, validates, and parses JWT tokens. It uses HMAC-SHA for token signing with a configurable secret key and expiration time.
  
  ```java
  public String generateToken(String username) { /* ... */ }
  public String getUsernameFromJWT(String token) { /* ... */ }
  public boolean validateToken(String authToken) { /* ... */ }
  ```
  
  - **Role in Spring Security:** Acts as a utility for managing JWT operations, ensuring tokens are securely created and validated.

- **JwtAuthenticationFilter:** Intercepts incoming requests to extract and validate JWT tokens. If valid, it sets the authentication in the Spring Security context.
  
  - **Integration with Spring Boot:** Extends `OncePerRequestFilter` to ensure that each request is processed once. It leverages the `JwtTokenProvider` to manage token validation and sets the security context accordingly.

- **SecurityConfig:** Configures Spring Security, defining public and protected endpoints, setting up the authentication provider, and applying security filters.
  
  - **Configuration Highlights:**
    - **CORS:** Configures Cross-Origin Resource Sharing to allow or restrict requests from specific origins.
    - **CSRF:** Disables Cross-Site Request Forgery protection for stateless APIs.
    - **Session Management:** Configures the application to be stateless, relying solely on JWT tokens without maintaining server-side sessions.
    - **Authentication Provider:** Sets up how authentication is handled, typically using a `DaoAuthenticationProvider` that retrieves user details from a data source.

### Security Features:

- **Stateless Authentication:** No server-side sessions are maintained. All authentication is handled via JWT tokens sent with each request.
  
  - **Advantages:** Enhances scalability as the server doesn't need to store session information. It also simplifies horizontal scaling and load balancing.

- **Password Encryption:** User passwords are hashed using BCrypt to ensure they are not stored in plain text.
  
  - **Security Best Practice:** Hashing passwords protects user credentials even if the database is compromised.

- **CORS Configuration:** Restricts backend access to authorized frontend origins and specific HTTP methods.
  
  - **Purpose:** Prevents unauthorized domains from making requests to the backend, mitigating potential cross-origin attacks.

## API Endpoints

The backend exposes a set of RESTful API endpoints to manage user authentication, games, and user profiles. Leveraging Spring Boot's **Spring MVC** framework, these endpoints are defined using annotations that map HTTP requests to handler methods.

### Examples:

- **Authentication:**
  - `POST /api/auth/login`: Authenticates a user and returns a JWT token.
  - `POST /api/auth/register`: Registers a new user.

- **Games Management:**
  - `GET /api/games`: Retrieves a list of games.
  - `POST /api/games`: Adds a new game to the backlog.
  - `PUT /api/games/{id}`: Updates game details.
  - `DELETE /api/games/{id}`: Removes a game from the backlog.

- **User Profiles:**
  - `GET /api/user`: Retrieves the authenticated user's profile information.

### Leveraging Spring MVC:

- **Controllers:** Annotated with `@RestController`, these classes handle HTTP requests and return responses.
- **Request Mappings:** Methods within controllers use annotations like `@GetMapping`, `@PostMapping`, etc., to map specific HTTP methods and URLs to handler functions.
- **Response Entities:** Facilitates building HTTP responses with appropriate status codes and headers.

## Database Management

The application uses **PostgreSQL** as its primary database, with the schema managed by **JPA/Hibernate**. Spring Boot's integration with Spring Data JPA simplifies database interactions, allowing developers to work with databases using Java objects rather than writing SQL queries.

### Benefits of Using JPA/Hibernate:

- **Object-Relational Mapping (ORM):** Translates Java objects to database tables, enabling developers to interact with the database using familiar Java constructs.
- **Schema Generation:** Automatically creates and updates the database schema based on entity classes, reducing manual configuration.
- **Query Abstraction:** Provides a high-level API for querying the database, such as JPQL or the Criteria API, abstracting the underlying SQL.

### Configuration:

```properties
# application.properties
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=yourusername
spring.datasource.password=yourpassword
spring.jpa.hibernate.ddl-auto=update
```

- **spring.datasource.url:** Specifies the JDBC URL for the PostgreSQL database.
- **spring.jpa.hibernate.ddl-auto:** Determines how Hibernate handles schema generation. The `update` value ensures that the schema is automatically updated based on entity changes.

## Testing and Deployment

### Testing:

Comprehensive tests are implemented to ensure the reliability and correctness of the backend functionalities. Leveraging **Spring Boot's testing framework**, developers can write unit and integration tests with ease.

- **Running Tests:**
  
  ```bash
  ./mvnw test
  ```
  
  - **Spring Boot Test Annotations:** Annotations like `@SpringBootTest` facilitate loading the application context and testing components in an integrated environment.
  
- **Benefits:**
  - **Continuous Integration:** Ensures that new changes do not break existing functionalities.
  - **Quality Assurance:** Maintains high code quality and reliability.

### Deployment:

The backend can be containerized using **Docker** and managed with **Docker Compose**. This facilitates consistent environments across development, testing, and production.

- **Containerization with Docker:**
  
  ```bash
  docker-compose up -d
  ```
  
  - **Advantages:**
    - **Isolation:** Ensures that the application runs in a consistent environment, eliminating "it works on my machine" issues.
    - **Scalability:** Simplifies scaling services horizontally.
    - **Portability:** Enables easy deployment across different environments and cloud platforms.

### Prerequisites:

- **Java 17+:** Required to run the Spring Boot application.
- **Maven:** For building and managing dependencies.
- **Docker and Docker Compose:** For containerization and deployment.

## Integration with Frontend

The backend seamlessly integrates with the **React/Next.js** frontend of the LudoNova application. Authentication tokens are managed on the frontend and included in API requests to secure endpoints.

### API Client:

A configured Axios instance is used on the frontend to handle API requests, automatically attaching JWT tokens and handling authentication errors.

```javascript
const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});
```

- **Interceptors:** Axios interceptors can be set up to inject JWT tokens into request headers and handle responses globally, such as redirecting to the login page on a `401 Unauthorized` response.

## Conclusion

The LudoNova backend is meticulously crafted using **Spring Boot** to provide a secure, efficient, and scalable foundation for the game backlog management system. Its thoughtful layered architecture and robust security measures ensure a reliable service for users, while Spring Boot's auto-configuration and integration capabilities facilitate ease of development and maintenance. Understanding how Spring Boot orchestrates its components and leverages frameworks like Spring MVC and Spring Data JPA empowers developers to effectively manage and extend the backend functionalities.

```
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  postgres:
    image: postgres:16
    container_name: ludonova_db
    environment:
      POSTGRES_DB: ludonova
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
</file>

<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>

    <groupId>com.bht</groupId>
    <artifactId>ludonova</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>ludonova</name>
    <description>Backend for LudoNova game backlog manager</description>

    <properties>
        <java.version>17</java.version>
        <jjwt.version>0.11.5</jjwt.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- JWT Dependencies -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Development Tools -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Environment Variables -->
        <dependency>
            <groupId>me.paulschwarz</groupId>
            <artifactId>spring-dotenv</artifactId>
            <version>4.0.0</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
</file>

<file path="README.md">
# LudoNova Backend

Spring Boot backend for the LudoNova game backlog manager.

## Prerequisites

- Java 17+
- Maven
- Docker and Docker Compose

## Getting Started

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/ludonova-backend.git
   ```

2. Start the PostgreSQL database:
   ```bash
   docker-compose up -d
   ```

3. To stop and remove the container (but keep the data volume):
   ```bash
   docker-compose down
   ```

4. To remove everything including the volume:
   ```bash
   docker-compose down -v
   ```
   Remember that after a full reset, your database will be empty and you'll need to run your application to reinitialize it with any seed data (like the test user) defined in DataInitializer.java.

4. Alternatively, if you just want to restart the container without stopping and recreating it:
   ```bash
   docker restart ludonova_db
   ```

5. Run the application:
   ```bash
   ./mvnw spring-boot:run
   ```

## API Documentation

The API documentation is available at http://localhost:8080/swagger-ui.html when running in development mode.

## Database

The application uses PostgreSQL. The database schema is managed by JPA/Hibernate and will be created automatically on startup.

## Testing

Run tests with:
```bash
./mvnw test
```
```
</file>

<file path="setup.sh">
#!/bin/bash

# Navigate to the backend directory
cd ludonova-backend

# Create main directory structure
mkdir -p src/main/java/com/bht/ludonova
mkdir -p src/main/resources
mkdir -p src/test/java/com/bht/ludonova
mkdir -p src/test/resources

# Create package directories
cd src/main/java/com/bht/ludonova
mkdir config
mkdir controller
mkdir model
mkdir repository
mkdir service
mkdir security
mkdir dto
mkdir exception

# Create application.properties
cd ../../resources
echo "# Server Configuration
server.port=8080

# Database Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# JWT Configuration
jwt.secret=your-secret-key-here
jwt.expiration=86400000

# CORS Configuration
spring.web.cors.allowed-origins=http://localhost:3000
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*

# Logging Configuration
logging.level.com.bht.ludonova=DEBUG" > application.properties

# Create main application class
cd ../java/com/bht/ludonova
echo "package com.bht.ludonova;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class LudoNovaApplication {
    public static void main(String[] args) {
        SpringApplication.run(LudoNovaApplication.class, args);
    }
}" > LudoNovaApplication.java
</file>

</repository_files>
</file>

<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>

    <groupId>com.bht</groupId>
    <artifactId>ludonova</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>ludonova</name>
    <description>Backend for LudoNova game backlog manager</description>

    <properties>
        <java.version>17</java.version>
        <jjwt.version>0.11.5</jjwt.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- JWT Dependencies -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Development Tools -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Environment Variables -->
        <dependency>
            <groupId>me.paulschwarz</groupId>
            <artifactId>spring-dotenv</artifactId>
            <version>4.0.0</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
</file>

<file path="README.md">
# LudoNova Backend

Spring Boot backend for the LudoNova game backlog manager.

## Prerequisites

- Java 17+
- Maven
- Docker and Docker Compose

## Getting Started

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/ludonova-backend.git
   ```

2. Start the PostgreSQL database:
   ```bash
   docker-compose up -d
   ```

3. To stop and remove the container (but keep the data volume):
   ```bash
   docker-compose down
   ```

4. To remove everything including the volume:
   ```bash
   docker-compose down -v
   ```
   Remember that after a full reset, your database will be empty and you'll need to run your application to reinitialize it with any seed data (like the test user) defined in DataInitializer.java.

4. Alternatively, if you just want to restart the container without stopping and recreating it:
   ```bash
   docker restart ludonova_db
   ```

5. Run the application:
   ```bash
   ./mvnw spring-boot:run
   ```

## API Documentation

The API documentation is available at http://localhost:8080/swagger-ui.html when running in development mode.

## Database

The application uses PostgreSQL. The database schema is managed by JPA/Hibernate and will be created automatically on startup.

## Testing

Run tests with:
```bash
./mvnw test
```
```
</file>

<file path="setup.sh">
#!/bin/bash

# Navigate to the backend directory
cd ludonova-backend

# Create main directory structure
mkdir -p src/main/java/com/bht/ludonova
mkdir -p src/main/resources
mkdir -p src/test/java/com/bht/ludonova
mkdir -p src/test/resources

# Create package directories
cd src/main/java/com/bht/ludonova
mkdir config
mkdir controller
mkdir model
mkdir repository
mkdir service
mkdir security
mkdir dto
mkdir exception

# Create application.properties
cd ../../resources
echo "# Server Configuration
server.port=8080

# Database Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# JWT Configuration
jwt.secret=your-secret-key-here
jwt.expiration=86400000

# CORS Configuration
spring.web.cors.allowed-origins=http://localhost:3000
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*

# Logging Configuration
logging.level.com.bht.ludonova=DEBUG" > application.properties

# Create main application class
cd ../java/com/bht/ludonova
echo "package com.bht.ludonova;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class LudoNovaApplication {
    public static void main(String[] args) {
        SpringApplication.run(LudoNovaApplication.class, args);
    }
}" > LudoNovaApplication.java
</file>

</repository_files>
```

## File: pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>

    <groupId>com.bht</groupId>
    <artifactId>ludonova</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>ludonova</name>
    <description>Backend for LudoNova game backlog manager</description>

    <properties>
        <java.version>17</java.version>
        <jjwt.version>0.11.5</jjwt.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- JWT Dependencies -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Development Tools -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- DataBase Migration with Flyway -->
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>

        <!-- Environment Variables -->
        <dependency>
            <groupId>me.paulschwarz</groupId>
            <artifactId>spring-dotenv</artifactId>
            <version>4.0.0</version>
        </dependency>

        <!-- Swagger/OpenAPI -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.3.0</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-maven-plugin</artifactId>
                <version>9.22.3</version>
                <configuration>
                    <url>jdbc:postgresql://localhost:5432/ludonova</url>
                    <user>postgres</user>
                    <password>postgres</password>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

## File: README.md
```markdown
# LudoNova Backend

Spring Boot backend for the LudoNova game backlog manager.

## Prerequisites

- Java 17+
- Maven
- Docker and Docker Compose

## Getting Started

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/ludonova-backend.git
   ```

2. Start the PostgreSQL database:
   ```bash
   docker-compose up -d
   ```

3. To stop and remove the container (but keep the data volume):
   ```bash
   docker-compose down
   ```

4. To remove everything including the volume:
   ```bash
   docker-compose down -v
   ```
   Remember that after a full reset, your database will be empty and you'll need to run your application to reinitialize it with any seed data (like the test user) defined in DataInitializer.java.

4. Alternatively, if you just want to restart the container without stopping and recreating it:
   ```bash
   docker restart ludonova_db
   ```

5. Run the application:
   ```bash
   ./mvnw spring-boot:run
   ```

## API Documentation

The API documentation is available at http://localhost:8080/swagger-ui.html when running in development mode.

## Database

The application uses PostgreSQL. The database schema is managed by JPA/Hibernate and will be created automatically on startup.

## Testing

Run tests with:
```bash
./mvnw test
```
```
```

## File: setup.sh
```bash
#!/bin/bash

# Navigate to the backend directory
cd ludonova-backend

# Create main directory structure
mkdir -p src/main/java/com/bht/ludonova
mkdir -p src/main/resources
mkdir -p src/test/java/com/bht/ludonova
mkdir -p src/test/resources

# Create package directories
cd src/main/java/com/bht/ludonova
mkdir config
mkdir controller
mkdir model
mkdir repository
mkdir service
mkdir security
mkdir dto
mkdir exception

# Create application.properties
cd ../../resources
echo "# Server Configuration
server.port=8080

# Database Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# JWT Configuration
jwt.secret=your-secret-key-here
jwt.expiration=86400000

# CORS Configuration
spring.web.cors.allowed-origins=http://localhost:3000
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*

# Logging Configuration
logging.level.com.bht.ludonova=DEBUG" > application.properties

# Create main application class
cd ../java/com/bht/ludonova
echo "package com.bht.ludonova;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class LudoNovaApplication {
    public static void main(String[] args) {
        SpringApplication.run(LudoNovaApplication.class, args);
    }
}" > LudoNovaApplication.java
```
```

## File: pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>

    <groupId>com.bht</groupId>
    <artifactId>ludonova</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>ludonova</name>
    <description>Backend for LudoNova game backlog manager</description>

    <properties>
        <java.version>17</java.version>
        <jjwt.version>0.11.5</jjwt.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- JWT Dependencies -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Development Tools -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- DataBase Migration with Flyway -->
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>

        <!-- Environment Variables -->
        <dependency>
            <groupId>me.paulschwarz</groupId>
            <artifactId>spring-dotenv</artifactId>
            <version>4.0.0</version>
        </dependency>

        <!-- Swagger/OpenAPI -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.3.0</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-maven-plugin</artifactId>
                <version>9.22.3</version>
                <configuration>
                    <url>jdbc:postgresql://localhost:5432/ludonova</url>
                    <user>postgres</user>
                    <password>postgres</password>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

## File: README.md
```markdown
# LudoNova Backend

Spring Boot backend for the LudoNova game backlog manager.

## Prerequisites

- Java 17+
- Maven
- Docker and Docker Compose

## Getting Started

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/ludonova-backend.git
   ```

2. Start the PostgreSQL database:
   ```bash
   docker-compose up -d
   ```

3. To stop and remove the container (but keep the data volume):
   ```bash
   docker-compose down
   ```

4. To remove everything including the volume:
   ```bash
   docker-compose down -v
   ```
   Remember that after a full reset, your database will be empty and you'll need to run your application to reinitialize it with any seed data (like the test user) defined in DataInitializer.java.

4. Alternatively, if you just want to restart the container without stopping and recreating it:
   ```bash
   docker restart ludonova_db
   ```

5. Run the application:
   ```bash
   ./mvnw spring-boot:run
   ```

## API Documentation

The API documentation is available at http://localhost:8080/swagger-ui.html when running in development mode.

## Database

The application uses PostgreSQL. The database schema is managed by JPA/Hibernate and will be created automatically on startup.

## Testing

Run tests with:
```bash
./mvnw test
```
```
```

## File: setup.sh
```bash
#!/bin/bash

# Navigate to the backend directory
cd ludonova-backend

# Create main directory structure
mkdir -p src/main/java/com/bht/ludonova
mkdir -p src/main/resources
mkdir -p src/test/java/com/bht/ludonova
mkdir -p src/test/resources

# Create package directories
cd src/main/java/com/bht/ludonova
mkdir config
mkdir controller
mkdir model
mkdir repository
mkdir service
mkdir security
mkdir dto
mkdir exception

# Create application.properties
cd ../../resources
echo "# Server Configuration
server.port=8080

# Database Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# JWT Configuration
jwt.secret=your-secret-key-here
jwt.expiration=86400000

# CORS Configuration
spring.web.cors.allowed-origins=http://localhost:3000
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*

# Logging Configuration
logging.level.com.bht.ludonova=DEBUG" > application.properties

# Create main application class
cd ../java/com/bht/ludonova
echo "package com.bht.ludonova;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class LudoNovaApplication {
    public static void main(String[] args) {
        SpringApplication.run(LudoNovaApplication.class, args);
    }
}" > LudoNovaApplication.java
```
